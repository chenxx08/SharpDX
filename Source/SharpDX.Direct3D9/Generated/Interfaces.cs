// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 28/03/2015 21:51:11
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct3D9 {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>An application implements this interface to handle callbacks in animation sets generated by calls to <strong><see cref="SharpDX.Direct3D9.AnimationController.AdvanceTime"/></strong>.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPD3DXANIMATIONCALLBACKHANDLER type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.AnimationCallbackHandler"/> <see cref="SharpDX.Direct3D9.AnimationCallbackHandler"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.AnimationCallbackHandler"/> *LPD3DXANIMATIONCALLBACKHANDLER;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationCallbackHandler']/*"/>	
    /// <msdn-id>bb205624</msdn-id>	
    /// <unmanaged>ID3DXAnimationCallbackHandler</unmanaged>	
    /// <unmanaged-short>ID3DXAnimationCallbackHandler</unmanaged-short>	
    public partial class AnimationCallbackHandler : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.AnimationCallbackHandler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AnimationCallbackHandler(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.AnimationCallbackHandler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.AnimationCallbackHandler(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.AnimationCallbackHandler(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>The application implements this method. This method is called when a callback occurs for an animation set in one of the tracks during a  call to <strong><see cref="SharpDX.Direct3D9.AnimationController.AdvanceTime"/></strong>.</p>	
        /// </summary>	
        /// <param name="track">No documentation.</param>	
        /// <param name="callbackDataRef">No documentation.</param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message  from D3DERR or <strong>D3DXERR</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationCallbackHandler::HandleCallback']/*"/>	
        /// <msdn-id>bb205625</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationCallbackHandler::HandleCallback([In] unsigned int Track,[In] void* pCallbackData)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationCallbackHandler::HandleCallback</unmanaged-short>	
        public void HandleCallback(int track, System.IntPtr callbackDataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, (void*)callbackDataRef,((void**)(*(void**)_nativePointer))[0]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface is used to control animation functionality, connecting animation sets with the transformation frames that are being animated. The interface has methods to mix multiple animations and to modify blending parameters over time to enable smooth transitions and other effects.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Create an animation controller object with <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateAnimationController"/></strong>.</p><p>The LPD3DXANIMATIONCONTROLLER type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.AnimationController"/></strong> interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.AnimationController"/> <see cref="SharpDX.Direct3D9.AnimationController"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.AnimationController"/> *LPD3DXANIMATIONCONTROLLER;	
    /// </pre><p>The D3DXEVENTHANDLE type is defined as an event handle to animation controller events. </p><pre> typedef DWORD D3DXEVENTHANDLE;	
    /// </pre><p>The LPD3DXEVENTHANDLE type is defined as a reference to an event handle to animation controller events. </p><pre> typedef D3DXEVENTHANDLE *LPD3DXEVENTHANDLE;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController']/*"/>	
    /// <msdn-id>bb205626</msdn-id>	
    /// <unmanaged>ID3DXAnimationController</unmanaged>	
    /// <unmanaged-short>ID3DXAnimationController</unmanaged-short>	
    [Guid("ac8948ec-f86d-43e2-96de-31fc35f96d9e")]
    public partial class AnimationController : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.AnimationController"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AnimationController(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.AnimationController"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.AnimationController(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.AnimationController(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get the maximum number of animation outputs the animation controller can support.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumAnimationOutputs']/*"/>	
        /// <msdn-id>bb205634</msdn-id>	
        /// <unmanaged>GetMaxNumAnimationOutputs</unmanaged>	
        /// <unmanaged-short>GetMaxNumAnimationOutputs</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumAnimationOutputs()</unmanaged>
        public int MaxNumAnimationOutputs {
                get { return GetMaxNumAnimationOutputs(); }
        }
        
        /// <summary>	
        /// <p>Gets the maximum number of animation sets the animation controller can support.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumAnimationSets']/*"/>	
        /// <msdn-id>bb205635</msdn-id>	
        /// <unmanaged>GetMaxNumAnimationSets</unmanaged>	
        /// <unmanaged-short>GetMaxNumAnimationSets</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumAnimationSets()</unmanaged>
        public int MaxNumAnimationSets {
                get { return GetMaxNumAnimationSets(); }
        }
        
        /// <summary>	
        /// <p>Gets the maximum number of tracks in the animation controller.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The maximum number of tracks the controller can manage.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumTracks']/*"/>	
        /// <msdn-id>bb205637</msdn-id>	
        /// <unmanaged>GetMaxNumTracks</unmanaged>	
        /// <unmanaged-short>GetMaxNumTracks</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumTracks()</unmanaged>
        public int MaxNumTracks {
                get { return GetMaxNumTracks(); }
        }
        
        /// <summary>	
        /// <p>Gets the maximum number of events the animation controller can support.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumEvents']/*"/>	
        /// <msdn-id>bb205636</msdn-id>	
        /// <unmanaged>GetMaxNumEvents</unmanaged>	
        /// <unmanaged-short>GetMaxNumEvents</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumEvents()</unmanaged>
        public int MaxNumEvents {
                get { return GetMaxNumEvents(); }
        }
        
        /// <summary>	
        /// <p>Returns the number of animation sets currently registered in the animation controller.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The controller contains any number of animations sets and tracks. Animation sets can be registered with  <strong>RegisterAnimationOutput</strong>.  An animation controller created by a call  to <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> will automatically register loaded animation sets.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetNumAnimationSets']/*"/>	
        /// <msdn-id>bb205638</msdn-id>	
        /// <unmanaged>GetNumAnimationSets</unmanaged>	
        /// <unmanaged-short>GetNumAnimationSets</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetNumAnimationSets()</unmanaged>
        public int NumAnimationSets {
                get { return GetNumAnimationSets(); }
        }
        
        /// <summary>	
        /// <p>Gets the global animation time.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Animations are designed using a local animation time and mixed into global time with <strong>AdvanceTime</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetTime']/*"/>	
        /// <msdn-id>bb205640</msdn-id>	
        /// <unmanaged>GetTime</unmanaged>	
        /// <unmanaged-short>GetTime</unmanaged-short>	
        /// <unmanaged>double ID3DXAnimationController::GetTime()</unmanaged>
        public double Time {
                get { return GetTime(); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the current priority blending weight used by the animation controller.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The priority blending weight is used to blend high and low priority tracks together.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetPriorityBlend']/*"/>	
        /// <msdn-id>bb205639</msdn-id>	
        /// <unmanaged>GetPriorityBlend / SetPriorityBlend</unmanaged>	
        /// <unmanaged-short>GetPriorityBlend</unmanaged-short>	
        /// <unmanaged>float ID3DXAnimationController::GetPriorityBlend()</unmanaged>
        public float PriorityBlend {
                get { return GetPriorityBlend(); }
                set { SetPriorityBlend(value); }
        }
        
        /// <summary>	
        /// <p>Returns an event handle to a priority blend event that is currently running.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetCurrentPriorityBlend']/*"/>	
        /// <msdn-id>bb205631</msdn-id>	
        /// <unmanaged>GetCurrentPriorityBlend</unmanaged>	
        /// <unmanaged-short>GetCurrentPriorityBlend</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetCurrentPriorityBlend()</unmanaged>
        public int CurrentPriorityBlend {
                get { return GetCurrentPriorityBlend(); }
        }
        
        /// <summary>	
        /// <p>Get the maximum number of animation outputs the animation controller can support.</p>	
        /// </summary>	
        /// <returns><p>The maximum number of animation outputs the controller can manage.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumAnimationOutputs']/*"/>	
        /// <msdn-id>bb205634</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumAnimationOutputs()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetMaxNumAnimationOutputs</unmanaged-short>	
        internal int GetMaxNumAnimationOutputs() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the maximum number of animation sets the animation controller can support.</p>	
        /// </summary>	
        /// <returns><p>The maximum number of animation sets the controller can manage.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumAnimationSets']/*"/>	
        /// <msdn-id>bb205635</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumAnimationSets()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetMaxNumAnimationSets</unmanaged-short>	
        internal int GetMaxNumAnimationSets() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the maximum number of tracks in the animation controller.</p>	
        /// </summary>	
        /// <returns><p>Number of tracks.</p></returns>	
        /// <remarks>	
        /// <p>The maximum number of tracks the controller can manage.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumTracks']/*"/>	
        /// <msdn-id>bb205637</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumTracks()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetMaxNumTracks</unmanaged-short>	
        internal int GetMaxNumTracks() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the maximum number of events the animation controller can support.</p>	
        /// </summary>	
        /// <returns><p>The maximum number of events the controller can manage.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetMaxNumEvents']/*"/>	
        /// <msdn-id>bb205636</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetMaxNumEvents()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetMaxNumEvents</unmanaged-short>	
        internal int GetMaxNumEvents() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Adds an animation output to the animation controller and registers references for scale, rotate, and translate (SRT) transformations.</p>	
        /// </summary>	
        /// <param name="nameRef"><dd>  <p>Name of the animation output.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> structure containing SRT transformation data. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="scaleRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> vector that describes the scale of the animation set. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="rotationRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawQuaternion"/></strong> quaternion that describes the rotation of the animation set. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="translationRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> vector that describes the translation of the animation set. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If the animation output is already registered, pMatrix will be filled with the input transformation data.</p><p>Animation sets created with <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> automatically register all loaded animation sets.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::RegisterAnimationOutput']/*"/>	
        /// <msdn-id>bb205650</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::RegisterAnimationOutput([In] const char* pName,[In] D3DXMATRIX* pMatrix,[In] D3DXVECTOR3* pScale,[In] D3DXQUATERNION* pRotation,[In] D3DXVECTOR3* pTranslation)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::RegisterAnimationOutput</unmanaged-short>	
        public void RegisterAnimationOutput(string nameRef, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef, SharpDX.Mathematics.Interop.RawVector3 scaleRef, SharpDX.Mathematics.Interop.RawQuaternion rotationRef, SharpDX.Mathematics.Interop.RawVector3 translationRef) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)nameRef_, matrixRef_, &scaleRef, &rotationRef, &translationRef,((void**)(*(void**)_nativePointer))[7]);		
                Marshal.FreeHGlobal(nameRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds an animation set to the animation controller.</p>	
        /// </summary>	
        /// <param name="animSetRef"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.AnimationSet"/></strong> animation set to add.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::RegisterAnimationSet']/*"/>	
        /// <msdn-id>bb205651</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::RegisterAnimationSet([In] ID3DXAnimationSet* pAnimSet)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::RegisterAnimationSet</unmanaged-short>	
        public void RegisterAnimationSet(SharpDX.Direct3D9.AnimationSet animSetRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((animSetRef == null)?IntPtr.Zero:animSetRef.NativePointer),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes an animation set from the animation controller.</p>	
        /// </summary>	
        /// <param name="animSetRef"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.AnimationSet"/></strong> animation set to remove.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotFound"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::UnregisterAnimationSet']/*"/>	
        /// <msdn-id>bb205664</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::UnregisterAnimationSet([In] ID3DXAnimationSet* pAnimSet)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::UnregisterAnimationSet</unmanaged-short>	
        public void UnregisterAnimationSet(SharpDX.Direct3D9.AnimationSet animSetRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((animSetRef == null)?IntPtr.Zero:animSetRef.NativePointer),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the number of animation sets currently registered in the animation controller.</p>	
        /// </summary>	
        /// <returns><p>Number of animation sets.</p></returns>	
        /// <remarks>	
        /// <p>The controller contains any number of animations sets and tracks. Animation sets can be registered with  <strong>RegisterAnimationOutput</strong>.  An animation controller created by a call  to <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> will automatically register loaded animation sets.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetNumAnimationSets']/*"/>	
        /// <msdn-id>bb205638</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetNumAnimationSets()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetNumAnimationSets</unmanaged-short>	
        internal int GetNumAnimationSets() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets an animation set.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index of the animation set.</p> </dd></param>	
        /// <param name="animationSetOut"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.AnimationSet"/></strong> animation set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The animation controller contains an array of animation sets. This method returns one of them at the given index.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetAnimationSet']/*"/>	
        /// <msdn-id>bb205629</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::GetAnimationSet([In] unsigned int Index,[Out] ID3DXAnimationSet** ppAnimationSet)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetAnimationSet</unmanaged-short>	
        public void GetAnimationSet(int index, out SharpDX.Direct3D9.AnimationSet animationSetOut) {
            unsafe {
                IntPtr animationSetOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, &animationSetOut_,((void**)(*(void**)_nativePointer))[11]);		
                animationSetOut= (animationSetOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.AnimationSet(animationSetOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an animation set, given its name.</p>	
        /// </summary>	
        /// <param name="szName"><dd>  <p>String containing the name of the animation set.</p> </dd></param>	
        /// <param name="animationSetOut"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.AnimationSet"/></strong> animation set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The animation controller contains an array of animation sets. This method returns an animation set that has the given name.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetAnimationSetByName']/*"/>	
        /// <msdn-id>bb205630</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::GetAnimationSetByName([In] const char* szName,[In] ID3DXAnimationSet** ppAnimationSet)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetAnimationSetByName</unmanaged-short>	
        public void GetAnimationSetByName(string szName, out SharpDX.Direct3D9.AnimationSet animationSetOut) {
            unsafe {
                IntPtr szName_ = Utilities.StringToHGlobalAnsi(szName);
                IntPtr animationSetOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)szName_, &animationSetOut_,((void**)(*(void**)_nativePointer))[12]);		
                Marshal.FreeHGlobal(szName_ );
                animationSetOut= (animationSetOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.AnimationSet(animationSetOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Animates the mesh and advances the global animation time by a specified amount.</p>	
        /// </summary>	
        /// <param name="timeDelta"><dd>  <p>Amount, in seconds, by which to advance the global animation time. TimeDelta value must be non-negative or zero.</p> </dd></param>	
        /// <param name="callbackHandlerRef"><dd>  <p>Pointer to a user-defined animation callback handler interface, <strong><see cref="SharpDX.Direct3D9.AnimationCallbackHandler"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::AdvanceTime']/*"/>	
        /// <msdn-id>bb205627</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::AdvanceTime([In] double TimeDelta,[In] ID3DXAnimationCallbackHandler* pCallbackHandler)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::AdvanceTime</unmanaged-short>	
        public void AdvanceTime(double timeDelta, SharpDX.Direct3D9.AnimationCallbackHandler callbackHandlerRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, timeDelta, (void*)((callbackHandlerRef == null)?IntPtr.Zero:callbackHandlerRef.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Resets the global animation time to zero. Any pending events will retain their original schedules, but in the new timeframe.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is typically used when the global animation time value is nearing the maximum precision of DOUBLE storage, or 264 - 1.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::ResetTime']/*"/>	
        /// <msdn-id>bb205652</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::ResetTime()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::ResetTime</unmanaged-short>	
        public void ResetTime() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the global animation time.</p>	
        /// </summary>	
        /// <returns><p>Returns the global animation time.</p></returns>	
        /// <remarks>	
        /// <p>Animations are designed using a local animation time and mixed into global time with <strong>AdvanceTime</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetTime']/*"/>	
        /// <msdn-id>bb205640</msdn-id>	
        /// <unmanaged>double ID3DXAnimationController::GetTime()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetTime</unmanaged-short>	
        internal double GetTime() {
            unsafe {
                double __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callidouble(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Applies the animation set to the specified track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to which the animation set is applied.</p> </dd></param>	
        /// <param name="animSetRef"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.AnimationSet"/></strong> animation set to be added to the track.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method sets the animation set to the specified track for mixing.  The animation set for each track is blended according to the  track weight and speed when <strong>AdvanceTime</strong> is called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetTrackAnimationSet']/*"/>	
        /// <msdn-id>bb205654</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackAnimationSet([In] unsigned int Track,[In] ID3DXAnimationSet* pAnimSet)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetTrackAnimationSet</unmanaged-short>	
        public void SetTrackAnimationSet(int track, SharpDX.Direct3D9.AnimationSet animSetRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, (void*)((animSetRef == null)?IntPtr.Zero:animSetRef.NativePointer),((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the animation set for the given track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Track identifier.</p> </dd></param>	
        /// <param name="animSetOut"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.AnimationSet"/></strong> animation set for the given track.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetTrackAnimationSet']/*"/>	
        /// <msdn-id>bb205641</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::GetTrackAnimationSet([In] unsigned int Track,[Out] ID3DXAnimationSet** ppAnimSet)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetTrackAnimationSet</unmanaged-short>	
        public void GetTrackAnimationSet(int track, out SharpDX.Direct3D9.AnimationSet animSetOut) {
            unsafe {
                IntPtr animSetOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, &animSetOut_,((void**)(*(void**)_nativePointer))[17]);		
                animSetOut= (animSetOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.AnimationSet(animSetOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the priority blending weight for the specified animation track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Track identifier.</p> </dd></param>	
        /// <param name="priority"><dd>  <p>Track priority. This parameter should be set to one of the constants from <strong><see cref="SharpDX.Direct3D9.TrackPriority"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetTrackPriority']/*"/>	
        /// <msdn-id>bb205658</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackPriority([In] unsigned int Track,[In] D3DXPRIORITY_TYPE Priority)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetTrackPriority</unmanaged-short>	
        public void SetTrackPriority(int track, SharpDX.Direct3D9.TrackPriority priority) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, unchecked((int)priority),((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the track speed. The track speed is similar to a multiplier that is used to speed up or slow down the playback of the track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to set the speed on.</p> </dd></param>	
        /// <param name="speed"><dd>  <p>New speed.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetTrackSpeed']/*"/>	
        /// <msdn-id>bb205659</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackSpeed([In] unsigned int Track,[In] float Speed)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetTrackSpeed</unmanaged-short>	
        public void SetTrackSpeed(int track, float speed) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, speed,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the track weight. The weight is used to determine how to blend multiple tracks together.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to set the weight on.</p> </dd></param>	
        /// <param name="weight"><dd>  <p>Weight value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetTrackWeight']/*"/>	
        /// <msdn-id>bb205660</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackWeight([In] unsigned int Track,[In] float Weight)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetTrackWeight</unmanaged-short>	
        public void SetTrackWeight(int track, float weight) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, weight,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the track to the specified local animation time.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Track identifier.</p> </dd></param>	
        /// <param name="position"><dd>  <p>Local animation time value to assign to the track.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetTrackPosition']/*"/>	
        /// <msdn-id>bb205657</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackPosition([In] unsigned int Track,[In] double Position)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetTrackPosition</unmanaged-short>	
        public void SetTrackPosition(int track, double position) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, position,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Enables or disables a track in the animation controller.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to be mixed.</p> </dd></param>	
        /// <param name="enable"><dd>  <p>Enable value. Set to <strong>TRUE</strong> to enable this track in the controller, or to <strong><see cref="SharpDX.Result.False"/></strong> to prevent it from being mixed.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>To mix a track with other tracks, the Enable flag must be set to <strong>TRUE</strong>. Conversely, setting the flag to <strong><see cref="SharpDX.Result.False"/></strong> will prevent the track from being  mixed with other tracks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetTrackEnable']/*"/>	
        /// <msdn-id>bb205656</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackEnable([In] unsigned int Track,[In] BOOL Enable)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetTrackEnable</unmanaged-short>	
        public void SetTrackEnable(int track, SharpDX.Mathematics.Interop.RawBool enable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint28(_nativePointer, track, enable,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the track description.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to modify.</p> </dd></param>	
        /// <param name="descRef"><dd>  <p>Description of the track.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetTrackDesc']/*"/>	
        /// <msdn-id>bb205655</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetTrackDesc([In] unsigned int Track,[In] D3DXTRACK_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetTrackDesc</unmanaged-short>	
        public void SetTrackDescription(int track, ref SharpDX.Direct3D9.TrackDescription descRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, descRef_,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the track description.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Track identifier.</p> </dd></param>	
        /// <param name="descRef"><dd>  <p>Pointer to the track description. See <strong><see cref="SharpDX.Direct3D9.TrackDescription"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetTrackDesc']/*"/>	
        /// <msdn-id>bb205642</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::GetTrackDesc([In] unsigned int Track,[In] D3DXTRACK_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetTrackDesc</unmanaged-short>	
        public void GetTrackDescription(int track, ref SharpDX.Direct3D9.TrackDescription descRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, descRef_,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the priority blending weight used by the animation controller.</p>	
        /// </summary>	
        /// <param name="blendWeight"><dd>  <p>Priority blending weight used by the animation controller.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The blend weight is used to blend high and low priority tracks together.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::SetPriorityBlend']/*"/>	
        /// <msdn-id>bb205653</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::SetPriorityBlend([In] float BlendWeight)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::SetPriorityBlend</unmanaged-short>	
        internal void SetPriorityBlend(float blendWeight) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, blendWeight,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the current priority blending weight used by the animation controller.</p>	
        /// </summary>	
        /// <returns><p>Returns the current priority blending weight.</p></returns>	
        /// <remarks>	
        /// <p>The priority blending weight is used to blend high and low priority tracks together.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetPriorityBlend']/*"/>	
        /// <msdn-id>bb205639</msdn-id>	
        /// <unmanaged>float ID3DXAnimationController::GetPriorityBlend()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetPriorityBlend</unmanaged-short>	
        internal float GetPriorityBlend() {
            unsafe {
                float __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callifloat(_nativePointer,((void**)(*(void**)_nativePointer))[26]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets an event key that changes the rate of play of an animation track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to modify.</p> </dd></param>	
        /// <param name="newSpeed"><dd>  <p>New speed of the animation track.</p> </dd></param>	
        /// <param name="startTime"><dd>  <p>Global time key. Specifies the global time when the change will take place.</p> </dd></param>	
        /// <param name="duration"><dd>  <p>Transition time, which specifies how long the smooth transition will take to complete.</p> </dd></param>	
        /// <param name="transition"><dd>  <p>Specifies the transition type used for transitioning between speeds. See <strong><see cref="SharpDX.Direct3D9.TransitionType"/></strong>.</p> </dd></param>	
        /// <returns><p>Event handle to the priority blend event. <strong><c>null</c></strong> is returned if one or more of the input parameters is invalid, or no free event is available.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::KeyTrackSpeed']/*"/>	
        /// <msdn-id>bb205648</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::KeyTrackSpeed([In] unsigned int Track,[In] float NewSpeed,[In] double StartTime,[In] double Duration,[In] D3DXTRANSITION_TYPE Transition)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::KeyTrackSpeed</unmanaged-short>	
        public int KeyTrackSpeed(int track, float newSpeed, double startTime, double duration, SharpDX.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, newSpeed, startTime, duration, unchecked((int)transition),((void**)(*(void**)_nativePointer))[27]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets an event key that changes the weight of an animation track. The weight is used as a multiplier when combining multiple tracks together.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to modify.</p> </dd></param>	
        /// <param name="newWeight"><dd>  <p>New weight of the track.</p> </dd></param>	
        /// <param name="startTime"><dd>  <p>Global time key. Specifies the global time when the change will take place.</p> </dd></param>	
        /// <param name="duration"><dd>  <p>Transition time, which specifies how long the smooth transition will take to complete.</p> </dd></param>	
        /// <param name="transition"><dd>  <p>Specifies the transition type used for transitioning between weights. See <strong><see cref="SharpDX.Direct3D9.TransitionType"/></strong>.</p> </dd></param>	
        /// <returns><p>Event handle to the priority blend event. <strong><c>null</c></strong> is returned if one or more of the input parameters is invalid, or no free event is available.</p></returns>	
        /// <remarks>	
        /// <p>The weight is used like a multiplier to determine how much of this track to blend together with other tracks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::KeyTrackWeight']/*"/>	
        /// <msdn-id>bb205649</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::KeyTrackWeight([In] unsigned int Track,[In] float NewWeight,[In] double StartTime,[In] double Duration,[In] D3DXTRANSITION_TYPE Transition)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::KeyTrackWeight</unmanaged-short>	
        public int KeyTrackWeight(int track, float newWeight, double startTime, double duration, SharpDX.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, newWeight, startTime, duration, unchecked((int)transition),((void**)(*(void**)_nativePointer))[28]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets an event key that changes the local time of an animation track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track to modify.</p> </dd></param>	
        /// <param name="newPosition"><dd>  <p>New local time of the animation track.</p> </dd></param>	
        /// <param name="startTime"><dd>  <p>Global time key. Specifies the global time when the change will take place.</p> </dd></param>	
        /// <returns><p>Event handle to the priority blend event. <strong><c>null</c></strong> is returned if Track is invalid, or if no free event is available.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::KeyTrackPosition']/*"/>	
        /// <msdn-id>bb205647</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::KeyTrackPosition([In] unsigned int Track,[In] double NewPosition,[In] double StartTime)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::KeyTrackPosition</unmanaged-short>	
        public int KeyTrackPosition(int track, double newPosition, double startTime) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, newPosition, startTime,((void**)(*(void**)_nativePointer))[29]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets an event key that enables or disables an animation track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the animation track to modify.</p> </dd></param>	
        /// <param name="newEnable"><dd>  <p>Enable flag. Set this to <strong>TRUE</strong> to enable the animation track, or to <strong><see cref="SharpDX.Result.False"/></strong> to disable the track.</p> </dd></param>	
        /// <param name="startTime"><dd>  <p>Global time key. Specifies the global time when the change will take place.</p> </dd></param>	
        /// <returns><p>Event handle to the priority blend event. <strong><c>null</c></strong> is returned if Track is invalid.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::KeyTrackEnable']/*"/>	
        /// <msdn-id>bb205646</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::KeyTrackEnable([In] unsigned int Track,[In] BOOL NewEnable,[In] double StartTime)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::KeyTrackEnable</unmanaged-short>	
        public int KeyTrackEnable(int track, SharpDX.Mathematics.Interop.RawBool newEnable, double startTime) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint73(_nativePointer, track, newEnable, startTime,((void**)(*(void**)_nativePointer))[30]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets blending event keys for the specified animation track.</p>	
        /// </summary>	
        /// <param name="newBlendWeight"><dd>  <p>Number between 0 and 1 that is used to blend tracks together.</p> </dd></param>	
        /// <param name="startTime"><dd>  <p>Global time to start the blend.</p> </dd></param>	
        /// <param name="duration"><dd>  <p>Global time duration of the blend.</p> </dd></param>	
        /// <param name="transition"><dd>  <p>Specifies the transition type used for the duration of the blend. See <strong><see cref="SharpDX.Direct3D9.TransitionType"/></strong>.</p> </dd></param>	
        /// <returns><p>Event handle to the priority blend event. <strong><c>null</c></strong> is returned if one or more of the input parameters is invalid, or no free event is available.</p></returns>	
        /// <remarks>	
        /// <p>The animation controller blends in three phases: low priority tracks are blended first, high priority tracks are blended second, and  then the results of both are blended.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::KeyPriorityBlend']/*"/>	
        /// <msdn-id>bb205645</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::KeyPriorityBlend([In] float NewBlendWeight,[In] double StartTime,[In] double Duration,[In] D3DXTRANSITION_TYPE Transition)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::KeyPriorityBlend</unmanaged-short>	
        public int KeyPriorityBlend(float newBlendWeight, double startTime, double duration, SharpDX.Direct3D9.TransitionType transition) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, newBlendWeight, startTime, duration, unchecked((int)transition),((void**)(*(void**)_nativePointer))[31]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Removes a specified event from an animation track, preventing the execution of the event.</p>	
        /// </summary>	
        /// <param name="hEvent"><dd>  <p>Event handle to the event to be removed from the animation track.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::UnkeyEvent']/*"/>	
        /// <msdn-id>bb205663</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::UnkeyEvent([In] unsigned int hEvent)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::UnkeyEvent</unmanaged-short>	
        public void UnkeyEvent(int hEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hEvent,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes all events from a specified animation track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Identifier of the track on which all events should be removed.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method prevents the execution of all events previously scheduled on the track, and discards all data associated with those events.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::UnkeyAllTrackEvents']/*"/>	
        /// <msdn-id>bb205662</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::UnkeyAllTrackEvents([In] unsigned int Track)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::UnkeyAllTrackEvents</unmanaged-short>	
        public void UnkeyAllTrackEvents(int track) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track,((void**)(*(void**)_nativePointer))[33]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes all scheduled priority blend events from the animation controller.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::UnkeyAllPriorityBlends']/*"/>	
        /// <msdn-id>bb205661</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::UnkeyAllPriorityBlends()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::UnkeyAllPriorityBlends</unmanaged-short>	
        public void UnkeyAllPriorityBlends() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns an event handle to the event currently running on the specified animation track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Track identifier.</p> </dd></param>	
        /// <param name="eventType"><dd>  <p>Type of event to query.</p> </dd></param>	
        /// <returns><p>Event handle to the event currently running on the specified track. <strong><c>null</c></strong> is returned if no event is running on the specified track.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetCurrentTrackEvent']/*"/>	
        /// <msdn-id>bb205632</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetCurrentTrackEvent([In] unsigned int Track,[In] D3DXEVENT_TYPE EventType)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetCurrentTrackEvent</unmanaged-short>	
        public int GetCurrentTrackEvent(int track, SharpDX.Direct3D9.EventType eventType) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, unchecked((int)eventType),((void**)(*(void**)_nativePointer))[35]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns an event handle to a priority blend event that is currently running.</p>	
        /// </summary>	
        /// <returns><p>Event handle to the currently running priority blend event. <strong><c>null</c></strong> is returned if no priority blend event is currently running.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetCurrentPriorityBlend']/*"/>	
        /// <msdn-id>bb205631</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetCurrentPriorityBlend()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetCurrentPriorityBlend</unmanaged-short>	
        internal int GetCurrentPriorityBlend() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[36]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns an event handle to the next event scheduled to occur after a specified event on an animation track.</p>	
        /// </summary>	
        /// <param name="track"><dd>  <p>Track identifier.</p> </dd></param>	
        /// <param name="hEvent"><dd>  <p>Event handle to a specified event after which to search for a following event. If set to <strong><c>null</c></strong>, then the method will return the next scheduled event.</p> </dd></param>	
        /// <returns><p>Event handle to the next event scheduled to run on the specified track. <strong><c>null</c></strong> is returned if no new event is scheduled.</p></returns>	
        /// <remarks>	
        /// <p>This method can be used iteratively to locate a desired event by repeatedly passing in <strong><c>null</c></strong> for hEvent.</p><p><strong>Note</strong>??Do not iterate further after the method has returned <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetUpcomingTrackEvent']/*"/>	
        /// <msdn-id>bb205644</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetUpcomingTrackEvent([In] unsigned int Track,[In] unsigned int hEvent)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetUpcomingTrackEvent</unmanaged-short>	
        public int GetUpcomingTrackEvent(int track, int hEvent) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, track, hEvent,((void**)(*(void**)_nativePointer))[37]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns an event handle to the next priority blend event scheduled to occur after a specified event.</p>	
        /// </summary>	
        /// <param name="hEvent"><dd>  <p>Event handle to a specified event after which to search for a following priority blend event. If set to <strong><c>null</c></strong>, then the method will  return the next scheduled priority blend event.</p> </dd></param>	
        /// <returns><p>Event handle to the next scheduled priority blend event. <strong><c>null</c></strong> is returned if no new priority blend event is scheduled.</p></returns>	
        /// <remarks>	
        /// <p>This method can be used iteratively to locate a desired priority blend event by repeatedly passing in <strong><c>null</c></strong> for hEvent.</p><p><strong>Note</strong>??Do not iterate further after the method has returned <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetUpcomingPriorityBlend']/*"/>	
        /// <msdn-id>bb205643</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationController::GetUpcomingPriorityBlend([In] unsigned int hEvent)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetUpcomingPriorityBlend</unmanaged-short>	
        public int GetUpcomingPriorityBlend(int hEvent) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hEvent,((void**)(*(void**)_nativePointer))[38]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Checks whether a specified event handle is valid and the animation event has not yet completed.</p>	
        /// </summary>	
        /// <param name="hEvent"><dd>  <p>Event handle to an animation event.</p> </dd></param>	
        /// <returns><p>Returns <see cref="SharpDX.Result.Ok"/> if the event handle is valid and the event has not yet completed.</p><p>Returns E_FAIL if the event handle is invalid and/or the event has completed.</p></returns>	
        /// <remarks>	
        /// <p>The method will indicate that an event handle is valid even if the event is running but has not yet completed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::ValidateEvent']/*"/>	
        /// <msdn-id>bb205665</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::ValidateEvent([In] unsigned int hEvent)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::ValidateEvent</unmanaged-short>	
        public void ValidateEvent(int hEvent) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hEvent,((void**)(*(void**)_nativePointer))[39]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a description of a specified animation event.</p>	
        /// </summary>	
        /// <param name="hEvent"><dd>  <p>Event handle to an animation event to describe.</p> </dd></param>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.EventDescription"/></strong> structure that contains a description of the animation event.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::GetEventDesc']/*"/>	
        /// <msdn-id>bb205633</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::GetEventDesc([In] unsigned int hEvent,[In] D3DXEVENT_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::GetEventDesc</unmanaged-short>	
        public void GetEventDescription(int hEvent, ref SharpDX.Direct3D9.EventDescription descRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hEvent, descRef_,((void**)(*(void**)_nativePointer))[40]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Clones, or copies, an animation controller.</p>	
        /// </summary>	
        /// <param name="maxNumAnimationOutputs"><dd>  <p>Maximum number of animation outputs the controller can support.</p> </dd></param>	
        /// <param name="maxNumAnimationSets"><dd>  <p>Maximum number of animation sets the controller can support.</p> </dd></param>	
        /// <param name="maxNumTracks"><dd>  <p>Maximum number of tracks the controller can support.</p> </dd></param>	
        /// <param name="maxNumEvents"><dd>  <p>Maximum number of events the controller can support.</p> </dd></param>	
        /// <param name="animControllerOut"><dd>  <p>Address of a reference to the cloned <strong><see cref="SharpDX.Direct3D9.AnimationController"/></strong> animation controller.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following  values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationController::CloneAnimationController']/*"/>	
        /// <msdn-id>bb205628</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationController::CloneAnimationController([In] unsigned int MaxNumAnimationOutputs,[In] unsigned int MaxNumAnimationSets,[In] unsigned int MaxNumTracks,[In] unsigned int MaxNumEvents,[In] ID3DXAnimationController** ppAnimController)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationController::CloneAnimationController</unmanaged-short>	
        public void CloneAnimationController(int maxNumAnimationOutputs, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out SharpDX.Direct3D9.AnimationController animControllerOut) {
            unsafe {
                IntPtr animControllerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, maxNumAnimationOutputs, maxNumAnimationSets, maxNumTracks, maxNumEvents, &animControllerOut_,((void**)(*(void**)_nativePointer))[41]);		
                animControllerOut= (animControllerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.AnimationController(animControllerOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface encapsulates the minimum functionality required of an animation set by an animation controller. Advanced users might want to implement this interface themselves to suit their specialized needs; for most users, however, the derived <strong><see cref="SharpDX.Direct3D9.CompressedAnimationSet"/></strong> and <strong><see cref="SharpDX.Direct3D9.KeyframedAnimationSet"/></strong> interfaces should suffice.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An animation set consists of animations for many nodes for the same animation.</p><p>The LPD3DXANIMATIONSET type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.AnimationSet"/> <see cref="SharpDX.Direct3D9.AnimationSet"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.AnimationSet"/> *LPD3DXANIMATIONSET;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet']/*"/>	
    /// <msdn-id>bb205667</msdn-id>	
    /// <unmanaged>ID3DXAnimationSet</unmanaged>	
    /// <unmanaged-short>ID3DXAnimationSet</unmanaged-short>	
    [Guid("698cfb3f-9289-4d95-9a57-33a94b5a65f9")]
    public partial class AnimationSet : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.AnimationSet"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public AnimationSet(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.AnimationSet"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.AnimationSet(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.AnimationSet(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the animation set name.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetName']/*"/>	
        /// <msdn-id>bb205671</msdn-id>	
        /// <unmanaged>GetName</unmanaged>	
        /// <unmanaged-short>GetName</unmanaged-short>	
        /// <unmanaged>const char* ID3DXAnimationSet::GetName()</unmanaged>
        public string Name {
                get { return GetName(); }
        }
        
        /// <summary>	
        /// <p>Gets the period of the animation set.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The period is the range of time that the animation key frames are valid. For looping animations, this is the period of the loop. The time units that the key frames are specified in (for example, seconds) is determined by the application. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetPeriod']/*"/>	
        /// <msdn-id>bb205673</msdn-id>	
        /// <unmanaged>GetPeriod</unmanaged>	
        /// <unmanaged-short>GetPeriod</unmanaged-short>	
        /// <unmanaged>double ID3DXAnimationSet::GetPeriod()</unmanaged>
        public double Period {
                get { return GetPeriod(); }
        }
        
        /// <summary>	
        /// <p>Gets the number of animations in the animation set.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetNumAnimations']/*"/>	
        /// <msdn-id>bb205672</msdn-id>	
        /// <unmanaged>GetNumAnimations</unmanaged>	
        /// <unmanaged-short>GetNumAnimations</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXAnimationSet::GetNumAnimations()</unmanaged>
        public int NumAnimations {
                get { return GetNumAnimations(); }
        }
        
        /// <summary>	
        /// <p>Gets the animation set name.</p>	
        /// </summary>	
        /// <returns><p>Name of the animation set.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetName']/*"/>	
        /// <msdn-id>bb205671</msdn-id>	
        /// <unmanaged>const char* ID3DXAnimationSet::GetName()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetName</unmanaged-short>	
        internal string GetName() {
            unsafe {
                string __result__;
                __result__= 
				Marshal.PtrToStringAnsi(SharpDX.Direct3D9.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[3]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the period of the animation set.</p>	
        /// </summary>	
        /// <returns><p>Period of the animation set.</p></returns>	
        /// <remarks>	
        /// <p>The period is the range of time that the animation key frames are valid. For looping animations, this is the period of the loop. The time units that the key frames are specified in (for example, seconds) is determined by the application. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetPeriod']/*"/>	
        /// <msdn-id>bb205673</msdn-id>	
        /// <unmanaged>double ID3DXAnimationSet::GetPeriod()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetPeriod</unmanaged-short>	
        internal double GetPeriod() {
            unsafe {
                double __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callidouble(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns time position in the local timeframe of an animation set.</p>	
        /// </summary>	
        /// <param name="position"><dd>  <p>Local time of the animation set.</p> </dd></param>	
        /// <returns><p>Time position as measured in the timeframe of the animation set. This value will be bounded by the period of the animation set.</p></returns>	
        /// <remarks>	
        /// <p>The time position returned by this method can be used as the PeriodicPosition parameter of <strong><see cref="SharpDX.Direct3D9.AnimationSet.GetSRT"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetPeriodicPosition']/*"/>	
        /// <msdn-id>bb205674</msdn-id>	
        /// <unmanaged>double ID3DXAnimationSet::GetPeriodicPosition([In] double Position)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetPeriodicPosition</unmanaged-short>	
        public double GetPeriodicPosition(double position) {
            unsafe {
                double __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callidouble(_nativePointer, position,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of animations in the animation set.</p>	
        /// </summary>	
        /// <returns><p>Number of animations in the animation set.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetNumAnimations']/*"/>	
        /// <msdn-id>bb205672</msdn-id>	
        /// <unmanaged>unsigned int ID3DXAnimationSet::GetNumAnimations()</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetNumAnimations</unmanaged-short>	
        internal int GetNumAnimations() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the name of an animation, given its index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index of the animation.</p> </dd></param>	
        /// <param name="nameOut"><dd>  <p>Address of a reference to a string that receives the animation name.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetAnimationNameByIndex']/*"/>	
        /// <msdn-id>bb205669</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetAnimationNameByIndex([In] unsigned int Index,[In] const char** ppName)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetAnimationNameByIndex</unmanaged-short>	
        public void GetAnimationNameByIndex(int index, string nameOut) {
            unsafe {
                IntPtr nameOut_ = Utilities.StringToHGlobalAnsi(nameOut);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, (void*)nameOut_,((void**)(*(void**)_nativePointer))[7]);		
                Marshal.FreeHGlobal(nameOut_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the index of an animation, given its name.</p>	
        /// </summary>	
        /// <param name="nameRef"><dd>  <p>Name of the animation.</p> </dd></param>	
        /// <param name="indexRef"><dd>  <p>Pointer to the animation index.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetAnimationIndexByName']/*"/>	
        /// <msdn-id>bb205668</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetAnimationIndexByName([In] const char* pName,[In] unsigned int* pIndex)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetAnimationIndexByName</unmanaged-short>	
        public void GetAnimationIndexByName(string nameRef, int indexRef) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)nameRef_, &indexRef,((void**)(*(void**)_nativePointer))[8]);		
                Marshal.FreeHGlobal(nameRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the scale, rotation, and translation values of the animation set.</p>	
        /// </summary>	
        /// <param name="periodicPosition"><dd>  <p>Position of the animation set. The position can be obtained by calling <strong><see cref="SharpDX.Direct3D9.AnimationSet.GetPeriodicPosition"/></strong>.</p> </dd></param>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="scaleRef"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> vector that describes the scale of the animation set.</p> </dd></param>	
        /// <param name="rotationRef"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Mathematics.Interop.RawQuaternion"/></strong> quaternion that describes the rotation of the animation set.</p> </dd></param>	
        /// <param name="translationRef"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> vector that describes the translation of the animation set.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetSRT']/*"/>	
        /// <msdn-id>bb205675</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetSRT([In] double PeriodicPosition,[In] unsigned int Animation,[Out] D3DXVECTOR3* pScale,[Out] D3DXQUATERNION* pRotation,[Out] D3DXVECTOR3* pTranslation)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetSRT</unmanaged-short>	
        public void GetSRT(double periodicPosition, int animation, out SharpDX.Mathematics.Interop.RawVector3 scaleRef, out SharpDX.Mathematics.Interop.RawQuaternion rotationRef, out SharpDX.Mathematics.Interop.RawVector3 translationRef) {
            unsafe {
                scaleRef = new SharpDX.Mathematics.Interop.RawVector3();
                rotationRef = new SharpDX.Mathematics.Interop.RawQuaternion();
                translationRef = new SharpDX.Mathematics.Interop.RawVector3();
                SharpDX.Result __result__;
                fixed (void* scaleRef_ = &scaleRef)
                    fixed (void* rotationRef_ = &rotationRef)
                        fixed (void* translationRef_ = &translationRef)
                            __result__= 
            				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, periodicPosition, animation, scaleRef_, rotationRef_, translationRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets information about a specific callback in the animation set.</p>	
        /// </summary>	
        /// <param name="position"><dd>  <p>Position from which to find callbacks.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Callback search flags. This parameter can be set to a combination of one or more flags from <strong><see cref="SharpDX.Direct3D9.CallbackSearchFlags"/></strong>.</p> </dd></param>	
        /// <param name="callbackPositionRef"><dd>  <p>Pointer to the position of the callback.</p> </dd></param>	
        /// <param name="callbackDataOut"><dd>  <p>Address of the callback data reference.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAnimationSet::GetCallback']/*"/>	
        /// <msdn-id>bb205670</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAnimationSet::GetCallback([In] double Position,[In] unsigned int Flags,[Out] double* pCallbackPosition,[In] void** ppCallbackData)</unmanaged>	
        /// <unmanaged-short>ID3DXAnimationSet::GetCallback</unmanaged-short>	
        public void GetCallback(double position, int flags, out double callbackPositionRef, System.IntPtr callbackDataOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* callbackPositionRef_ = &callbackPositionRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, position, flags, callbackPositionRef_, (void*)callbackDataOut,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect']/*"/>	
    /// <msdn-id>bb280470</msdn-id>	
    /// <unmanaged>ID3DXBaseEffect</unmanaged>	
    /// <unmanaged-short>ID3DXBaseEffect</unmanaged-short>	
    [Guid("017c18ac-103f-4417-8c51-6bf6ef1e56be")]
    public partial class BaseEffect : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.BaseEffect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BaseEffect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.BaseEffect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.BaseEffect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.BaseEffect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the effect description.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetDesc']/*"/>	
        /// <msdn-id>bb205681</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetDesc([Out] D3DXEFFECT_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.EffectDescription Description {
                get { SharpDX.Direct3D9.EffectDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the effect description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Returns a description of the effect. See <strong><see cref="SharpDX.Direct3D9.EffectDescription"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetDesc']/*"/>	
        /// <msdn-id>bb205681</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetDesc([Out] D3DXEFFECT_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.EffectDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D9.EffectDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[3]);		
                descRef = new SharpDX.Direct3D9.EffectDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a parameter or annotation description.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Parameter or annotation handle. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a description of the specified parameter or annotation. See <strong><see cref="SharpDX.Direct3D9.ParameterDescription"/></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetParameterDesc']/*"/>	
        /// <msdn-id>bb205698</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetParameterDesc([In] D3DXHANDLE hParameter,[Out] D3DXPARAMETER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetParameterDesc</unmanaged-short>	
        public SharpDX.Direct3D9.ParameterDescription GetParameterDescription(SharpDX.Direct3D9.EffectHandle hParameter) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Direct3D9.ParameterDescription descRef;
                var descRef_ = new SharpDX.Direct3D9.ParameterDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, &descRef_,((void**)(*(void**)_nativePointer))[4]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                descRef = new SharpDX.Direct3D9.ParameterDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Gets a technique description.</p>	
        /// </summary>	
        /// <param name="hTechnique"><dd>  <p>Technique handle. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a description of the technique. See <strong><see cref="SharpDX.Direct3D9.TechniqueDescription"/></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetTechniqueDesc']/*"/>	
        /// <msdn-id>bb205707</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetTechniqueDesc([In] D3DXHANDLE hTechnique,[Out] D3DXTECHNIQUE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetTechniqueDesc</unmanaged-short>	
        public SharpDX.Direct3D9.TechniqueDescription GetTechniqueDescription(SharpDX.Direct3D9.EffectHandle hTechnique) {
            unsafe {
                var hTechnique_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hTechnique, ref hTechnique_);
                SharpDX.Direct3D9.TechniqueDescription descRef;
                var descRef_ = new SharpDX.Direct3D9.TechniqueDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hTechnique_, &descRef_,((void**)(*(void**)_nativePointer))[5]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hTechnique, ref hTechnique_);
                descRef = new SharpDX.Direct3D9.TechniqueDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Gets a pass description.</p>	
        /// </summary>	
        /// <param name="hPass"><dd>  <p>Pass handle. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a description of the specified pass. See <strong><see cref="SharpDX.Direct3D9.PassDescription"/></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??If an effect is created with <see cref="SharpDX.Direct3D9.FX.NotCloneable"/>, this method will return <strong><c>null</c></strong> references (in <strong><see cref="SharpDX.Direct3D9.PassDescription"/></strong>) to the shader functions.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetPassDesc']/*"/>	
        /// <msdn-id>bb205702</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetPassDesc([In] D3DXHANDLE hPass,[Out] D3DXPASS_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetPassDesc</unmanaged-short>	
        public SharpDX.Direct3D9.PassDescription GetPassDescription(SharpDX.Direct3D9.EffectHandle hPass) {
            unsafe {
                var hPass_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hPass, ref hPass_);
                SharpDX.Direct3D9.PassDescription descRef;
                var descRef_ = new SharpDX.Direct3D9.PassDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hPass_, &descRef_,((void**)(*(void**)_nativePointer))[6]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hPass, ref hPass_);
                descRef = new SharpDX.Direct3D9.PassDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Gets a function description.</p>	
        /// </summary>	
        /// <param name="hShader"><dd>  <p>Function handle. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a description of the function. See <strong><see cref="SharpDX.Direct3D9.FunctionDescription"/></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetFunctionDesc']/*"/>	
        /// <msdn-id>bb205686</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetFunctionDesc([In] D3DXHANDLE hShader,[Out] D3DXFUNCTION_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetFunctionDesc</unmanaged-short>	
        public SharpDX.Direct3D9.FunctionDescription GetFunctionDescription(SharpDX.Direct3D9.EffectHandle hShader) {
            unsafe {
                var hShader_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hShader, ref hShader_);
                SharpDX.Direct3D9.FunctionDescription descRef;
                var descRef_ = new SharpDX.Direct3D9.FunctionDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hShader_, &descRef_,((void**)(*(void**)_nativePointer))[7]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hShader, ref hShader_);
                descRef = new SharpDX.Direct3D9.FunctionDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a top-level parameter or a structure member parameter.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Handle of the parameter, or <strong><c>null</c></strong> for top-level parameters. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="index"><dd>  <p>Parameter index.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified parameter, or <strong><c>null</c></strong> if the index was invalid. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetParameter']/*"/>	
        /// <msdn-id>bb205695</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameter([In] D3DXHANDLE hParameter,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetParameter</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetParameter(SharpDX.Direct3D9.EffectHandle hParameter, int index) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hParameter_, index,((void**)(*(void**)_nativePointer))[8]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a top-level parameter or a structure member parameter by looking up its name.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Handle of the parameter, or <strong><c>null</c></strong> for top-level parameters. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="nameRef"><dd>  <p>String containing the parameter name.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified parameter, or <strong><c>null</c></strong> if the index was invalid. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetParameterByName']/*"/>	
        /// <msdn-id>bb205696</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameterByName([In] D3DXHANDLE hParameter,[In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetParameterByName</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetParameter(SharpDX.Direct3D9.EffectHandle hParameter, string nameRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hParameter_, (void*)nameRef_,((void**)(*(void**)_nativePointer))[9]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a top-level parameter or a structure member parameter by looking up its semantic with a case-insensitive search.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Handle of the parameter, or <strong><c>null</c></strong> for top-level parameters. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="semanticRef"><dd>  <p>String containing the semantic name.</p> </dd></param>	
        /// <returns><p>Returns the handle of the first parameter that matches the specified semantic, or <strong><c>null</c></strong> if the semantic was not found. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetParameterBySemantic']/*"/>	
        /// <msdn-id>bb205697</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameterBySemantic([In] D3DXHANDLE hParameter,[In] const char* pSemantic)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetParameterBySemantic</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetParameterBySemantic(SharpDX.Direct3D9.EffectHandle hParameter, string semanticRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                IntPtr semanticRef_ = Utilities.StringToHGlobalAnsi(semanticRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hParameter_, (void*)semanticRef_,((void**)(*(void**)_nativePointer))[10]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                Marshal.FreeHGlobal(semanticRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the handle of an array element parameter.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Handle of the array. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="index"><dd>  <p>Array element index.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified parameter, or <strong><c>null</c></strong> if either hParameter or ElementIndex is invalid.  See Handles (Direct3D 9).</p></returns>	
        /// <remarks>	
        /// <p>This method is used to get an element of a parameter that is an array.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetParameterElement']/*"/>	
        /// <msdn-id>bb205699</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetParameterElement([In] D3DXHANDLE hParameter,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetParameterElement</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetParameterElement(SharpDX.Direct3D9.EffectHandle hParameter, int index) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hParameter_, index,((void**)(*(void**)_nativePointer))[11]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a technique.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Technique index.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified technique, or <strong><c>null</c></strong> if the index was invalid. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetTechnique']/*"/>	
        /// <msdn-id>bb205705</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetTechnique([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetTechnique</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetTechnique(int index) {
            unsafe {
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[12]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a technique by looking up its name.</p>	
        /// </summary>	
        /// <param name="nameRef"><dd>  <p>String containing the technique name.</p> </dd></param>	
        /// <returns><p>Returns the handle of the first technique that has the specified name, or <strong><c>null</c></strong> if the name was not found. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetTechniqueByName']/*"/>	
        /// <msdn-id>bb205706</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetTechniqueByName([In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetTechniqueByName</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetTechnique(string nameRef) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, (void*)nameRef_,((void**)(*(void**)_nativePointer))[13]);		
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a pass.</p>	
        /// </summary>	
        /// <param name="hTechnique"><dd>  <p>Handle of the parent technique. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="index"><dd>  <p>Index for the pass.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified pass inside the specified technique, or <strong><c>null</c></strong> if the index was invalid. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetPass']/*"/>	
        /// <msdn-id>bb205700</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetPass([In] D3DXHANDLE hTechnique,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetPass</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetPass(SharpDX.Direct3D9.EffectHandle hTechnique, int index) {
            unsafe {
                var hTechnique_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hTechnique, ref hTechnique_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hTechnique_, index,((void**)(*(void**)_nativePointer))[14]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hTechnique, ref hTechnique_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a pass by looking up its name.</p>	
        /// </summary>	
        /// <param name="hTechnique"><dd>  <p>Handle of the parent technique. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="nameRef"><dd>  <p>String containing the pass name.</p> </dd></param>	
        /// <returns><p>Returns the handle of the first pass inside the specified technique that has the specified name, or <strong><c>null</c></strong> if the name was not found. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetPassByName']/*"/>	
        /// <msdn-id>bb205701</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetPassByName([In] D3DXHANDLE hTechnique,[In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetPassByName</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetPass(SharpDX.Direct3D9.EffectHandle hTechnique, string nameRef) {
            unsafe {
                var hTechnique_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hTechnique, ref hTechnique_);
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hTechnique_, (void*)nameRef_,((void**)(*(void**)_nativePointer))[15]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hTechnique, ref hTechnique_);
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a function.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Function index.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified function, or <strong><c>null</c></strong> if the index was invalid. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetFunction']/*"/>	
        /// <msdn-id>bb205684</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetFunction([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetFunction</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetFunction(int index) {
            unsafe {
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[16]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of a function by looking up its name.</p>	
        /// </summary>	
        /// <param name="nameRef"><dd>  <p>String containing the function name. </p> </dd></param>	
        /// <returns><p>Returns the handle of the specified function, or <strong><c>null</c></strong> if the name was not found. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetFunctionByName']/*"/>	
        /// <msdn-id>bb205685</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetFunctionByName([In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetFunctionByName</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetFunction(string nameRef) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, (void*)nameRef_,((void**)(*(void**)_nativePointer))[17]);		
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of an annotation. </p>	
        /// </summary>	
        /// <param name="hObject"><dd>  <p>Handle of a technique, pass, or top-level parameter. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="index"><dd>  <p>Annotation index.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified annotation, or <strong><c>null</c></strong> if the index was invalid. See Handles (Direct3D 9).</p></returns>	
        /// <remarks>	
        /// <p>Annotations are user-specific data that can be attached to any technique, pass, or parameter. See Handles (Direct3D 9). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetAnnotation']/*"/>	
        /// <msdn-id>bb205677</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetAnnotation([In] D3DXHANDLE hObject,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetAnnotation</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetAnnotation(SharpDX.Direct3D9.EffectHandle hObject, int index) {
            unsafe {
                var hObject_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hObject, ref hObject_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hObject_, index,((void**)(*(void**)_nativePointer))[18]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hObject, ref hObject_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the handle of an annotation by looking up its name.</p>	
        /// </summary>	
        /// <param name="hObject"><dd>  <p>Handle of a technique, pass, or top-level parameter. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="nameRef"><dd>  <p>String containing the annotation name.</p> </dd></param>	
        /// <returns><p>Returns the handle of the specified annotation, or <strong><c>null</c></strong> if the name was not found. See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetAnnotationByName']/*"/>	
        /// <msdn-id>bb205678</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXBaseEffect::GetAnnotationByName([In] D3DXHANDLE hObject,[In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetAnnotationByName</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetAnnotation(SharpDX.Direct3D9.EffectHandle hObject, string nameRef) {
            unsafe {
                var hObject_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hObject, ref hObject_);
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, hObject_, (void*)nameRef_,((void**)(*(void**)_nativePointer))[19]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hObject, ref hObject_);
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set the value of an arbitrary parameter or annotation, including simple types, structs, arrays, strings, shaders and textures. </p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to a buffer containing data.</p> </dd></param>	
        /// <param name="bytes"><dd>  <p>[in] Number of bytes in the buffer. Pass in D3DX_DEFAULT if you know your buffer is large enough to contain the entire parameter, and you want to skip size validation.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method can be used in place of nearly all the effect set API calls.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetValue']/*"/>	
        /// <msdn-id>bb205728</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetValue([In] D3DXHANDLE hParameter,[In] const void* pData,[In] unsigned int Bytes)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetValue</unmanaged-short>	
        internal void SetValue(SharpDX.Direct3D9.EffectHandle hParameter, System.IntPtr dataRef, int bytes) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, (void*)dataRef, bytes,((void**)(*(void**)_nativePointer))[20]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the value of an arbitrary parameter or annotation, including simple types, structs, arrays, strings, shaders and textures. This method can be used in place of nearly all the Getxxx calls in <strong><see cref="SharpDX.Direct3D9.BaseEffect"/></strong>.</p>	
        /// </summary>	
        /// <param name="hParameter">No documentation.</param>	
        /// <param name="dataRef">No documentation.</param>	
        /// <param name="bytes">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetValue']/*"/>	
        /// <msdn-id>bb205709</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetValue([In] D3DXHANDLE hParameter,[In] void* pData,[In] unsigned int Bytes)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetValue</unmanaged-short>	
        internal void GetValue(SharpDX.Direct3D9.EffectHandle hParameter, System.IntPtr dataRef, int bytes) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, (void*)dataRef, bytes,((void**)(*(void**)_nativePointer))[21]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a <see cref="SharpDX.Mathematics.Interop.RawBool"/> value.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="b"><dd>  <p>Boolean value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetBool']/*"/>	
        /// <msdn-id>bb205714</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetBool([In] D3DXHANDLE hParameter,[In] BOOL b)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetBool</unmanaged-short>	
        internal void SetBool(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawBool b) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint85(_nativePointer, hParameter_, b,((void**)(*(void**)_nativePointer))[22]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a <see cref="SharpDX.Mathematics.Interop.RawBool"/> value.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="bRef"><dd>  <p>Returns a Boolean value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetBool']/*"/>	
        /// <msdn-id>bb205679</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetBool([In] D3DXHANDLE hParameter,[Out] BOOL* pb)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetBool</unmanaged-short>	
        internal void GetBool(SharpDX.Direct3D9.EffectHandle hParameter, out SharpDX.Mathematics.Interop.RawBool bRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                bRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* bRef_ = &bRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, bRef_,((void**)(*(void**)_nativePointer))[23]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of Boolean values.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="bRef"><dd>  <p>Array of Boolean values.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of Boolean values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetBoolArray']/*"/>	
        /// <msdn-id>bb205715</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetBoolArray([In] D3DXHANDLE hParameter,[In, Buffer] const BOOL* pb,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetBoolArray</unmanaged-short>	
        internal void SetBoolArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawBool[] bRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* bRef_ = bRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, bRef_, count,((void**)(*(void**)_nativePointer))[24]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of <see cref="SharpDX.Mathematics.Interop.RawBool"/> values.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="bRef"><dd>  <p>Returns an array of Boolean values.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of Boolean values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetBoolArray']/*"/>	
        /// <msdn-id>bb205680</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetBoolArray([In] D3DXHANDLE hParameter,[Out, Buffer] BOOL* pb,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetBoolArray</unmanaged-short>	
        internal void GetBoolArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawBool[] bRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* bRef_ = bRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, bRef_, count,((void**)(*(void**)_nativePointer))[25]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an integer.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="n"><dd>  <p>Integer value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetInt']/*"/>	
        /// <msdn-id>bb205718</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetInt([In] D3DXHANDLE hParameter,[In] int n)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetInt</unmanaged-short>	
        internal void SetInt(SharpDX.Direct3D9.EffectHandle hParameter, int n) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, n,((void**)(*(void**)_nativePointer))[26]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an integer.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="nRef"><dd>  <p>Returns an integer.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetInt']/*"/>	
        /// <msdn-id>bb205687</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetInt([In] D3DXHANDLE hParameter,[Out] int* pn)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetInt</unmanaged-short>	
        internal void GetInt(SharpDX.Direct3D9.EffectHandle hParameter, out int nRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* nRef_ = &nRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, nRef_,((void**)(*(void**)_nativePointer))[27]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of integers.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="nRef"><dd>  <p>Array of integers.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of integers in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetIntArray']/*"/>	
        /// <msdn-id>bb205719</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetIntArray([In] D3DXHANDLE hParameter,[In, Buffer] const int* pn,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetIntArray</unmanaged-short>	
        internal void SetIntArray(SharpDX.Direct3D9.EffectHandle hParameter, int[] nRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* nRef_ = nRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, nRef_, count,((void**)(*(void**)_nativePointer))[28]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of integers.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="nRef"><dd>  <p>Returns an array of integers.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of integers in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetIntArray']/*"/>	
        /// <msdn-id>bb205688</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetIntArray([In] D3DXHANDLE hParameter,[Out, Buffer] int* pn,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetIntArray</unmanaged-short>	
        internal void GetIntArray(SharpDX.Direct3D9.EffectHandle hParameter, int[] nRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* nRef_ = nRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, nRef_, count,((void**)(*(void**)_nativePointer))[29]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a floating point value.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="f"><dd>  <p>Floating point value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetFloat']/*"/>	
        /// <msdn-id>bb205716</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetFloat([In] D3DXHANDLE hParameter,[In] float f)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetFloat</unmanaged-short>	
        internal void SetFloat(SharpDX.Direct3D9.EffectHandle hParameter, float f) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, f,((void**)(*(void**)_nativePointer))[30]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a floating point value.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="fRef"><dd>  <p>Returns a floating point value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetFloat']/*"/>	
        /// <msdn-id>bb205682</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetFloat([In] D3DXHANDLE hParameter,[Out] float* pf)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetFloat</unmanaged-short>	
        internal void GetFloat(SharpDX.Direct3D9.EffectHandle hParameter, out float fRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* fRef_ = &fRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, fRef_,((void**)(*(void**)_nativePointer))[31]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of floating point values.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="fRef"><dd>  <p>Array of floating point values.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of floating point values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetFloatArray']/*"/>	
        /// <msdn-id>bb205717</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetFloatArray([In] D3DXHANDLE hParameter,[In, Buffer] const float* pf,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetFloatArray</unmanaged-short>	
        internal void SetFloatArray(SharpDX.Direct3D9.EffectHandle hParameter, float[] fRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* fRef_ = fRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, fRef_, count,((void**)(*(void**)_nativePointer))[32]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of floating point values.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="fRef"><dd>  <p>Returns an array of floating point values.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of floating point values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetFloatArray']/*"/>	
        /// <msdn-id>bb205683</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetFloatArray([In] D3DXHANDLE hParameter,[Out, Buffer] float* pf,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetFloatArray</unmanaged-short>	
        internal void GetFloatArray(SharpDX.Direct3D9.EffectHandle hParameter, float[] fRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* fRef_ = fRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, fRef_, count,((void**)(*(void**)_nativePointer))[33]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a vector.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Pointer to a 4D vector.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If the destination vector is smaller than the source vector, the additional components of the source vector will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetVector']/*"/>	
        /// <msdn-id>bb205729</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetVector([In] D3DXHANDLE hParameter,[In] const D3DXVECTOR4* pVector)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetVector</unmanaged-short>	
        internal void SetVector(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawVector4 vectorRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, &vectorRef,((void**)(*(void**)_nativePointer))[34]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a vector.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Returns a 4D vector.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If the destination vector is larger than the source vector, only the initial components of the destination vector will be filled, and the remaining components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetVector']/*"/>	
        /// <msdn-id>bb205710</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetVector([In] D3DXHANDLE hParameter,[Out] D3DXVECTOR4* pVector)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetVector</unmanaged-short>	
        internal void GetVector(SharpDX.Direct3D9.EffectHandle hParameter, out SharpDX.Mathematics.Interop.RawVector4 vectorRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                vectorRef = new SharpDX.Mathematics.Interop.RawVector4();
                SharpDX.Result __result__;
                fixed (void* vectorRef_ = &vectorRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, vectorRef_,((void**)(*(void**)_nativePointer))[35]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of vectors.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Array of 4D floating point vectors.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of vectors in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If the destination vectors are smaller than the source vectors, the additional components of the source vectors will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetVectorArray']/*"/>	
        /// <msdn-id>bb205730</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetVectorArray([In] D3DXHANDLE hParameter,[In, Buffer] const D3DXVECTOR4* pVector,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetVectorArray</unmanaged-short>	
        internal void SetVectorArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawVector4[] vectorRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* vectorRef_ = vectorRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, vectorRef_, count,((void**)(*(void**)_nativePointer))[36]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of vectors.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Returns an array of 4D floating point vectors.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of vectors in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If the destination vectors are larger than the source vectors, only the initial components of each destination vector will be filled, and the remaining destination vector components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetVectorArray']/*"/>	
        /// <msdn-id>bb205711</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetVectorArray([In] D3DXHANDLE hParameter,[Out, Buffer] D3DXVECTOR4* pVector,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetVectorArray</unmanaged-short>	
        internal void GetVectorArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawVector4[] vectorRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* vectorRef_ = vectorRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, vectorRef_, count,((void**)(*(void**)_nativePointer))[37]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a non-transposed matrix.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a nontransposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A non-transposed matrix contains row-major data. In other words, each vector is contained in a row.</p><p>If the destination matrix is smaller than the source matrix, the additional components of the source matrix will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetMatrix']/*"/>	
        /// <msdn-id>bb205720</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrix([In] D3DXHANDLE hParameter,[In] const D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetMatrix</unmanaged-short>	
        internal void SetMatrix(SharpDX.Direct3D9.EffectHandle hParameter, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_,((void**)(*(void**)_nativePointer))[38]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a nontransposed matrix.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Returns a nontransposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A nontransposed matrix contains row-major data; that is, each vector is contained in a row.</p><p>If the destination matrix is larger than the source matrix, only the upper-left components of the destination matrix will be filled, and the remaining components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetMatrix']/*"/>	
        /// <msdn-id>bb205689</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrix([In] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetMatrix</unmanaged-short>	
        internal void GetMatrix(SharpDX.Direct3D9.EffectHandle hParameter, out SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                matrixRef = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_,((void**)(*(void**)_nativePointer))[39]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of nontransposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Array of nontransposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A nontransposed matrix contains row-major data; that is, each vector is contained in a row.</p><p>If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetMatrixArray']/*"/>	
        /// <msdn-id>bb205721</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixArray([In] D3DXHANDLE hParameter,[In, Buffer] const D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetMatrixArray</unmanaged-short>	
        internal void SetMatrixArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawMatrix[] matrixRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_, count,((void**)(*(void**)_nativePointer))[40]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of nontransposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Returns an array of nontransposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A nontransposed matrix contains row-major data; that is, each vector is contained in a row.</p><p>If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetMatrixArray']/*"/>	
        /// <msdn-id>bb205690</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixArray([In] D3DXHANDLE hParameter,[Out, Buffer] D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetMatrixArray</unmanaged-short>	
        internal void GetMatrixArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawMatrix[] matrixRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_, count,((void**)(*(void**)_nativePointer))[41]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of references to nontransposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to nontransposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A nontransposed matrix contains row-major data; that is, each vector is contained in a row.</p><p>If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetMatrixPointerArray']/*"/>	
        /// <msdn-id>bb205722</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixPointerArray([In] D3DXHANDLE hParameter,[In] const D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetMatrixPointerArray</unmanaged-short>	
        internal void SetMatrixPointerArray(SharpDX.Direct3D9.EffectHandle hParameter, ref SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixOut_, count,((void**)(*(void**)_nativePointer))[42]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of references to nontransposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to nontransposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A nontransposed matrix contains row-major data; that is, each vector is contained in a row.</p><p>If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetMatrixPointerArray']/*"/>	
        /// <msdn-id>bb205691</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixPointerArray([In] D3DXHANDLE hParameter,[Out] D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetMatrixPointerArray</unmanaged-short>	
        internal void GetMatrixPointerArray(SharpDX.Direct3D9.EffectHandle hParameter, out SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                matrixOut = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixOut_, count,((void**)(*(void**)_nativePointer))[43]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a transposed matrix.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a transposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p><p>If the destination matrix is smaller than the source matrix, the additional components of the source matrix will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetMatrixTranspose']/*"/>	
        /// <msdn-id>bb205723</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixTranspose([In] D3DXHANDLE hParameter,[In] const D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetMatrixTranspose</unmanaged-short>	
        internal void SetMatrixTranspose(SharpDX.Direct3D9.EffectHandle hParameter, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_,((void**)(*(void**)_nativePointer))[44]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a transposed matrix.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Returns a transposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p><p>If the destination matrix is larger than the source matrix, only the upper-left elements of the destination matrix will be filled, and the remaining destination matrix components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetMatrixTranspose']/*"/>	
        /// <msdn-id>bb205692</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixTranspose([In] D3DXHANDLE hParameter,[Out] D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetMatrixTranspose</unmanaged-short>	
        internal void GetMatrixTranspose(SharpDX.Direct3D9.EffectHandle hParameter, out SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                matrixRef = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_,((void**)(*(void**)_nativePointer))[45]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of transposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Array of transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p><p>If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetMatrixTransposeArray']/*"/>	
        /// <msdn-id>bb205724</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixTransposeArray([In] D3DXHANDLE hParameter,[In, Buffer] const D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetMatrixTransposeArray</unmanaged-short>	
        internal void SetMatrixTransposeArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawMatrix[] matrixRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_, count,((void**)(*(void**)_nativePointer))[46]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of transposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Returns an array of transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p><p>If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetMatrixTransposeArray']/*"/>	
        /// <msdn-id>bb205693</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixTransposeArray([In] D3DXHANDLE hParameter,[Out, Buffer] D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetMatrixTransposeArray</unmanaged-short>	
        internal void GetMatrixTransposeArray(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawMatrix[] matrixRef, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixRef_, count,((void**)(*(void**)_nativePointer))[47]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of references to transposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p><p>If the destination matrices are smaller than the source matrices, the additional components of the source matrices will be ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetMatrixTransposePointerArray']/*"/>	
        /// <msdn-id>bb205725</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetMatrixTransposePointerArray([In] D3DXHANDLE hParameter,[In] const D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetMatrixTransposePointerArray</unmanaged-short>	
        public void SetMatrixTransposePointerArray(SharpDX.Direct3D9.EffectHandle hParameter, ref SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixOut_, count,((void**)(*(void**)_nativePointer))[48]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an array of references to transposed matrices.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p><p>If the destination matrices are larger than the source matrices, only the upper-left components of each destination matrix will be filled, and the remaining destination matrix components will be set to zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetMatrixTransposePointerArray']/*"/>	
        /// <msdn-id>bb205694</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetMatrixTransposePointerArray([In] D3DXHANDLE hParameter,[Out] D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetMatrixTransposePointerArray</unmanaged-short>	
        public void GetMatrixTransposePointerArray(SharpDX.Direct3D9.EffectHandle hParameter, out SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                matrixOut = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, matrixOut_, count,((void**)(*(void**)_nativePointer))[49]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a string.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="stringRef"><dd>  <p>String to set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetString']/*"/>	
        /// <msdn-id>bb205726</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetString([In] D3DXHANDLE hParameter,[In] const char* pString)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetString</unmanaged-short>	
        public void SetString(SharpDX.Direct3D9.EffectHandle hParameter, string stringRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                IntPtr stringRef_ = Utilities.StringToHGlobalAnsi(stringRef);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, (void*)stringRef_,((void**)(*(void**)_nativePointer))[50]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                Marshal.FreeHGlobal(stringRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a string.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a string identified by hParameter.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetString']/*"/>	
        /// <msdn-id>bb205704</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetString([In] D3DXHANDLE hParameter,[Out] const void** ppString)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetString</unmanaged-short>	
        internal System.IntPtr GetString_(SharpDX.Direct3D9.EffectHandle hParameter) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                System.IntPtr stringOut;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, &stringOut,((void**)(*(void**)_nativePointer))[51]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
                return stringOut;
            }
        }
        
        /// <summary>	
        /// <p>Sets a texture.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="textureRef"><dd>  <p>Texture object. See <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetTexture']/*"/>	
        /// <msdn-id>bb205727</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetTexture([In] D3DXHANDLE hParameter,[In] IDirect3DBaseTexture9* pTexture)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetTexture</unmanaged-short>	
        public void SetTexture(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Direct3D9.BaseTexture textureRef) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, (void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer),((void**)(*(void**)_nativePointer))[52]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a texture.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a texture object. See <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetTexture']/*"/>	
        /// <msdn-id>bb205708</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetTexture([In] D3DXHANDLE hParameter,[Out] IDirect3DBaseTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetTexture</unmanaged-short>	
        public SharpDX.Direct3D9.BaseTexture GetTexture(SharpDX.Direct3D9.EffectHandle hParameter) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Direct3D9.BaseTexture textureOut;
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, &textureOut_,((void**)(*(void**)_nativePointer))[53]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.BaseTexture(textureOut_);	
                __result__.CheckError();
                return textureOut;
            }
        }
        
        /// <summary>	
        /// <p>Gets a pixel shader.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a pixel shader object. See <strong><see cref="SharpDX.Direct3D9.PixelShader"/></strong> object.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetPixelShader']/*"/>	
        /// <msdn-id>bb205703</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetPixelShader([In] D3DXHANDLE hParameter,[Out] IDirect3DPixelShader9** ppPShader)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetPixelShader</unmanaged-short>	
        public SharpDX.Direct3D9.PixelShader GetPixelShader(SharpDX.Direct3D9.EffectHandle hParameter) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Direct3D9.PixelShader pShaderOut;
                IntPtr pShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, &pShaderOut_,((void**)(*(void**)_nativePointer))[54]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                pShaderOut= (pShaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.PixelShader(pShaderOut_);	
                __result__.CheckError();
                return pShaderOut;
            }
        }
        
        /// <summary>	
        /// <p>Gets a vertex shader.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns a vertex shader object. See <strong><see cref="SharpDX.Direct3D9.VertexShader"/></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::GetVertexShader']/*"/>	
        /// <msdn-id>bb205712</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::GetVertexShader([In] D3DXHANDLE hParameter,[Out] IDirect3DVertexShader9** ppVShader)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::GetVertexShader</unmanaged-short>	
        public SharpDX.Direct3D9.VertexShader GetVertexShader(SharpDX.Direct3D9.EffectHandle hParameter) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Direct3D9.VertexShader vShaderOut;
                IntPtr vShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, &vShaderOut_,((void**)(*(void**)_nativePointer))[55]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                vShaderOut= (vShaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VertexShader(vShaderOut_);	
                __result__.CheckError();
                return vShaderOut;
            }
        }
        
        /// <summary>	
        /// <p>Set the range of an array to pass to the device.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="uStart"><dd>  <p>Start index.</p> </dd></param>	
        /// <param name="uEnd"><dd>  <p>Stop index.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseEffect::SetArrayRange']/*"/>	
        /// <msdn-id>bb205713</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseEffect::SetArrayRange([In] D3DXHANDLE hParameter,[In] unsigned int uStart,[In] unsigned int uEnd)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseEffect::SetArrayRange</unmanaged-short>	
        internal void SetArrayRange(SharpDX.Direct3D9.EffectHandle hParameter, int uStart, int uEnd) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, uStart, uEnd,((void**)(*(void**)_nativePointer))[56]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Locks a vertex buffer and obtains a reference to the vertex buffer memory.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>When working with vertex buffers, you are allowed to make multiple lock calls; however, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set vertex buffer.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh']/*"/>	
    /// <msdn-id>bb205749</msdn-id>	
    /// <unmanaged>ID3DXBaseMesh</unmanaged>	
    /// <unmanaged-short>ID3DXBaseMesh</unmanaged-short>	
    [Guid("7ed943dd-52e8-40b5-a8d8-76685c406330")]
    public partial class BaseMesh : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.BaseMesh"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BaseMesh(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.BaseMesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.BaseMesh(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.BaseMesh(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the fixed function vertex value.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetFVF']/*"/>	
        /// <msdn-id>bb205741</msdn-id>	
        /// <unmanaged>GetFVF</unmanaged>	
        /// <unmanaged-short>GetFVF</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
        }
        
        /// <summary>	
        /// <p>Gets the number of bytes per vertex.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetNumBytesPerVertex']/*"/>	
        /// <msdn-id>bb205743</msdn-id>	
        /// <unmanaged>GetNumBytesPerVertex</unmanaged>	
        /// <unmanaged-short>GetNumBytesPerVertex</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetNumBytesPerVertex()</unmanaged>
        public int NumBytesPerVertex {
                get { return GetNumBytesPerVertex(); }
        }
        
        /// <summary>	
        /// <p>Retrieves the mesh options enabled for this mesh at creation time.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetOptions']/*"/>	
        /// <msdn-id>bb205746</msdn-id>	
        /// <unmanaged>GetOptions</unmanaged>	
        /// <unmanaged-short>GetOptions</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with the mesh.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call <strong><see cref="SharpDX.ComObject"/></strong> when you are done using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetDevice']/*"/>	
        /// <msdn-id>bb205740</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the vertex buffer associated with the mesh.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetVertexBuffer']/*"/>	
        /// <msdn-id>bb205747</msdn-id>	
        /// <unmanaged>GetVertexBuffer</unmanaged>	
        /// <unmanaged-short>GetVertexBuffer</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetVertexBuffer([Out] IDirect3DVertexBuffer9** ppVB)</unmanaged>
        public SharpDX.Direct3D9.VertexBuffer VertexBuffer {
                get { SharpDX.Direct3D9.VertexBuffer __output__; GetVertexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the data in an index buffer.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetIndexBuffer']/*"/>	
        /// <msdn-id>bb205742</msdn-id>	
        /// <unmanaged>GetIndexBuffer</unmanaged>	
        /// <unmanaged-short>GetIndexBuffer</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetIndexBuffer([Out] IDirect3DIndexBuffer9** ppIB)</unmanaged>
        public SharpDX.Direct3D9.IndexBuffer IndexBuffer {
                get { SharpDX.Direct3D9.IndexBuffer __output__; GetIndexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Draws a subset of a mesh.</p>	
        /// </summary>	
        /// <param name="attribId"><dd>  <p> DWORD that specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The subset that is specified by AttribId will be rendered by the <strong><see cref="SharpDX.Direct3D9.Device.DrawIndexedPrimitive"/></strong> method, using the <see cref="SharpDX.Direct3D9.PrimitiveType.TriangleList"/> primitive type, so an index buffer must be properly initialized.</p><p>An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (<em>AttribId</em>) when drawing the frame.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::DrawSubset']/*"/>	
        /// <msdn-id>bb205736</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::DrawSubset([In] unsigned int AttribId)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::DrawSubset</unmanaged-short>	
        public void DrawSubset(int attribId) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, attribId,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of faces in the mesh.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of faces in the mesh.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetNumFaces']/*"/>	
        /// <msdn-id>bb205744</msdn-id>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetNumFaces()</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetNumFaces</unmanaged-short>	
        internal int GetNumFaces() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of vertices in the mesh.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of vertices in the mesh.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetNumVertices']/*"/>	
        /// <msdn-id>bb205745</msdn-id>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetNumVertices()</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetNumVertices</unmanaged-short>	
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the fixed function vertex value.</p>	
        /// </summary>	
        /// <returns><p>Returns the flexible vertex format (FVF) codes.</p></returns>	
        /// <remarks>	
        /// <p>This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetFVF']/*"/>	
        /// <msdn-id>bb205741</msdn-id>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetFVF()</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetFVF</unmanaged-short>	
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a declaration describing the vertices in the mesh.</p>	
        /// </summary>	
        /// <param name="declaration"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is <strong><see cref="SharpDX.Direct3D9.VertexFormatDeclaratorCount.Max"/></strong>. The vertex element array ends with the <strong>D3DDECL_END</strong> macro. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The array of elements includes the <strong>D3DDECL_END</strong> macro, which ends the declaration.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetDeclaration']/*"/>	
        /// <msdn-id>bb205739</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetDeclaration([In] D3DVERTEXELEMENT9* Declaration)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetDeclaration</unmanaged-short>	
        public void GetDeclaration(SharpDX.Direct3D9.VertexElement declaration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &declaration,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of bytes per vertex.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of bytes per vertex.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetNumBytesPerVertex']/*"/>	
        /// <msdn-id>bb205743</msdn-id>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetNumBytesPerVertex()</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetNumBytesPerVertex</unmanaged-short>	
        internal int GetNumBytesPerVertex() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the mesh options enabled for this mesh at creation time.</p>	
        /// </summary>	
        /// <returns><p>Returns a combination of one or more of the following flags, indicating the options enabled for this mesh at creation time.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.Use32Bit"/></td><td>Use 32-bit indices.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.DoNotClip"/></td><td>Use the <see cref="SharpDX.Direct3D9.Usage.DoNotClip"/> usage flag for vertex and index buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.Dynamic"/></td><td>Equivalent to specifying both <see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferDynamic"/> and <see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferDynamic"/>.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.RTPatches"/></td><td>Use the <see cref="SharpDX.Direct3D9.Usage.RTPatches"/> usage flag for vertex and index buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.NPatches"/></td><td>Specifying this flag causes the vertex and index buffer of the mesh to be created with <see cref="SharpDX.Direct3D9.Usage.NPatches"/> flag. This is required if the mesh object is to be rendered using N-Patch enhancement.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.Managed"/></td><td>Equivalent to specifying both <see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferManaged"/> and <see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferManaged"/>.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.Points"/></td><td>Use the <see cref="SharpDX.Direct3D9.Usage.Points"/> usage flag for vertex and index buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferDynamic"/></td><td>Use the <see cref="SharpDX.Direct3D9.Usage.Dynamic"/> usage flag for index buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferManaged"/></td><td>Use the <see cref="SharpDX.Direct3D9.Pool.Managed"/> memory class for index buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferSystemMemory"/></td><td>Use the <see cref="SharpDX.Direct3D9.Pool.SystemMemory"/> memory class for index buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferWriteOnly"/></td><td>Use the <see cref="SharpDX.Direct3D9.Usage.WriteOnly"/> usage flag for index buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.SystemMemory"/></td><td>Equivalent to specifying both <see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferSystemMemory"/> and <see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferSystemMemory"/>.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferDynamic"/></td><td>Use the <see cref="SharpDX.Direct3D9.Usage.Dynamic"/> usage flag for vertex buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferManaged"/></td><td>Use the <see cref="SharpDX.Direct3D9.Pool.Managed"/> memory class for vertex buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferSystemMemory"/></td><td>Use the <see cref="SharpDX.Direct3D9.Pool.SystemMemory"/> memory class for vertex buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferWriteOnly"/></td><td>Use the <see cref="SharpDX.Direct3D9.Usage.WriteOnly"/> usage flag for vertex buffers.</td></tr> <tr><td><see cref="SharpDX.Direct3D9.MeshFlags.WriteOnly"/></td><td>Equivalent to specifying both <see cref="SharpDX.Direct3D9.MeshFlags.VertexBufferWriteOnly"/> and <see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferWriteOnly"/>.</td></tr> </table><p>?</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetOptions']/*"/>	
        /// <msdn-id>bb205746</msdn-id>	
        /// <unmanaged>unsigned int ID3DXBaseMesh::GetOptions()</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetOptions</unmanaged-short>	
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with the mesh.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the Direct3D device object associated with the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call <strong><see cref="SharpDX.ComObject"/></strong> when you are done using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetDevice']/*"/>	
        /// <msdn-id>bb205740</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[10]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Clones a mesh using a flexible vertex format (FVF) code.</p>	
        /// </summary>	
        /// <param name="options"><dd>  <p>A combination of one or more <strong>D3DXMESH</strong> flags specifying creation options for the mesh.</p> </dd></param>	
        /// <param name="fvf"><dd>  <p>Combination of FVF codes, which specifies the vertex format for the vertices in the output mesh. For the values of the codes, see <see cref="SharpDX.Direct3D9.VertexFormat"/>.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface representing the device object associated with the mesh.</p> </dd></param>	
        /// <param name="cloneMeshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the cloned mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.BaseMesh.CloneMeshFVF"/></strong> is used to reformat and change the vertex data layout. This is done by creating a new mesh object. For example, use it to to add space for normals, texture coordinates, colors, weights, etc. that were not present before. </p><p> <strong><see cref="SharpDX.Direct3D9.BaseMesh.UpdateSemantics"/></strong> updates the vertex declaration with different semantic information without changing the layout of the vertex buffer. This method does not modify the contents of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent or vice versa.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::CloneMeshFVF']/*"/>	
        /// <msdn-id>bb205733</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::CloneMeshFVF([In] unsigned int Options,[In] unsigned int FVF,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::CloneMeshFVF</unmanaged-short>	
        public void CloneMeshFVF(int options, int fvf, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.Mesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, fvf, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &cloneMeshOut_,((void**)(*(void**)_nativePointer))[11]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Clones a mesh using a declarator.</p>	
        /// </summary>	
        /// <param name="options"><dd>  <p>A combination of one or more <strong>D3DXMESH</strong> flags specifying creation options for the mesh.</p> </dd></param>	
        /// <param name="declarationRef"><dd>  <p>An array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements, which specify the vertex format for the vertices in the output mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device object associated with the mesh.</p> </dd></param>	
        /// <param name="cloneMeshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the cloned mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.BaseMesh.CloneMesh"/></strong> is used to reformat and change the vertex data layout. This is done by creating a new mesh object. For example, use it to add space for normals, texture coordinates, colors, weights, etc. that were not present before. </p><p> <strong><see cref="SharpDX.Direct3D9.BaseMesh.UpdateSemantics"/></strong> updates the vertex declaration with different semantic information without changing the layout of the vertex buffer. This method does not modify the contents of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent or vice versa.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::CloneMesh']/*"/>	
        /// <msdn-id>bb205732</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::CloneMesh([In] unsigned int Options,[In] const D3DVERTEXELEMENT9* pDeclaration,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::CloneMesh</unmanaged-short>	
        public void CloneMesh(int options, SharpDX.Direct3D9.VertexElement declarationRef, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.Mesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, &declarationRef, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &cloneMeshOut_,((void**)(*(void**)_nativePointer))[12]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the vertex buffer associated with the mesh.</p>	
        /// </summary>	
        /// <param name="vBOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface, representing the vertex buffer object associated with the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetVertexBuffer']/*"/>	
        /// <msdn-id>bb205747</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetVertexBuffer([Out] IDirect3DVertexBuffer9** ppVB)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetVertexBuffer</unmanaged-short>	
        internal void GetVertexBuffer(out SharpDX.Direct3D9.VertexBuffer vBOut) {
            unsafe {
                IntPtr vBOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &vBOut_,((void**)(*(void**)_nativePointer))[13]);		
                vBOut= (vBOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VertexBuffer(vBOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the data in an index buffer.</p>	
        /// </summary>	
        /// <param name="iBOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface, representing the index buffer object associated with the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetIndexBuffer']/*"/>	
        /// <msdn-id>bb205742</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetIndexBuffer([Out] IDirect3DIndexBuffer9** ppIB)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetIndexBuffer</unmanaged-short>	
        internal void GetIndexBuffer(out SharpDX.Direct3D9.IndexBuffer iBOut) {
            unsafe {
                IntPtr iBOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &iBOut_,((void**)(*(void**)_nativePointer))[14]);		
                iBOut= (iBOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.IndexBuffer(iBOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Locks a vertex buffer and obtains a reference to the vertex buffer memory.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/></li> </ul> <p>For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>VOID* reference to a buffer containing the vertex data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>When working with vertex buffers, you are allowed to make multiple lock calls; however, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set vertex buffer.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::LockVertexBuffer']/*"/>	
        /// <msdn-id>bb205749</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::LockVertexBuffer([In] unsigned int Flags,[In] void** ppData)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::LockVertexBuffer</unmanaged-short>	
        public void LockVertexBuffer(int flags, System.IntPtr dataOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, (void*)dataOut,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks a vertex buffer.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::UnlockVertexBuffer']/*"/>	
        /// <msdn-id>bb205751</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::UnlockVertexBuffer()</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::UnlockVertexBuffer</unmanaged-short>	
        public void UnlockVertexBuffer() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Locks an index buffer and obtains a reference to the index buffer memory.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are: </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p>For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>VOID* reference to a buffer containing the index data. The count of indices in this buffer will be equal to <strong><see cref="SharpDX.Direct3D9.BaseMesh.GetNumFaces"/></strong> * 3.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>When working with index buffers, you are allowed to make multiple lock calls. However, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set index buffer.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::LockIndexBuffer']/*"/>	
        /// <msdn-id>bb205748</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::LockIndexBuffer([In] unsigned int Flags,[In] void** ppData)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::LockIndexBuffer</unmanaged-short>	
        public void LockIndexBuffer(int flags, System.IntPtr dataOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, (void*)dataOut,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks an index buffer.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::UnlockIndexBuffer']/*"/>	
        /// <msdn-id>bb205750</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::UnlockIndexBuffer()</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::UnlockIndexBuffer</unmanaged-short>	
        public void UnlockIndexBuffer() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves either an attribute table for a mesh, or the number of entries stored in an attribute table for a mesh.</p>	
        /// </summary>	
        /// <param name="attribTableRef"><dd>  <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.AttributeRange"/></strong> structures, representing the entries in the mesh's attribute table. Specify <strong><c>null</c></strong> to retrieve the value for pAttribTableSize.</p> </dd></param>	
        /// <param name="attribTableSizeRef"><dd>  <p>Pointer to either the number of entries stored in pAttribTable or a value to be filled in with the number of entries stored in the attribute table for the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>An attribute table is created by <strong><see cref="SharpDX.Direct3D9.Mesh.Optimize"/></strong> and passing <see cref="SharpDX.Direct3D9.MeshOptimizeFlags.AttributeSort"/> for the Flags parameter.</p><p>An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier when drawing the frame.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GetAttributeTable']/*"/>	
        /// <msdn-id>bb205738</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GetAttributeTable([Out] D3DXATTRIBUTERANGE* pAttribTable,[Out] unsigned int* pAttribTableSize)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GetAttributeTable</unmanaged-short>	
        public void GetAttributeTable(out SharpDX.Direct3D9.AttributeRange attribTableRef, out int attribTableSizeRef) {
            unsafe {
                attribTableRef = new SharpDX.Direct3D9.AttributeRange();
                SharpDX.Result __result__;
                fixed (void* attribTableRef_ = &attribTableRef)
                    fixed (void* attribTableSizeRef_ = &attribTableSizeRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, attribTableRef_, attribTableSizeRef_,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Converts point representative data to mesh adjacency information.</p>	
        /// </summary>	
        /// <param name="pRepRef"><dd>  <p>Pointer to an array of one DWORD per vertex of the mesh that contains point representative data. This parameter is optional. Supplying a <strong><c>null</c></strong> value will cause this parameter to be interpreted as an "identity" array.</p> </dd></param>	
        /// <param name="adjacencyRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <strong><see cref="SharpDX.Direct3D9.BaseMesh.GetNumFaces"/></strong> * sizeof(DWORD).</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::ConvertPointRepsToAdjacency']/*"/>	
        /// <msdn-id>bb205735</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::ConvertPointRepsToAdjacency([In] const unsigned int* pPRep,[In] unsigned int* pAdjacency)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::ConvertPointRepsToAdjacency</unmanaged-short>	
        public void ConvertPointRepsToAdjacency(int pRepRef, int adjacencyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &pRepRef, &adjacencyRef,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Converts mesh adjacency information to an array of point representatives.</p>	
        /// </summary>	
        /// <param name="adjacencyRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <strong><see cref="SharpDX.Direct3D9.BaseMesh.GetNumFaces"/></strong> * sizeof(DWORD).</p> </dd></param>	
        /// <param name="pRepRef"><dd>  <p>Pointer to an array of one DWORD per vertex of the mesh that will be filled with point representative data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::ConvertAdjacencyToPointReps']/*"/>	
        /// <msdn-id>bb205734</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::ConvertAdjacencyToPointReps([In] const unsigned int* pAdjacency,[In] unsigned int* pPRep)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::ConvertAdjacencyToPointReps</unmanaged-short>	
        public void ConvertAdjacencyToPointReps(int adjacencyRef, int pRepRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &adjacencyRef, &pRepRef,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generate a list of mesh edges, as well as a list of faces that share each edge.</p>	
        /// </summary>	
        /// <param name="epsilon"><dd>  <p>Specifies that vertices that differ in position by less than epsilon should be treated as coincident.</p> </dd></param>	
        /// <param name="adjacencyRef"><dd>  <p>Pointer to an array of three DWORDs per face to be filled with the indices of adjacent faces. The number of bytes in this array must be at least 3 * <strong><see cref="SharpDX.Direct3D9.BaseMesh.GetNumFaces"/></strong> * sizeof(DWORD).</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>After an application generates adjacency information for a mesh, the mesh data can be optimized for better drawing performance.</p><p>The order of the entries in the adjacency buffer is determined by the order of the vertex indices in the index buffer. The adjacent triangle 0 always corresponds to the edge between the indices of the corners 0 and 1. The adjacent triangle 1 always corresponds to the edge between the indices of the corners 1 and 2 while the adjacent triangle 2 corresponds to the edge between the indices of the corners 2 and 0.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::GenerateAdjacency']/*"/>	
        /// <msdn-id>bb205737</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::GenerateAdjacency([In] float Epsilon,[In] unsigned int* pAdjacency)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::GenerateAdjacency</unmanaged-short>	
        public void GenerateAdjacency(float epsilon, int adjacencyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, epsilon, &adjacencyRef,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>This method allows the user to change the mesh declaration without changing the data layout of the vertex buffer. The call is valid only if the old and new declaration formats have the same vertex size.</p>	
        /// </summary>	
        /// <param name="declaration"><dd>  <p>An array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements, describing the vertex format of the mesh vertices. The upper limit of this declarator array is <strong><see cref="SharpDX.Direct3D9.VertexFormatDeclaratorCount.Max"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.Direct3D9.BaseMesh.CloneMesh"/></strong> is used to reformat and change the vertex data layout. For example, use it to to add space for normals, texture coordinates, colors, weights, etc. that were not present before.</p><p><strong><see cref="SharpDX.Direct3D9.BaseMesh.UpdateSemantics"/></strong> is a method for updating the vertex declaration with different semantic information, without changing the layout of the vertex buffer. For example, use it to relabel a 3D texture coordinate as a binormal or tangent, or vice versa.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXBaseMesh::UpdateSemantics']/*"/>	
        /// <msdn-id>bb205752</msdn-id>	
        /// <unmanaged>HRESULT ID3DXBaseMesh::UpdateSemantics([In] D3DVERTEXELEMENT9* Declaration)</unmanaged>	
        /// <unmanaged-short>ID3DXBaseMesh::UpdateSemantics</unmanaged-short>	
        public void UpdateSemantics(SharpDX.Direct3D9.VertexElement declaration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &declaration,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.BaseTexture"/> interface to manipulate texture resources including cube and volume textures.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface assigned to a particular stage for a device is obtained by calling the <strong>GetTexture</strong> method.</p><p>The LPDIRECT3DBASETEXTURE9 and PDIRECT3DBASETEXTURE9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface. </p><pre>typedef struct <see cref="SharpDX.Direct3D9.BaseTexture"/> *LPDIRECT3DBASETEXTURE9, *PDIRECT3DBASETEXTURE9;</pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9']/*"/>	
    /// <msdn-id>bb174322</msdn-id>	
    /// <unmanaged>IDirect3DBaseTexture9</unmanaged>	
    /// <unmanaged-short>IDirect3DBaseTexture9</unmanaged-short>	
    [Guid("580CA87E-1D3C-4d54-991D-B7D3E3C298CE")]
    public partial class BaseTexture : SharpDX.Direct3D9.Resource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.BaseTexture"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BaseTexture(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.BaseTexture"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.BaseTexture(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.BaseTexture(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns the number of texture levels in a multilevel texture.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>Warning</strong>??If you create a texture with <strong><see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/></strong> to make that texture automatically generate sublevels, <strong>GetLevelCount</strong> always returns 1 for the number of levels.</p><p>This method applies to the following interfaces, which inherit from <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong>.</p><ul> <li> <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::GetLevelCount']/*"/>	
        /// <msdn-id>bb174325</msdn-id>	
        /// <unmanaged>GetLevelCount</unmanaged>	
        /// <unmanaged-short>GetLevelCount</unmanaged-short>	
        /// <unmanaged>unsigned int IDirect3DBaseTexture9::GetLevelCount()</unmanaged>
        public int LevelCount {
                get { return GetLevelCount(); }
        }
        
        /// <summary>	
        /// <p>Get or sets the filter type that is used for automatically generated mipmap sublevels.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated.</p><p>The (default) filter type set at texture creation time is <see cref="SharpDX.Direct3D9.TextureFilter.Linear"/>. If the driver doesn't support a linear filter, the filter type will be set to <see cref="SharpDX.Direct3D9.TextureFilter.Point"/>. All filter types supported by the driver for regular texture filtering are supported for autogeneration except <see cref="SharpDX.Direct3D9.TextureFilter.None"/>. For each resource type, drivers should support all the filter types reported in the corresponding texture, CubeTexture, and volumetexture filter caps. For more information about texture types, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p><p>This method has no effect if the texture is not created with <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::GetAutoGenFilterType']/*"/>	
        /// <msdn-id>bb174324</msdn-id>	
        /// <unmanaged>GetAutoGenFilterType / SetAutoGenFilterType</unmanaged>	
        /// <unmanaged-short>GetAutoGenFilterType</unmanaged-short>	
        /// <unmanaged>D3DTEXTUREFILTERTYPE IDirect3DBaseTexture9::GetAutoGenFilterType()</unmanaged>
        public SharpDX.Direct3D9.TextureFilter AutoMipGenerationFilter {
                get { return GetAutoMipGenerationFilter(); }
                set { SetAutoMipGenerationFilter(value); }
        }
        
        /// <summary>	
        /// <p>Sets the most detailed level-of-detail for a managed texture. </p>	
        /// </summary>	
        /// <param name="lODNew"><dd>  <p>Most detailed level-of-detail value to set for the mipmap chain. </p> </dd></param>	
        /// <returns><p>A DWORD value, clamped to the maximum level-of-detail value (one less than the total number of levels). Subsequent calls to this method will return the clamped value, not the level-of-detail value that was previously set.</p></returns>	
        /// <remarks>	
        /// <p>This method applies to the following interfaces, which inherit from <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong>.</p><ul> <li> <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> </li> </ul><p><strong>SetLOD</strong> is used for level-of-detail control of managed textures. This method returns 0 on nonmanaged textures.</p><p><strong>SetLOD</strong> communicates to the Direct3D texture manager the most detailed mipmap in the chain that should be loaded into local video memory. For example, in a five-level mipmap chain, setting LODNew to 2 indicates that the texture manager should load only mipmap levels 2 through 4 into local video memory at any given time. </p><p>More specifically, if the texture was created with the dimensions of 256x256, setting the most detailed level to 0 indicates that 256 x 256 is the largest mipmap available, setting the most detailed level to 1 indicates that 128 x 128 is the largest mipmap available, and so on, up to the most detailed mip level (the smallest texture size) for the chain.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::SetLOD']/*"/>	
        /// <msdn-id>bb174328</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DBaseTexture9::SetLOD([In] unsigned int LODNew)</unmanaged>	
        /// <unmanaged-short>IDirect3DBaseTexture9::SetLOD</unmanaged-short>	
        internal int SetLOD(int lODNew) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, lODNew,((void**)(*(void**)_nativePointer))[11]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns a value clamped to the maximum level-of-detail set for a managed texture (this method is not supported for an unmanaged texture).</p>	
        /// </summary>	
        /// <returns><p>A DWORD value, clamped to the maximum level-of-detail value (one less than the total number of levels). Calling <strong>GetLOD</strong> on an unmanaged texture is not supported and will result in a D3DERR error code being returned.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::GetLOD']/*"/>	
        /// <msdn-id>bb174326</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DBaseTexture9::GetLOD()</unmanaged>	
        /// <unmanaged-short>IDirect3DBaseTexture9::GetLOD</unmanaged-short>	
        internal int GetLOD() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns the number of texture levels in a multilevel texture.</p>	
        /// </summary>	
        /// <returns><p>A <strong>DWORD</strong> value that indicates the number of texture levels in a multilevel texture.</p></returns>	
        /// <remarks>	
        /// <p><strong>Warning</strong>??If you create a texture with <strong><see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/></strong> to make that texture automatically generate sublevels, <strong>GetLevelCount</strong> always returns 1 for the number of levels.</p><p>This method applies to the following interfaces, which inherit from <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong>.</p><ul> <li> <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::GetLevelCount']/*"/>	
        /// <msdn-id>bb174325</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DBaseTexture9::GetLevelCount()</unmanaged>	
        /// <unmanaged-short>IDirect3DBaseTexture9::GetLevelCount</unmanaged-short>	
        internal int GetLevelCount() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[13]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set the filter type that is used for automatically generated mipmap sublevels.</p>	
        /// </summary>	
        /// <param name="filterType"><dd>  <p>Filter type. See <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>. This method will fail if the filter type is invalid or not supported.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated.</p><p>The (default) filter type set at texture creation time is <see cref="SharpDX.Direct3D9.TextureFilter.Linear"/>. If the driver does not support a linear filter, the filter type will be set to <see cref="SharpDX.Direct3D9.TextureFilter.Point"/>. All filter types supported by the driver for regular texture filtering are supported for autogeneration except <see cref="SharpDX.Direct3D9.TextureFilter.None"/>. <strong>SetAutoGenFilterType</strong> will fail unless the driver sets the appropriate D3DPTFILTERCAPS_MINFxxx caps. These values are specified in the TextureFilterCaps and/or  CubeTextureFilterCaps members of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.  For more information about texture filter types, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p><p>This method has no effect if the texture is not created with <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/>. In this case, no failure is returned. For more information about usage constants, see <see cref="SharpDX.Direct3D9.Usage"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::SetAutoGenFilterType']/*"/>	
        /// <msdn-id>bb174327</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DBaseTexture9::SetAutoGenFilterType([In] D3DTEXTUREFILTERTYPE FilterType)</unmanaged>	
        /// <unmanaged-short>IDirect3DBaseTexture9::SetAutoGenFilterType</unmanaged-short>	
        internal void SetAutoMipGenerationFilter(SharpDX.Direct3D9.TextureFilter filterType) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)filterType),((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the filter type that is used for automatically generated mipmap sublevels.</p>	
        /// </summary>	
        /// <returns><p>Filter type. See <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>. A texture must be created with <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/> to use this method. Any other usage value will cause this method to return <see cref="SharpDX.Direct3D9.TextureFilter.None"/>. </p></returns>	
        /// <remarks>	
        /// <p>Changing the filter type "dirties" the mipmap sublevels and causes them to be regenerated.</p><p>The (default) filter type set at texture creation time is <see cref="SharpDX.Direct3D9.TextureFilter.Linear"/>. If the driver doesn't support a linear filter, the filter type will be set to <see cref="SharpDX.Direct3D9.TextureFilter.Point"/>. All filter types supported by the driver for regular texture filtering are supported for autogeneration except <see cref="SharpDX.Direct3D9.TextureFilter.None"/>. For each resource type, drivers should support all the filter types reported in the corresponding texture, CubeTexture, and volumetexture filter caps. For more information about texture types, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p><p>This method has no effect if the texture is not created with <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::GetAutoGenFilterType']/*"/>	
        /// <msdn-id>bb174324</msdn-id>	
        /// <unmanaged>D3DTEXTUREFILTERTYPE IDirect3DBaseTexture9::GetAutoGenFilterType()</unmanaged>	
        /// <unmanaged-short>IDirect3DBaseTexture9::GetAutoGenFilterType</unmanaged-short>	
        internal SharpDX.Direct3D9.TextureFilter GetAutoMipGenerationFilter() {
            unsafe {
                SharpDX.Direct3D9.TextureFilter __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXDirect3D9TextureFilter(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Generate mipmap sublevels.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An application can generate mipmap sublevels at any time by calling <strong>GenerateMipSubLevels</strong>. To have mipmap sublevels generated automatically at texture creation time (see Automatic Generation of Mipmaps (Direct3D 9)), specify  <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/> during <strong>CreateTexture</strong>, <strong>CreateCubeTexture</strong>, and <strong>CreateVolumeTexture</strong>. For more information about usage constants, see <see cref="SharpDX.Direct3D9.Usage"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DBaseTexture9::GenerateMipSubLevels']/*"/>	
        /// <msdn-id>bb174323</msdn-id>	
        /// <unmanaged>void IDirect3DBaseTexture9::GenerateMipSubLevels()</unmanaged>	
        /// <unmanaged-short>IDirect3DBaseTexture9::GenerateMipSubLevels</unmanaged-short>	
        public void GenerateMipSubLevels() {
            unsafe {
                SharpDX.Direct3D9.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
            }
        }
    }
    /// <summary>	
    /// <p>An application uses the methods of this interface to implement a key frame animation set stored in a compressed data format.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Create a compressed-format key frame animation set with <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCompressedAnimationSet"/></strong>.</p><p>The LPD3DXCOMPRESSEDANIMATIONSET type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.CompressedAnimationSet"/> <see cref="SharpDX.Direct3D9.CompressedAnimationSet"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.CompressedAnimationSet"/> *LPD3DXCOMPRESSEDANIMATIONSET;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet']/*"/>	
    /// <msdn-id>bb205756</msdn-id>	
    /// <unmanaged>ID3DXCompressedAnimationSet</unmanaged>	
    /// <unmanaged-short>ID3DXCompressedAnimationSet</unmanaged-short>	
    [Guid("6cc2480d-3808-4739-9f88-de49facd8d4c")]
    public partial class CompressedAnimationSet : SharpDX.Direct3D9.AnimationSet {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.CompressedAnimationSet"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CompressedAnimationSet(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.CompressedAnimationSet"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.CompressedAnimationSet(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.CompressedAnimationSet(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the type of the animation set playback loop.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetPlaybackType']/*"/>	
        /// <msdn-id>bb205760</msdn-id>	
        /// <unmanaged>GetPlaybackType</unmanaged>	
        /// <unmanaged-short>GetPlaybackType</unmanaged-short>	
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXCompressedAnimationSet::GetPlaybackType()</unmanaged>
        public SharpDX.Direct3D9.PlaybackType PlaybackType {
                get { return GetPlaybackType(); }
        }
        
        /// <summary>	
        /// <p>Gets the number of animation key frame ticks that occur per second.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetSourceTicksPerSecond']/*"/>	
        /// <msdn-id>bb205761</msdn-id>	
        /// <unmanaged>GetSourceTicksPerSecond</unmanaged>	
        /// <unmanaged-short>GetSourceTicksPerSecond</unmanaged-short>	
        /// <unmanaged>double ID3DXCompressedAnimationSet::GetSourceTicksPerSecond()</unmanaged>
        public double SourceTicksPerSecond {
                get { return GetSourceTicksPerSecond(); }
        }
        
        /// <summary>	
        /// <p>Gets the data buffer that stores compressed key frame animation data.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetCompressedData']/*"/>	
        /// <msdn-id>bb205758</msdn-id>	
        /// <unmanaged>GetCompressedData</unmanaged>	
        /// <unmanaged-short>GetCompressedData</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXCompressedAnimationSet::GetCompressedData([Out] ID3DXBuffer** ppCompressedData)</unmanaged>
        public SharpDX.Direct3D.Blob CompressedData {
                get { SharpDX.Direct3D.Blob __output__; GetCompressedData(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the number of callback keys in the animation set.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetNumCallbackKeys']/*"/>	
        /// <msdn-id>bb205759</msdn-id>	
        /// <unmanaged>GetNumCallbackKeys</unmanaged>	
        /// <unmanaged-short>GetNumCallbackKeys</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXCompressedAnimationSet::GetNumCallbackKeys()</unmanaged>
        public int NumCallbackKeys {
                get { return GetNumCallbackKeys(); }
        }
        
        /// <summary>	
        /// <p>Gets the type of the animation set playback loop.</p>	
        /// </summary>	
        /// <returns><p>Type of the animation set playback loop. See <strong><see cref="SharpDX.Direct3D9.PlaybackType"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetPlaybackType']/*"/>	
        /// <msdn-id>bb205760</msdn-id>	
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXCompressedAnimationSet::GetPlaybackType()</unmanaged>	
        /// <unmanaged-short>ID3DXCompressedAnimationSet::GetPlaybackType</unmanaged-short>	
        internal SharpDX.Direct3D9.PlaybackType GetPlaybackType() {
            unsafe {
                SharpDX.Direct3D9.PlaybackType __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXDirect3D9PlaybackType(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of animation key frame ticks that occur per second.</p>	
        /// </summary>	
        /// <returns><p>Number of animation key frame ticks that occur per second.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetSourceTicksPerSecond']/*"/>	
        /// <msdn-id>bb205761</msdn-id>	
        /// <unmanaged>double ID3DXCompressedAnimationSet::GetSourceTicksPerSecond()</unmanaged>	
        /// <unmanaged-short>ID3DXCompressedAnimationSet::GetSourceTicksPerSecond</unmanaged-short>	
        internal double GetSourceTicksPerSecond() {
            unsafe {
                double __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callidouble(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the data buffer that stores compressed key frame animation data.</p>	
        /// </summary>	
        /// <param name="compressedDataOut"><dd>  <p>Address of a reference to the <strong><see cref="SharpDX.Direct3D.Blob"/></strong> data buffer that receives compressed key frame animation data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetCompressedData']/*"/>	
        /// <msdn-id>bb205758</msdn-id>	
        /// <unmanaged>HRESULT ID3DXCompressedAnimationSet::GetCompressedData([Out] ID3DXBuffer** ppCompressedData)</unmanaged>	
        /// <unmanaged-short>ID3DXCompressedAnimationSet::GetCompressedData</unmanaged-short>	
        internal void GetCompressedData(out SharpDX.Direct3D.Blob compressedDataOut) {
            unsafe {
                IntPtr compressedDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &compressedDataOut_,((void**)(*(void**)_nativePointer))[13]);		
                compressedDataOut= (compressedDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compressedDataOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of callback keys in the animation set.</p>	
        /// </summary>	
        /// <returns><p>Number of callback keys in the animation set.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetNumCallbackKeys']/*"/>	
        /// <msdn-id>bb205759</msdn-id>	
        /// <unmanaged>unsigned int ID3DXCompressedAnimationSet::GetNumCallbackKeys()</unmanaged>	
        /// <unmanaged-short>ID3DXCompressedAnimationSet::GetNumCallbackKeys</unmanaged-short>	
        internal int GetNumCallbackKeys() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Fills an array with callback key data used for key frame animation.</p>	
        /// </summary>	
        /// <param name="callbackKeysRef"><dd>  <p>Pointer to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.CallbackKey"/></strong> structures that the method is to fill with callback data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXCompressedAnimationSet::GetCallbackKeys']/*"/>	
        /// <msdn-id>bb205757</msdn-id>	
        /// <unmanaged>HRESULT ID3DXCompressedAnimationSet::GetCallbackKeys([In] D3DXKEY_CALLBACK* pCallbackKeys)</unmanaged>	
        /// <unmanaged-short>ID3DXCompressedAnimationSet::GetCallbackKeys</unmanaged-short>	
        public void GetCallbackKeys(SharpDX.Direct3D9.CallbackKey callbackKeysRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &callbackKeysRef,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D9.ConstantTable"/> interface is used to access the constant table. This table contains the variables that are used by high-level language shaders and effects.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPD3DXCONSTANTTABLE type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.ConstantTable"/></strong> interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.ConstantTable"/> <see cref="SharpDX.Direct3D9.ConstantTable"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.ConstantTable"/> *LPD3DXCONSTANTTABLE;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable']/*"/>	
    /// <msdn-id>bb205762</msdn-id>	
    /// <unmanaged>ID3DXConstantTable</unmanaged>	
    /// <unmanaged-short>ID3DXConstantTable</unmanaged-short>	
    [Guid("ab3c758f-093e-4356-b762-4db18f1b3a01")]
    public partial class ConstantTable : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.ConstantTable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ConstantTable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.ConstantTable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.ConstantTable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.ConstantTable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets a reference to the buffer that contains the constant table.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetBufferPointer']/*"/>	
        /// <msdn-id>bb205763</msdn-id>	
        /// <unmanaged>GetBufferPointer</unmanaged>	
        /// <unmanaged-short>GetBufferPointer</unmanaged-short>	
        /// <unmanaged>void* ID3DXConstantTable::GetBufferPointer()</unmanaged>
        public System.IntPtr BufferPointer {
                get { return GetBufferPointer(); }
        }
        
        /// <summary>	
        /// <p>Gets the buffer size of the constant table.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetBufferSize']/*"/>	
        /// <msdn-id>bb205764</msdn-id>	
        /// <unmanaged>GetBufferSize</unmanaged>	
        /// <unmanaged-short>GetBufferSize</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXConstantTable::GetBufferSize()</unmanaged>
        public int BufferSize {
                get { return GetBufferSize(); }
        }
        
        /// <summary>	
        /// <p>Gets a description of the constant table.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetDesc']/*"/>	
        /// <msdn-id>bb205769</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXConstantTable::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.ConstantTableDescription Description {
                get { SharpDX.Direct3D9.ConstantTableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets a reference to the buffer that contains the constant table.</p>	
        /// </summary>	
        /// <returns><p>Returns a reference the buffer.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetBufferPointer']/*"/>	
        /// <msdn-id>bb205763</msdn-id>	
        /// <unmanaged>void* ID3DXConstantTable::GetBufferPointer()</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetBufferPointer</unmanaged-short>	
        internal System.IntPtr GetBufferPointer() {
            unsafe {
                System.IntPtr __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the buffer size of the constant table.</p>	
        /// </summary>	
        /// <returns><p>Returns the size of the buffer, in bytes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetBufferSize']/*"/>	
        /// <msdn-id>bb205764</msdn-id>	
        /// <unmanaged>unsigned int ID3DXConstantTable::GetBufferSize()</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetBufferSize</unmanaged-short>	
        internal int GetBufferSize() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets a description of the constant table.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Description of the constant table. See <strong><see cref="SharpDX.Direct3D9.ConstantTableDescription"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetDesc']/*"/>	
        /// <msdn-id>bb205769</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.ConstantTableDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D9.ConstantTableDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[5]);		
                descRef = new SharpDX.Direct3D9.ConstantTableDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a reference to an array of constant descriptions in the constant table.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to a constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="constantDescRef"><dd>  <p>Returns a reference to an array of descriptions. See <strong><see cref="SharpDX.Direct3D9.ConstantDescription"/></strong>.</p> </dd></param>	
        /// <param name="countRef"><dd>  <p>The input supplied must be the maximum size of the array. The output is the number of elements that are filled in the array when the function returns.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.ConstantTable.GetConstantDescription"/></strong> will sometimes return a <strong><see cref="SharpDX.Direct3D9.ConstantDescription"/></strong> with a Register_Count of 0.  This will happen with a constant appears in more than one Register_Set but does not have space in that register set allocated.</p><p>Because a sampler can appear more than once in a constant table, this method can return an array of descriptions, each one with a different register index.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetConstantDesc']/*"/>	
        /// <msdn-id>bb205767</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::GetConstantDesc([In] D3DXHANDLE hConstant,[Out, Buffer] D3DXCONSTANT_DESC* pConstantDesc,[InOut] unsigned int* pCount)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetConstantDesc</unmanaged-short>	
        internal void GetConstantDescription(SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Direct3D9.ConstantDescription[] constantDescRef, ref int countRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Direct3D9.ConstantDescription.__Native[] constantDescRef__ = new SharpDX.Direct3D9.ConstantDescription.__Native[constantDescRef.Length];
                SharpDX.Result __result__;
                fixed (void* constantDescRef_ = constantDescRef__)
                    fixed (void* countRef_ = &countRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, constantDescRef_, countRef_,((void**)(*(void**)_nativePointer))[6]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                for (int i = 0; i < constantDescRef.Length; i++)
                    constantDescRef[i].__MarshalFrom(ref constantDescRef__[i]);				
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the sampler index.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>The sampler handle.</p> </dd></param>	
        /// <returns><p>Returns the sampler index number from the constant table.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetSamplerIndex']/*"/>	
        /// <msdn-id>bb205770</msdn-id>	
        /// <unmanaged>unsigned int ID3DXConstantTable::GetSamplerIndex([In] D3DXHANDLE hConstant)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetSamplerIndex</unmanaged-short>	
        public int GetSamplerIndex(SharpDX.Direct3D9.EffectHandle effectHandle) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_,((void**)(*(void**)_nativePointer))[7]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets a constant by looking up its index.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="index"><dd>  <p>Zero-based index of the constant.</p> </dd></param>	
        /// <returns><p>Returns a unique identifier to the constant.</p></returns>	
        /// <remarks>	
        /// <p>To get a constant from an array of constants, use <strong><see cref="SharpDX.Direct3D9.ConstantTable.GetConstantElement"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetConstant']/*"/>	
        /// <msdn-id>bb205765</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXConstantTable::GetConstant([In] D3DXHANDLE hConstant,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetConstant</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetConstant(SharpDX.Direct3D9.EffectHandle effectHandle, int index) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, effectHandle_, index,((void**)(*(void**)_nativePointer))[8]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets a constant by looking up its name.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="nameRef"><dd>  <p>Name of the constant.</p> </dd></param>	
        /// <returns><p>Returns a unique identifier to the constant.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetConstantByName']/*"/>	
        /// <msdn-id>bb205766</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXConstantTable::GetConstantByName([In] D3DXHANDLE hConstant,[In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetConstantByName</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetConstantByName(SharpDX.Direct3D9.EffectHandle effectHandle, string nameRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, effectHandle_, (void*)nameRef_,((void**)(*(void**)_nativePointer))[9]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets a constant from an array of constants. An array is made up of elements.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constants.  This value may not be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="index"><dd>  <p>Zero-based index of the element in the array.</p> </dd></param>	
        /// <returns><p>Returns a unique identifier to the element constant.</p></returns>	
        /// <remarks>	
        /// <p>To get a constant that is not part of an array, use <strong><see cref="SharpDX.Direct3D9.ConstantTable.GetConstant"/></strong> or <strong><see cref="SharpDX.Direct3D9.ConstantTable.GetConstantByName"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::GetConstantElement']/*"/>	
        /// <msdn-id>bb205768</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXConstantTable::GetConstantElement([In] D3DXHANDLE hConstant,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::GetConstantElement</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetConstantElement(SharpDX.Direct3D9.EffectHandle effectHandle, int index) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, effectHandle_, index,((void**)(*(void**)_nativePointer))[10]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets the constants to their default values. The default values are declared in the variable declarations in the shader.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetDefaults']/*"/>	
        /// <msdn-id>bb205773</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetDefaults([In] IDirect3DDevice9* pDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetDefaults</unmanaged-short>	
        internal void SetDefaults(SharpDX.Direct3D9.Device deviceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the contents of the buffer to the constant table.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to a constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Buffer containing data.</p> </dd></param>	
        /// <param name="bytes"><dd>  <p>Size of the buffer, in bytes.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetValue']/*"/>	
        /// <msdn-id>bb205785</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetValue([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] const void* pData,[In] unsigned int Bytes)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetValue</unmanaged-short>	
        internal void SetValue(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, System.IntPtr dataRef, int bytes) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, (void*)dataRef, bytes,((void**)(*(void**)_nativePointer))[12]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a Boolean value.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="b"><dd>  <p>Boolean value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetBool']/*"/>	
        /// <msdn-id>bb205771</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetBool([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] BOOL b)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetBool</unmanaged-short>	
        internal void SetBool(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawBool b) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint104(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, b,((void**)(*(void**)_nativePointer))[13]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of Boolean values.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="bRef"><dd>  <p>Array of Boolean values.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of Boolean values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetBoolArray']/*"/>	
        /// <msdn-id>bb205772</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetBoolArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In, Buffer] const BOOL* pb,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetBoolArray</unmanaged-short>	
        internal void SetBoolArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawBool[] bRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* bRef_ = bRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, bRef_, count,((void**)(*(void**)_nativePointer))[14]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an integer value.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="n"><dd>  <p>Integer.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetInt']/*"/>	
        /// <msdn-id>bb205776</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetInt([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] int n)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetInt</unmanaged-short>	
        internal void SetInt(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, int n) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, n,((void**)(*(void**)_nativePointer))[15]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of integers.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="nRef"><dd>  <p>Array of integers.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of integers in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetIntArray']/*"/>	
        /// <msdn-id>bb205778</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetIntArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In, Buffer] const int* pn,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetIntArray</unmanaged-short>	
        internal void SetIntArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, int[] nRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* nRef_ = nRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, nRef_, count,((void**)(*(void**)_nativePointer))[16]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a floating-point number.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="f"><dd>  <p>Floating-point number.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetFloat']/*"/>	
        /// <msdn-id>bb205774</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetFloat([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] float f)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetFloat</unmanaged-short>	
        internal void SetFloat(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, float f) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, f,((void**)(*(void**)_nativePointer))[17]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of floating-point numbers.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="fRef"><dd>  <p>Array of floating-point numbers.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of floating-point values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetFloatArray']/*"/>	
        /// <msdn-id>bb205775</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetFloatArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In, Buffer] const float* pf,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetFloatArray</unmanaged-short>	
        internal void SetFloatArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, float[] fRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* fRef_ = fRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, fRef_, count,((void**)(*(void**)_nativePointer))[18]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a 4D vector.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the vector constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Pointer to a 4D vector.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetVector']/*"/>	
        /// <msdn-id>bb205786</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetVector([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] const D3DXVECTOR4* pVector)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetVector</unmanaged-short>	
        internal void SetVector(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawVector4 vectorRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, &vectorRef,((void**)(*(void**)_nativePointer))[19]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of 4D vectors.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of vector constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Array of 4D vectors.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of vectors in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetVectorArray']/*"/>	
        /// <msdn-id>bb205787</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetVectorArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In, Buffer] const D3DXVECTOR4* pVector,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetVectorArray</unmanaged-short>	
        internal void SetVectorArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawVector4[] vectorRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* vectorRef_ = vectorRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, vectorRef_, count,((void**)(*(void**)_nativePointer))[20]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a nontransposed matrix.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the matrix of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a nontransposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetMatrix']/*"/>	
        /// <msdn-id>bb205779</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrix([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] const D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetMatrix</unmanaged-short>	
        internal void SetMatrix(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, matrixRef_,((void**)(*(void**)_nativePointer))[21]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of nontransposed matrices.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constant matrices. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Array of nontransposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetMatrixArray']/*"/>	
        /// <msdn-id>bb205780</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In, Buffer] const D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetMatrixArray</unmanaged-short>	
        internal void SetMatrixArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawMatrix[] matrixRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, matrixRef_, count,((void**)(*(void**)_nativePointer))[22]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of references to nontransposed matrices.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to an array of constant matrices. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to nontransposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A nontransposed matrix contains row-major data; that is, each vector is contained in a row.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetMatrixPointerArray']/*"/>	
        /// <msdn-id>bb205781</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixPointerArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] const D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetMatrixPointerArray</unmanaged-short>	
        internal void SetMatrixPointerArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, matrixOut_, count,((void**)(*(void**)_nativePointer))[23]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a transposed matrix.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the matrix of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a transposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetMatrixTranspose']/*"/>	
        /// <msdn-id>bb205782</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixTranspose([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] const D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetMatrixTranspose</unmanaged-short>	
        internal void SetMatrixTranspose(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, matrixRef_,((void**)(*(void**)_nativePointer))[24]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of transposed matrices.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of matrix constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Array of transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetMatrixTransposeArray']/*"/>	
        /// <msdn-id>bb205783</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixTransposeArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In, Buffer] const D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetMatrixTransposeArray</unmanaged-short>	
        internal void SetMatrixTransposeArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawMatrix[] matrixRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, matrixRef_, count,((void**)(*(void**)_nativePointer))[25]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of references to transposed matrices.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the constant table.</p> </dd></param>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of matrix constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXConstantTable::SetMatrixTransposePointerArray']/*"/>	
        /// <msdn-id>bb205784</msdn-id>	
        /// <unmanaged>HRESULT ID3DXConstantTable::SetMatrixTransposePointerArray([In] IDirect3DDevice9* pDevice,[In] D3DXHANDLE hConstant,[In] const D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXConstantTable::SetMatrixTransposePointerArray</unmanaged-short>	
        internal void SetMatrixTransposePointerArray(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), effectHandle_, matrixOut_, count,((void**)(*(void**)_nativePointer))[26]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.CubeTexture"/> interface to manipulate a cube texture resource.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface can be obtained by calling the <strong><see cref="SharpDX.Direct3D9.Device.CreateCubeTexture"/></strong> method or one of the <see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTexture"/><em>xxx</em> functions.</p><p>This interface inherits additional functionality from the <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface.</p><p>This interface, like all COM interfaces, inherits additional functionality from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPDIRECT3DCUBETEXTURE9 and PDIRECT3DCubeTexture9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.CubeTexture"/> *LPDIRECT3DCUBETEXTURE9, *PDIRECT3DCubeTexture9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DCubeTexture9']/*"/>	
    /// <msdn-id>bb174329</msdn-id>	
    /// <unmanaged>IDirect3DCubeTexture9</unmanaged>	
    /// <unmanaged-short>IDirect3DCubeTexture9</unmanaged-short>	
    [Guid("FFF32F81-D953-473a-9223-93D652ABA93F")]
    public partial class CubeTexture : SharpDX.Direct3D9.BaseTexture {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.CubeTexture"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public CubeTexture(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.CubeTexture"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.CubeTexture(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.CubeTexture(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a description of one face of the specified cube texture level.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Specifies a level of a mipmapped cube texture.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.SurfaceDescription"/></strong> structure, describing one face of the specified cube texture level.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct3D9.SurfaceDescription"/></strong> structure contains Width and Height members, which describe the size of one face in the cube. To get the size of the entire cube, multiply six (the number of cube faces) by the product of Width and Height.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DCubeTexture9::GetLevelDesc']/*"/>	
        /// <msdn-id>bb174332</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::GetLevelDesc([In] unsigned int Level,[Out] D3DSURFACE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>IDirect3DCubeTexture9::GetLevelDesc</unmanaged-short>	
        public SharpDX.Direct3D9.SurfaceDescription GetLevelDescription(int level) {
            unsafe {
                SharpDX.Direct3D9.SurfaceDescription descRef;
                descRef = new SharpDX.Direct3D9.SurfaceDescription();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level, &descRef,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a cube texture map surface.</p>	
        /// </summary>	
        /// <param name="faceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.CubeMapFace"/></strong> enumerated type, identifying a cube map face. </p> </dd></param>	
        /// <param name="level"><dd>  <p>Specifies a level of a mipmapped cube texture. </p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the returned cube texture map surface. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DCubeTexture9::GetCubeMapSurface']/*"/>	
        /// <msdn-id>bb174331</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::GetCubeMapSurface([In] D3DCUBEMAP_FACES FaceType,[In] unsigned int Level,[Out] IDirect3DSurface9** ppCubeMapSurface)</unmanaged>	
        /// <unmanaged-short>IDirect3DCubeTexture9::GetCubeMapSurface</unmanaged-short>	
        public SharpDX.Direct3D9.Surface GetCubeMapSurface(SharpDX.Direct3D9.CubeMapFace faceType, int level) {
            unsafe {
                SharpDX.Direct3D9.Surface cubeMapSurfaceOut;
                IntPtr cubeMapSurfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)faceType), level, &cubeMapSurfaceOut_,((void**)(*(void**)_nativePointer))[18]);		
                cubeMapSurfaceOut= (cubeMapSurfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(cubeMapSurfaceOut_);	
                __result__.CheckError();
                return cubeMapSurfaceOut;
            }
        }
        
        /// <summary>	
        /// <p>Locks a rectangle on a cube texture resource.</p>	
        /// </summary>	
        /// <param name="faceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.CubeMapFace"/></strong> enumerated type, identifying a cube map face. </p> </dd></param>	
        /// <param name="level"><dd>  <p>Specifies a level of a mipmapped cube texture. </p> </dd></param>	
        /// <param name="lockedRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.LockedRectangle"/></strong> structure, describing the region to lock. </p> </dd></param>	
        /// <param name="rectRef"><dd>  <p>Pointer to a rectangle to lock. Specified by a reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifying <strong><c>null</c></strong> for this parameter expands the dirty region to cover the entire cube texture.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p> You may not specify a subrect when using <see cref="SharpDX.Direct3D9.LockFlags.Discard"/>. For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if one or more of the arguments is invalid.</p></returns>	
        /// <remarks>	
        /// <p>For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when <strong><see cref="SharpDX.Direct3D9.CubeTexture.LockRectangle"/></strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. See <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong> for more information.</p><p>Cube textures created with <see cref="SharpDX.Direct3D9.Pool.Default"/> are not lockable. Cube textures created in video memory are lockable when created with <strong>USAGE_DYNAMIC</strong>.</p><p>The only lockable format for a depth-stencil texture is <see cref="SharpDX.Direct3D9.Format.D16Lockable"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DCubeTexture9::LockRect']/*"/>	
        /// <msdn-id>bb174334</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::LockRect([In] D3DCUBEMAP_FACES FaceType,[In] unsigned int Level,[Out] D3DLOCKED_RECT* pLockedRect,[In] const void* pRect,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DCubeTexture9::LockRect</unmanaged-short>	
        internal void LockRectangle(SharpDX.Direct3D9.CubeMapFace faceType, int level, out SharpDX.Direct3D9.LockedRectangle lockedRectRef, System.IntPtr rectRef, SharpDX.Direct3D9.LockFlags flags) {
            unsafe {
                lockedRectRef = new SharpDX.Direct3D9.LockedRectangle();
                SharpDX.Result __result__;
                fixed (void* lockedRectRef_ = &lockedRectRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)faceType), level, lockedRectRef_, (void*)rectRef, unchecked((int)flags),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks a rectangle on a cube texture resource.</p>	
        /// </summary>	
        /// <param name="faceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.CubeMapFace"/></strong> enumerated type, identifying a cube map face. </p> </dd></param>	
        /// <param name="level"><dd>  <p>Specifies a level of a mipmapped cube texture. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DCubeTexture9::UnlockRect']/*"/>	
        /// <msdn-id>bb174335</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::UnlockRect([In] D3DCUBEMAP_FACES FaceType,[In] unsigned int Level)</unmanaged>	
        /// <unmanaged-short>IDirect3DCubeTexture9::UnlockRect</unmanaged-short>	
        public void UnlockRectangle(SharpDX.Direct3D9.CubeMapFace faceType, int level) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)faceType), level,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a dirty region to a cube texture resource.</p>	
        /// </summary>	
        /// <param name="faceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.CubeMapFace"/></strong> enumerated type, identifying the cube map face. </p> </dd></param>	
        /// <param name="dirtyRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure, specifying the dirty region. Specifying <strong><c>null</c></strong> expands the dirty region to cover the entire cube texture. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when <strong><see cref="SharpDX.Direct3D9.CubeTexture.LockRectangle"/></strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. The destination surface of <strong><see cref="SharpDX.Direct3D9.Device.UpdateSurface"/></strong> is also marked dirty automatically.</p><p>Using <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> and explicitly specifying dirty regions can be used to increase the efficiency of <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong>. Using this method, applications can optimize what subset of a resource is copied by specifying dirty regions on the resource. However, the dirty regions may be expanded to optimize alignment.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DCubeTexture9::AddDirtyRect']/*"/>	
        /// <msdn-id>bb174330</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DCubeTexture9::AddDirtyRect([In] D3DCUBEMAP_FACES FaceType,[In] const void* pDirtyRect)</unmanaged>	
        /// <unmanaged-short>IDirect3DCubeTexture9::AddDirtyRect</unmanaged-short>	
        internal void AddDirtyRectangle(SharpDX.Direct3D9.CubeMapFace faceType, System.IntPtr dirtyRectRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)faceType), (void*)dirtyRectRef,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.Device"/> interface to perform DrawPrimitive-based rendering, create resources, work with system-level variables, adjust gamma ramp levels, work with palettes, and create shaders.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong> method.</p><p>This interface, like all COM interfaces, inherits the <strong><see cref="SharpDX.ComObject"/></strong> interface methods.</p><p>The LPDIRECT3DDEVICE9 and PDIRECT3DDEVICE9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface.</p><pre> typedef struct <see cref="SharpDX.Direct3D9.Device"/> *LPDIRECT3DDEVICE9, *PDIRECT3DDEVICE9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9']/*"/>	
    /// <msdn-id>bb174336</msdn-id>	
    /// <unmanaged>IDirect3DDevice9</unmanaged>	
    /// <unmanaged-short>IDirect3DDevice9</unmanaged-short>	
    [Guid("D0223B96-BF7A-43fd-92BD-A43B0D82B9EB")]
    public partial class Device : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Device"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Device"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Device(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Device(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns an interface to the instance of the Direct3D object that created the device.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling <strong><see cref="SharpDX.Direct3D9.Device.GetDirect3D"/></strong> will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetDirect3D']/*"/>	
        /// <msdn-id>bb174386</msdn-id>	
        /// <unmanaged>GetDirect3D</unmanaged>	
        /// <unmanaged-short>GetDirect3D</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDirect3D([Out] IDirect3D9** ppD3D9)</unmanaged>
        public SharpDX.Direct3D9.Direct3D Direct3D {
                get { SharpDX.Direct3D9.Direct3D __output__; GetDirect3D(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the capabilities of the rendering device.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Device.GetCapabilities"/></strong> retrieves the software vertex pipeline capabilities when the device is being used in software vertex processing mode.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetDeviceCaps']/*"/>	
        /// <msdn-id>bb174385</msdn-id>	
        /// <unmanaged>GetDeviceCaps</unmanaged>	
        /// <unmanaged-short>GetDeviceCaps</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDeviceCaps([Out] D3DCAPS9* pCaps)</unmanaged>
        public SharpDX.Direct3D9.Capabilities Capabilities {
                get { SharpDX.Direct3D9.Capabilities __output__; GetCapabilities(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the creation parameters of the device.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>You can query the AdapterOrdinal member of the returned <strong><see cref="SharpDX.Direct3D9.CreationParameters"/></strong> structure to retrieve the ordinal of the adapter represented by this device. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetCreationParameters']/*"/>	
        /// <msdn-id>bb174382</msdn-id>	
        /// <unmanaged>GetCreationParameters</unmanaged>	
        /// <unmanaged-short>GetCreationParameters</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCreationParameters([Out] D3DDEVICE_CREATION_PARAMETERS* pParameters)</unmanaged>
        public SharpDX.Direct3D9.CreationParameters CreationParameters {
                get { SharpDX.Direct3D9.CreationParameters __output__; GetCreationParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the number of implicit swap chains.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Implicit swap chains are created by the device during <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>. This method returns the number of swap chains created by CreateDevice.  </p><p>An application may create additional swap chains using <strong><see cref="SharpDX.Direct3D9.Device.CreateAdditionalSwapChain"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetNumberOfSwapChains']/*"/>	
        /// <msdn-id>bb174396</msdn-id>	
        /// <unmanaged>GetNumberOfSwapChains</unmanaged>	
        /// <unmanaged-short>GetNumberOfSwapChains</unmanaged-short>	
        /// <unmanaged>unsigned int IDirect3DDevice9::GetNumberOfSwapChains()</unmanaged>
        public int SwapChainCount {
                get { return GetSwapChainCount(); }
        }
        
        /// <summary>	
        /// <p>This method allows the use of GDI dialog boxes in full-screen mode applications.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The GDI dialog boxes must be created as child to the device window. They should also be created within the same thread that created the device because this enables the parent window to manage redrawing the child window.</p><p>The method has no effect for windowed mode applications, but this setting will be respected if the application resets the device into full-screen mode. If SetDialogBoxMode succeeds in a windowed mode application, any subsequent reset to full-screen mode will be checked against the restrictions listed above.  Also, SetDialogBoxMode causes all back buffers on the swap chain to be discarded, so an application is expected to refresh its content for all back buffers after this call.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetDialogBoxMode']/*"/>	
        /// <msdn-id>bb174432</msdn-id>	
        /// <unmanaged>SetDialogBoxMode</unmanaged>	
        /// <unmanaged-short>SetDialogBoxMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetDialogBoxMode([In] BOOL bEnableDialogs)</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool DialogBoxMode {
                set { SetDialogBoxMode(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the depth-stencil surface owned by the Direct3DDevice object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetDepthStencilSurface']/*"/>	
        /// <msdn-id>bb174384</msdn-id>	
        /// <unmanaged>GetDepthStencilSurface / SetDepthStencilSurface</unmanaged>	
        /// <unmanaged-short>GetDepthStencilSurface</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDepthStencilSurface([Out] IDirect3DSurface9** ppZStencilSurface)</unmanaged>
        public SharpDX.Direct3D9.Surface DepthStencilSurface {
                get { SharpDX.Direct3D9.Surface __output__; GetDepthStencilSurface(out __output__); return __output__; }
                set { SetDepthStencilSurface(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the viewport parameters currently set for the device.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Typically, methods that return state will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. This method however, will work even on a pure device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetViewport']/*"/>	
        /// <msdn-id>bb174420</msdn-id>	
        /// <unmanaged>GetViewport / SetViewport</unmanaged>	
        /// <unmanaged-short>GetViewport</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetViewport([Out] D3DVIEWPORT9* pViewport)</unmanaged>
        public SharpDX.Mathematics.Interop.RawViewport Viewport {
                get { SharpDX.Mathematics.Interop.RawViewport __output__; GetViewport(out __output__); return __output__; }
                set { SetViewport(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the current material properties for the device.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other values in <see cref="SharpDX.Direct3D9.CreateFlags"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetMaterial']/*"/>	
        /// <msdn-id>bb174394</msdn-id>	
        /// <unmanaged>GetMaterial / SetMaterial</unmanaged>	
        /// <unmanaged-short>GetMaterial</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetMaterial([Out] D3DMATERIAL9* pMaterial)</unmanaged>
        public SharpDX.Direct3D9.Material Material {
                get { SharpDX.Direct3D9.Material __output__; GetMaterial(out __output__); return __output__; }
                set { SetMaterial(ref value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the clip status.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>When clipping is enabled during vertex processing (by <strong><see cref="SharpDX.Direct3D9.Device.ProcessVertices"/></strong>, <strong><see cref="SharpDX.Direct3D9.Device.DrawPrimitives"/></strong>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <strong><see cref="SharpDX.Direct3D9.ClipStatus"/></strong>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When <see cref="SharpDX.Direct3D9.RenderState.Clipping"/> is set to <strong><see cref="SharpDX.Result.False"/></strong>, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing.</p><p>Clip status is not updated by <strong><see cref="SharpDX.Direct3D9.Device.DrawRectanglePatch"/></strong> and <strong><see cref="SharpDX.Direct3D9.Device.DrawTrianglePatch"/></strong> because there is no software emulation for them.</p><p>Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see <see cref="SharpDX.Direct3D9.CreateFlags"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetClipStatus']/*"/>	
        /// <msdn-id>bb174381</msdn-id>	
        /// <unmanaged>GetClipStatus / SetClipStatus</unmanaged>	
        /// <unmanaged-short>GetClipStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetClipStatus([Out] D3DCLIPSTATUS9* pClipStatus)</unmanaged>
        public SharpDX.Direct3D9.ClipStatus ClipStatus {
                get { SharpDX.Direct3D9.ClipStatus __output__; GetClipStatus(out __output__); return __output__; }
                set { SetClipStatus(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the current texture palette.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetCurrentTexturePalette']/*"/>	
        /// <msdn-id>bb174383</msdn-id>	
        /// <unmanaged>GetCurrentTexturePalette / SetCurrentTexturePalette</unmanaged>	
        /// <unmanaged-short>GetCurrentTexturePalette</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCurrentTexturePalette([Out] unsigned int* PaletteNumber)</unmanaged>
        public int CurrentTexturePalette {
                get { int __output__; GetCurrentTexturePalette(out __output__); return __output__; }
                set { SetCurrentTexturePalette(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the scissor rectangle.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The scissor rectangle is used as a rectangular clipping region.</p><p>See Rectangles (Direct3D 9) for further information on the use of rectangles in DirectX.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetScissorRect']/*"/>	
        /// <msdn-id>bb174407</msdn-id>	
        /// <unmanaged>GetScissorRect / SetScissorRect</unmanaged>	
        /// <unmanaged-short>GetScissorRect</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetScissorRect([Out] RECT* pRect)</unmanaged>
        public SharpDX.Mathematics.Interop.RawRectangle ScissorRect {
                get { SharpDX.Mathematics.Interop.RawRectangle __output__; GetScissorRect(out __output__); return __output__; }
                set { SetScissorRect(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the vertex processing (hardware or software) mode.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use <strong><see cref="SharpDX.Direct3D9.Device.SetRenderState"/></strong> with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate <see cref="SharpDX.Mathematics.Interop.RawBool"/> argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks.</p><p>In Direct3D 9, use <strong><see cref="SharpDX.Direct3D9.Device.SetSoftwareVertexProcessing"/></strong> instead. This new API is not recorded by StateBlocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetSoftwareVertexProcessing']/*"/>	
        /// <msdn-id>bb174408</msdn-id>	
        /// <unmanaged>GetSoftwareVertexProcessing / SetSoftwareVertexProcessing</unmanaged>	
        /// <unmanaged-short>GetSoftwareVertexProcessing</unmanaged-short>	
        /// <unmanaged>BOOL IDirect3DDevice9::GetSoftwareVertexProcessing()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool SoftwareVertexProcessing {
                get { return GetSoftwareVertexProcessing(); }
                set { SetSoftwareVertexProcessing(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the N-patch mode segments.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetNPatchMode']/*"/>	
        /// <msdn-id>bb174395</msdn-id>	
        /// <unmanaged>GetNPatchMode / SetNPatchMode</unmanaged>	
        /// <unmanaged-short>GetNPatchMode</unmanaged-short>	
        /// <unmanaged>float IDirect3DDevice9::GetNPatchMode()</unmanaged>
        public float NPatchMode {
                get { return GetNPatchMode(); }
                set { SetNPatchMode(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets a vertex shader declaration.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetVertexDeclaration']/*"/>	
        /// <msdn-id>bb174415</msdn-id>	
        /// <unmanaged>GetVertexDeclaration / SetVertexDeclaration</unmanaged>	
        /// <unmanaged-short>GetVertexDeclaration</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexDeclaration([Out] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>
        public SharpDX.Direct3D9.VertexDeclaration VertexDeclaration {
                get { SharpDX.Direct3D9.VertexDeclaration __output__; GetVertexDeclaration(out __output__); return __output__; }
                set { SetVertexDeclaration(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the fixed vertex function declaration.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The fixed vertex function declaration is a set of FVF flags that determine how vertices processed by the fixed function pipeline will be used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetFVF']/*"/>	
        /// <msdn-id>bb174389</msdn-id>	
        /// <unmanaged>GetFVF / SetFVF</unmanaged>	
        /// <unmanaged-short>GetFVF</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetFVF([Out] D3DFVF* pFVF)</unmanaged>
        public SharpDX.Direct3D9.VertexFormat VertexFormat {
                get { SharpDX.Direct3D9.VertexFormat __output__; GetVertexFormat(out __output__); return __output__; }
                set { SetVertexFormat(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the currently set vertex shader.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Typically, methods that return state will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. This method however, will work even on a pure device because it returns an interface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetVertexShader']/*"/>	
        /// <msdn-id>bb174416</msdn-id>	
        /// <unmanaged>GetVertexShader / SetVertexShader</unmanaged>	
        /// <unmanaged-short>GetVertexShader</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShader([Out] IDirect3DVertexShader9** ppShader)</unmanaged>
        public SharpDX.Direct3D9.VertexShader VertexShader {
                get { SharpDX.Direct3D9.VertexShader __output__; GetVertexShader(out __output__); return __output__; }
                set { SetVertexShader(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets index data.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetIndices']/*"/>	
        /// <msdn-id>bb174391</msdn-id>	
        /// <unmanaged>GetIndices / SetIndices</unmanaged>	
        /// <unmanaged-short>GetIndices</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetIndices([Out] IDirect3DIndexBuffer9** ppIndexData)</unmanaged>
        public SharpDX.Direct3D9.IndexBuffer Indices {
                get { SharpDX.Direct3D9.IndexBuffer __output__; GetIndices(out __output__); return __output__; }
                set { SetIndices(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the currently set pixel shader.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetPixelShader']/*"/>	
        /// <msdn-id>bb174398</msdn-id>	
        /// <unmanaged>GetPixelShader / SetPixelShader</unmanaged>	
        /// <unmanaged-short>GetPixelShader</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShader([Out] IDirect3DPixelShader9** ppShader)</unmanaged>
        public SharpDX.Direct3D9.PixelShader PixelShader {
                get { SharpDX.Direct3D9.PixelShader __output__; GetPixelShader(out __output__); return __output__; }
                set { SetPixelShader(value); }
        }
        
        /// <summary>	
        /// <p>Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>, indicating that the device is operational and the calling application can continue. If the method fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceNotReset"/>, <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>. </p></returns>	
        /// <remarks>	
        /// <p>If the device is lost but cannot be restored at the current time, <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong> returns the <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> return code. This would be the case, for example, when a full-screen device has lost focus. If an application detects a lost device, it should pause and periodically call <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong> until it receives a return value of <see cref="SharpDX.Direct3D9.ResultCode.DeviceNotReset"/>. The application may then attempt to reset the device by calling <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> and, if this succeeds, restore the necessary resources and resume normal operation. Note that <strong><see cref="SharpDX.Direct3D9.Device.Present"/></strong> will return <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> if the device is either "lost" or "not reset".</p><p>A call to <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong> will fail if called on a different thread than that used to create the device being reset.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::TestCooperativeLevel']/*"/>	
        /// <msdn-id>bb174472</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::TestCooperativeLevel()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::TestCooperativeLevel</unmanaged-short>	
        public SharpDX.Result TestCooperativeLevel() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns an estimate of the amount of available texture memory.</p>	
        /// </summary>	
        /// <returns><p>The function returns an estimate of the available texture memory.</p></returns>	
        /// <remarks>	
        /// <p>The returned value is rounded to the nearest MB. This is done to reflect the fact that video memory estimates are never precise due to alignment and other issues that affect consumption by certain resources. Applications can use this value to make gross estimates of memory availability to make large-scale resource decisions such as how many levels of a mipmap to attempt to allocate, but applications cannot use this value to make small-scale decisions such as if there is enough memory left to allocate another resource.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetAvailableTextureMem']/*"/>	
        /// <msdn-id>bb174378</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DDevice9::GetAvailableTextureMem()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetAvailableTextureMem</unmanaged-short>	
        internal int GetAvailableTextureMem() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Evicts all managed resources, including both Direct3D and driver-managed resources.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DERR_COMMAND_UNPARSED.</p></returns>	
        /// <remarks>	
        /// <p>This function causes only the <see cref="SharpDX.Direct3D9.Pool.Default"/> copy of resources to be evicted. The resource copy in system memory is retained. See <strong><see cref="SharpDX.Direct3D9.Pool"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::EvictManagedResources']/*"/>	
        /// <msdn-id>bb174377</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::EvictManagedResources()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::EvictManagedResources</unmanaged-short>	
        public void EvictManagedResources() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns an interface to the instance of the Direct3D object that created the device.</p>	
        /// </summary>	
        /// <param name="d3D9Out"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface, representing the interface of the Direct3D object that created the device. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>Calling <strong><see cref="SharpDX.Direct3D9.Device.GetDirect3D"/></strong> will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetDirect3D']/*"/>	
        /// <msdn-id>bb174386</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDirect3D([Out] IDirect3D9** ppD3D9)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetDirect3D</unmanaged-short>	
        internal void GetDirect3D(out SharpDX.Direct3D9.Direct3D d3D9Out) {
            unsafe {
                IntPtr d3D9Out_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &d3D9Out_,((void**)(*(void**)_nativePointer))[6]);		
                d3D9Out= (d3D9Out_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Direct3D(d3D9Out_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the capabilities of the rendering device.</p>	
        /// </summary>	
        /// <param name="capsRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure, describing the returned device. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Device.GetCapabilities"/></strong> retrieves the software vertex pipeline capabilities when the device is being used in software vertex processing mode.  </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetDeviceCaps']/*"/>	
        /// <msdn-id>bb174385</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDeviceCaps([Out] D3DCAPS9* pCaps)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetDeviceCaps</unmanaged-short>	
        internal void GetCapabilities(out SharpDX.Direct3D9.Capabilities capsRef) {
            unsafe {
                capsRef = new SharpDX.Direct3D9.Capabilities();
                SharpDX.Result __result__;
                fixed (void* capsRef_ = &capsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, capsRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>An unsigned integer specifying the swap chain.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayMode"/></strong> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. </p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetDisplayMode']/*"/>	
        /// <msdn-id>bb174387</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDisplayMode([In] unsigned int iSwapChain,[Out] D3DDISPLAYMODE* pMode)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetDisplayMode</unmanaged-short>	
        public SharpDX.Direct3D9.DisplayMode GetDisplayMode(int iSwapChain) {
            unsafe {
                SharpDX.Direct3D9.DisplayMode modeRef;
                modeRef = new SharpDX.Direct3D9.DisplayMode();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iSwapChain, &modeRef,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
                return modeRef;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the creation parameters of the device.</p>	
        /// </summary>	
        /// <param name="parametersRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.CreationParameters"/></strong> structure, describing the creation parameters of the device. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p><p><see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the argument is invalid.</p></returns>	
        /// <remarks>	
        /// <p>You can query the AdapterOrdinal member of the returned <strong><see cref="SharpDX.Direct3D9.CreationParameters"/></strong> structure to retrieve the ordinal of the adapter represented by this device. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetCreationParameters']/*"/>	
        /// <msdn-id>bb174382</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCreationParameters([Out] D3DDEVICE_CREATION_PARAMETERS* pParameters)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetCreationParameters</unmanaged-short>	
        internal void GetCreationParameters(out SharpDX.Direct3D9.CreationParameters parametersRef) {
            unsafe {
                parametersRef = new SharpDX.Direct3D9.CreationParameters();
                SharpDX.Result __result__;
                fixed (void* parametersRef_ = &parametersRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, parametersRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets properties for the cursor.</p>	
        /// </summary>	
        /// <param name="xHotSpot"><dd>  <p>X-coordinate offset (in pixels) that marks the center of the cursor. The offset is relative to the upper-left corner of the cursor. When the cursor is given a new position, the image is drawn at an offset from this new position determined by subtracting the hot spot coordinates from the position. </p> </dd></param>	
        /// <param name="yHotSpot"><dd>  <p>Y-coordinate offset (in pixels) that marks the center of the cursor. The offset is relative to the upper-left corner of the cursor. When the cursor is given a new position, the image is drawn at an offset from this new position determined by subtracting the hot spot coordinates from the position. </p> </dd></param>	
        /// <param name="cursorBitmapRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. This parameter must point to an 8888 ARGB surface (format <see cref="SharpDX.Direct3D9.Format.A8R8G8B8"/>). The contents of this surface will be copied and potentially format-converted into an internal buffer from which the cursor is displayed. The dimensions of this surface must be less than the dimensions of the display mode, and must be a power of two in each direction, although not necessarily the same power of two. The alpha channel must be either 0.0 or 1.0. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>An operating system cursor is created and used under either of these conditions:</p><ul> <li>The hardware has set <see cref="SharpDX.Direct3D9.CursorCaps.Color"/> (see <see cref="SharpDX.Direct3D9.CursorCaps"/>), and the cursor size is 32x32 (which is the cursor size in the operating system).</li> <li>The application is running in windowed mode.</li> </ul><p>Otherwise, DirectX uses an emulated cursor. An application uses <strong><see cref="SharpDX.Direct3D9.Device.SetCursorPosition"/></strong> to move an emulated cursor to follow mouse movement.</p><p>It is recommended for applications to always trap WM_MOUSEMOVE events and call DXSetCursorPosition.</p><p>Direct3D cursor functions use either GDI cursor or software emulation, depending on the hardware. Users typically want to respond to a WM_SETCURSOR message. For example, they might want to write the message handler as follows:</p><pre> case WM_SETCURSOR:	
        /// // Turn off window cursor. 	
        /// SetCursor( <c>null</c> );	
        /// m_pd3dDevice-&gt;ShowCursor( TRUE );	
        /// return TRUE; // Prevent Windows from setting cursor to window class cursor.	
        /// break;	
        /// </pre><p>Or, users might want to call the <strong><see cref="SharpDX.Direct3D9.Device.SetCursorProperties"/></strong> method if they want to change the cursor. </p><p>The application can determine what hardware support is available for cursors by examining appropriate members of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure. Typically, hardware supports only 32x32 cursors and, when windowed, the system might support only 32x32 cursors. In this case, <strong><see cref="SharpDX.Direct3D9.Device.SetCursorProperties"/></strong> still succeeds but the cursor might be reduced to that size. The hot spot is scaled appropriately.</p><p>The cursor does not survive when the device is lost. This method must be called after the device is reset.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetCursorProperties']/*"/>	
        /// <msdn-id>bb174430</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetCursorProperties([In] unsigned int XHotSpot,[In] unsigned int YHotSpot,[In] IDirect3DSurface9* pCursorBitmap)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetCursorProperties</unmanaged-short>	
        public void SetCursorProperties(int xHotSpot, int yHotSpot, SharpDX.Direct3D9.Surface cursorBitmapRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, xHotSpot, yHotSpot, (void*)((cursorBitmapRef == null)?IntPtr.Zero:cursorBitmapRef.NativePointer),((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the cursor position and update options.</p>	
        /// </summary>	
        /// <param name="x"><dd>  <p>The new X-position of the cursor in virtual desktop coordinates. See Remarks. </p> </dd></param>	
        /// <param name="y"><dd>  <p>The new Y-position of the cursor in virtual desktop coordinates. See Remarks. </p> </dd></param>	
        /// <param name="flags"><dd>  <p> </p><p>Specifies the update options for the cursor. Currently, only one flag is defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>D3DCURSOR_IMMEDIATE_UPDATE</strong></dt> </dl> </td><td> <p>Update cursor at the refresh rate.</p> <p>If this flag is specified, the system guarantees that the cursor will be updated at a minimum of half the display refresh rate, but never more frequently than the display refresh rate. Otherwise, the method delays cursor updates until the next <strong><see cref="SharpDX.Direct3D9.Device.Present"/></strong> call. Not setting this flag usually results in better performance than if the flag is set. However, applications should set this flag if the rate of calls to Present is low enough that users would notice a significant delay in cursor motion. This flag has no effect in a windowed-mode application. Some video cards implement hardware color cursors. This flag does not have an effect on these cards.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <remarks>	
        /// <p>When running in full-screen mode, screen space coordinates are the back buffer coordinates appropriately scaled to the current display mode. When running in windowed mode, screen space coordinates are the desktop coordinates. The cursor image is drawn at the specified position minus the hotspot-offset specified by the <strong>SetCursorProperties</strong> method.</p><p>If the cursor has been hidden by <strong>ShowCursor</strong>, the cursor is not drawn.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetCursorPosition']/*"/>	
        /// <msdn-id>bb174429</msdn-id>	
        /// <unmanaged>void IDirect3DDevice9::SetCursorPosition([In] int X,[In] int Y,[In] unsigned int Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetCursorPosition</unmanaged-short>	
        internal void SetCursorPosition(int x, int y, int flags) {
            unsafe {
                SharpDX.Direct3D9.LocalInterop.Callivoid(_nativePointer, x, y, flags,((void**)(*(void**)_nativePointer))[11]);		
            }
        }
        
        /// <summary>	
        /// <p>Displays or hides the cursor.</p>	
        /// </summary>	
        /// <param name="bShow"><dd>  <p>If bShow is <strong>TRUE</strong>, the cursor is shown. If bShow is <strong><see cref="SharpDX.Result.False"/></strong>, the cursor is hidden. </p> </dd></param>	
        /// <returns><p>Value indicating whether the cursor was previously visible. <strong>TRUE</strong> if the cursor was previously visible, or <strong><see cref="SharpDX.Result.False"/></strong> if the cursor was not previously visible.</p></returns>	
        /// <remarks>	
        /// <p>Direct3D cursor functions use either GDI cursor or software emulation, depending on the hardware. Users usually want to respond to a WM_SETCURSOR message. For example, the users might want to write the message handler like this:</p><pre> case WM_SETCURSOR: // Turn off window cursor  SetCursor( <c>null</c> ); m_pd3dDevice-&gt;ShowCursor( TRUE ); return TRUE; // prevent Windows from setting cursor to window class cursor break;	
        /// </pre><p>Or users might want to call the <strong><see cref="SharpDX.Direct3D9.Device.SetCursorProperties"/></strong> method if they want to change the cursor. See the code in the DirectX Graphics C/C++ Samples for more detail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::ShowCursor']/*"/>	
        /// <msdn-id>bb174470</msdn-id>	
        /// <unmanaged>BOOL IDirect3DDevice9::ShowCursor([In] BOOL bShow)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::ShowCursor</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetSetShowCursor(SharpDX.Mathematics.Interop.RawBool bShow) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawBool14(_nativePointer, bShow,((void**)(*(void**)_nativePointer))[12]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Creates an additional swap chain for rendering multiple views.</p>	
        /// </summary>	
        /// <param name="presentationParametersRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structure, containing the presentation parameters for the new swap chain. This value cannot be <strong><c>null</c></strong>.</p> <p>Calling this method changes the value of members of the <see cref="SharpDX.Direct3D9.PresentParameters"/> structure.</p> <ul> <li>If BackBufferCount == 0, calling CreateAdditionalSwapChain will increase it to 1.</li> <li>If the application is in windowed mode, and if either the BackBufferWidth or the BackBufferHeight == 0, they will be set to the client area width and height of the hwnd.</li> </ul> </dd></param>	
        /// <param name="swapChainRef"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.SwapChain"/></strong> interface, representing the additional swap chain. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>There is always at least one swap chain (the implicit swap chain) for each device because Direct3D 9 has one swap chain as a property of the device. </p><p>Note that any given device can support only one full-screen swap chain.</p><p><see cref="SharpDX.Direct3D9.Format.Unknown"/> can be specified for the windowed mode back buffer format when calling <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>, <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> and CreateAdditionalSwapChain. This means the application does not have to query the current desktop format before calling CreateDevice for windowed mode. For full-screen mode, the back buffer format must be specified. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateAdditionalSwapChain']/*"/>	
        /// <msdn-id>bb174354</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateAdditionalSwapChain([In] D3DPRESENT_PARAMETERS* pPresentationParameters,[Out, Fast] IDirect3DSwapChain9** pSwapChain)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateAdditionalSwapChain</unmanaged-short>	
        internal void CreateAdditionalSwapChain(ref SharpDX.Direct3D9.PresentParameters presentationParametersRef, SharpDX.Direct3D9.SwapChain swapChainRef) {
            unsafe {
                IntPtr swapChainRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* presentationParametersRef_ = &presentationParametersRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, presentationParametersRef_, &swapChainRef_,((void**)(*(void**)_nativePointer))[13]);		
                ((SharpDX.Direct3D9.SwapChain)swapChainRef).NativePointer = swapChainRef_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a reference to a swap chain.</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>The swap chain ordinal value.  For more information, see NumberOfAdaptersInGroup in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.SwapChain"/></strong> interface that will receive a copy of swap chain. </p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetSwapChain']/*"/>	
        /// <msdn-id>bb174411</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetSwapChain([In] unsigned int iSwapChain,[Out] IDirect3DSwapChain9** pSwapChain)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetSwapChain</unmanaged-short>	
        public SharpDX.Direct3D9.SwapChain GetSwapChain(int iSwapChain) {
            unsafe {
                SharpDX.Direct3D9.SwapChain swapChainRef;
                IntPtr swapChainRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iSwapChain, &swapChainRef_,((void**)(*(void**)_nativePointer))[14]);		
                swapChainRef= (swapChainRef_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.SwapChain(swapChainRef_);	
                __result__.CheckError();
                return swapChainRef;
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of implicit swap chains.</p>	
        /// </summary>	
        /// <returns><p>Number of implicit swap chains. See Remarks.</p></returns>	
        /// <remarks>	
        /// <p>Implicit swap chains are created by the device during <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>. This method returns the number of swap chains created by CreateDevice.  </p><p>An application may create additional swap chains using <strong><see cref="SharpDX.Direct3D9.Device.CreateAdditionalSwapChain"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetNumberOfSwapChains']/*"/>	
        /// <msdn-id>bb174396</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DDevice9::GetNumberOfSwapChains()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetNumberOfSwapChains</unmanaged-short>	
        internal int GetSwapChainCount() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Resets the type, size, and format of the swap chain.</p>	
        /// </summary>	
        /// <param name="presentationParametersRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structure, describing the new presentation parameters. This value cannot be <strong><c>null</c></strong>.  </p> <p>When switching to full-screen mode, Direct3D will try to find a desktop format that matches the back buffer format, so that back buffer and front buffer formats will be identical (to eliminate the need for color conversion).</p> <p>When this method returns:</p> <ul> <li>BackBufferCount, BackBufferWidth, and BackBufferHeight are set to zero.</li> <li>BackBufferFormat is set to <see cref="SharpDX.Direct3D9.Format.Unknown"/> for windowed mode only; a full-screen mode must specify a format.</li> </ul> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Direct3D9.ResultCode.Success"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/>, <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>, or <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/> (see D3DERR).</p></returns>	
        /// <remarks>	
        /// <p>If a call to <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> fails, the device will be placed in the "lost" state (as indicated by a return value of <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> from a call to <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong>) unless it is already in the "not reset" state (as indicated by a return value of <see cref="SharpDX.Direct3D9.ResultCode.DeviceNotReset"/> from a call to <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong>). Refer to <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong> and Lost Devices (Direct3D 9) for further information concerning the use of <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> in the context of lost devices.</p><p>Calling <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> causes all texture memory surfaces to be lost, managed textures to be flushed from video memory, and all state information to be lost. Before calling the <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> method for a device, an application should release any explicit render targets, depth stencil surfaces, additional swap chains, state blocks, and <see cref="SharpDX.Direct3D9.Pool.Default"/> resources associated with the device.</p><p>There are two different types of swap chains: full-screen or windowed. If the new swap chain is full-screen, the adapter will be placed in the display mode that matches the new size.</p><p>Direct3D 9 applications can expect messages to be sent to them during this call (for example, before this call is returned); applications should take precautions not to call into Direct3D at this time. In addition, when <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> fails, the only valid methods that can be called are <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>, <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong>, and the various Release member functions. Calling any other method can result in an exception.</p><p>A call to <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> will fail if called on a different thread than that used to create the device being reset.</p><p>Pixel shaders and vertex shaders survive <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> calls for Direct3D 9. They do not need to be re-created explicitly by the application.</p><p> <see cref="SharpDX.Direct3D9.Format.Unknown"/> can be specified for the windowed mode back buffer format when calling <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>, <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>, and <strong><see cref="SharpDX.Direct3D9.Device.CreateAdditionalSwapChain"/></strong>. This means the application does not have to query the current desktop format before calling <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong> for windowed mode. For full-screen mode, the back buffer format must be specified. Setting BackBufferCount equal to zero  (BackBufferCount = 0) results in one back buffer.</p><p>When trying to reset more than one display adapter in a group, set pPresentationParameters to point to an array of <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structures, one for each display in the adapter group.</p><p>If a multihead device was created with <see cref="SharpDX.Direct3D9.CreateFlags.AdapterGroupDevice"/>, <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> requires an array of <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structures wherein each structure must specify a full-screen display. To switch back to windowed mode, the application must destroy the device and re-create a non-multihead device in windowed mode.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::Reset']/*"/>	
        /// <msdn-id>bb174425</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::Reset([In, Out, Params] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::Reset</unmanaged-short>	
        public void Reset(params SharpDX.Direct3D9.PresentParameters[] presentationParametersRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* presentationParametersRef_ = presentationParametersRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, presentationParametersRef_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Presents the contents of the next buffer in the sequence of back buffers owned by the device.</p>	
        /// </summary>	
        /// <param name="sourceRectRef"><dd>  <p>Pointer to a value that must be <strong><c>null</c></strong> unless the swap chain was created with <see cref="SharpDX.Direct3D9.SwapEffect.Copy"/>. pSourceRect is a reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure containing the source rectangle. If <strong><c>null</c></strong>, the entire source surface is presented. If the rectangle exceeds the source surface, the rectangle is clipped to the source surface. </p> </dd></param>	
        /// <param name="destRectRef"><dd>  <p>Pointer to a value that must be <strong><c>null</c></strong> unless the swap chain was created with <see cref="SharpDX.Direct3D9.SwapEffect.Copy"/>. pDestRect is a reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure containing the destination rectangle, in window client coordinates. If <strong><c>null</c></strong>, the entire client area is filled. If the rectangle exceeds the destination client area, the rectangle is clipped to the destination client area. </p> </dd></param>	
        /// <param name="hDestWindowOverride"><dd>  <p>Pointer to a destination window whose client area is taken as the target for this presentation. If this value is <strong><c>null</c></strong>, the runtime uses the <strong>hDeviceWindow</strong> member of <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> for the presentation.</p> </dd></param>	
        /// <param name="dirtyRegionRef"><dd>  <p>Value must be <strong><c>null</c></strong> unless the swap chain was created with <see cref="SharpDX.Direct3D9.SwapEffect.Copy"/>. For more information about swap chains, see Flipping Surfaces (Direct3D 9) and <strong><see cref="SharpDX.Direct3D9.SwapEffect"/></strong>. If this value is non-<strong><c>null</c></strong>, the contained region is expressed in back buffer coordinates. The rectangles within the region are the minimal set of pixels that need to be updated. This method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation can choose to copy the whole source rectangle.  </p> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Direct3D9.ResultCode.Success"/> or <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/> (see D3DERR).</p></returns>	
        /// <remarks>	
        /// <p>If necessary, a stretch operation is applied to transfer the pixels within the source rectangle to the destination rectangle in the client area of the target window. </p><p><strong>Present</strong> will fail, returning <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, if called between BeginScene and EndScene pairs unless the render target is not the current render target (such as the back buffer you get from creating an additional swap chain). This is a new behavior for Direct3D 9. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::Present']/*"/>	
        /// <msdn-id>bb174423</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::Present([In] const void* pSourceRect,[In] const void* pDestRect,[In] HWND hDestWindowOverride,[In] const void* pDirtyRegion)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::Present</unmanaged-short>	
        internal void Present(System.IntPtr sourceRectRef, System.IntPtr destRectRef, System.IntPtr hDestWindowOverride, System.IntPtr dirtyRegionRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)sourceRectRef, (void*)destRectRef, (void*)hDestWindowOverride, (void*)dirtyRegionRef,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a back buffer from the device's swap chain.</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>An unsigned integer specifying the swap chain.</p> </dd></param>	
        /// <param name="iBackBuffer"><dd>  <p>Index of the back buffer object to return. Back buffers are numbered from 0 to the total number of back buffers minus one. A value of 0 returns the first back buffer, not the front buffer. The front buffer is not accessible through this method. Use <strong><see cref="SharpDX.Direct3D9.Device.GetFrontBufferData"/></strong> to retrieve a copy of the front buffer.</p> </dd></param>	
        /// <param name="type"><dd>  <p>Stereo view is not supported in Direct3D 9, so the only valid value for this parameter is <see cref="SharpDX.Direct3D9.BackBufferType.Mono"/>. </p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the returned back buffer surface. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetBackBuffer']/*"/>	
        /// <msdn-id>bb174379</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetBackBuffer([In] unsigned int iSwapChain,[In] unsigned int iBackBuffer,[In] D3DBACKBUFFER_TYPE Type,[Out] IDirect3DSurface9** ppBackBuffer)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetBackBuffer</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface GetBackBuffer(int iSwapChain, int iBackBuffer, SharpDX.Direct3D9.BackBufferType type) {
            unsafe {
                SharpDX.Direct3D9.Surface backBufferOut;
                IntPtr backBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iSwapChain, iBackBuffer, unchecked((int)type), &backBufferOut_,((void**)(*(void**)_nativePointer))[18]);		
                backBufferOut= (backBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(backBufferOut_);	
                __result__.CheckError();
                return backBufferOut;
            }
        }
        
        /// <summary>	
        /// <p>Returns information describing the raster of the monitor on which the swap chain is presented.</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>An unsigned integer specifying the swap chain.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.RasterStatus"/></strong> structure filled with information about the position or other status of the raster on the monitor driven by this adapter. </p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetRasterStatus']/*"/>	
        /// <msdn-id>bb174402</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRasterStatus([In] unsigned int iSwapChain,[Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetRasterStatus</unmanaged-short>	
        public SharpDX.Direct3D9.RasterStatus GetRasterStatus(int iSwapChain) {
            unsafe {
                SharpDX.Direct3D9.RasterStatus rasterStatusRef;
                rasterStatusRef = new SharpDX.Direct3D9.RasterStatus();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iSwapChain, &rasterStatusRef,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
                return rasterStatusRef;
            }
        }
        
        /// <summary>	
        /// <p>This method allows the use of GDI dialog boxes in full-screen mode applications.</p>	
        /// </summary>	
        /// <param name="bEnableDialogs"><dd>  <p><strong>TRUE</strong> to enable GDI dialog boxes, and <strong><see cref="SharpDX.Result.False"/></strong> to disable them.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> unless all of the following are true. </p><ul> <li>The application specified a back buffer format compatible with GDI, in other words, one of <see cref="SharpDX.Direct3D9.Format.X1R5G5B5"/>, <see cref="SharpDX.Direct3D9.Format.R5G6B5"/>, or <see cref="SharpDX.Direct3D9.Format.X8R8G8B8"/>.</li> <li>The application specified no multisampling.</li> <li>The application specified <see cref="SharpDX.Direct3D9.SwapEffect.Discard"/>.</li> <li>The application specified <see cref="SharpDX.Direct3D9.PresentFlags.LockableBackBuffer"/>.</li> <li>The application did not specify <see cref="SharpDX.Direct3D9.CreateFlags.AdapterGroupDevice"/>.</li> <li>The application is not between BeginScene and EndScene.</li> </ul></returns>	
        /// <remarks>	
        /// <p>The GDI dialog boxes must be created as child to the device window. They should also be created within the same thread that created the device because this enables the parent window to manage redrawing the child window.</p><p>The method has no effect for windowed mode applications, but this setting will be respected if the application resets the device into full-screen mode. If SetDialogBoxMode succeeds in a windowed mode application, any subsequent reset to full-screen mode will be checked against the restrictions listed above.  Also, SetDialogBoxMode causes all back buffers on the swap chain to be discarded, so an application is expected to refresh its content for all back buffers after this call.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetDialogBoxMode']/*"/>	
        /// <msdn-id>bb174432</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetDialogBoxMode([In] BOOL bEnableDialogs)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetDialogBoxMode</unmanaged-short>	
        internal void SetDialogBoxMode(SharpDX.Mathematics.Interop.RawBool bEnableDialogs) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint17(_nativePointer, bEnableDialogs,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the gamma correction ramp for the implicit swap chain. This method will affect the entire screen (not just the active window if you are running in windowed mode).</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>Unsigned integer specifying the swap chain.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Indicates whether correction should be applied. Gamma correction results in a more consistent display, but can incur processing overhead and should not be used frequently. Short-duration effects, such as flashing the whole screen red, should not be calibrated, but long-duration gamma changes should be calibrated. One of the following values can be set: </p> <p></p> <table> <tr><th>Item</th><th>Description</th></tr> <tr><td> <p>D3DSGR_CALIBRATE</p> </td><td> <p>If a gamma calibrator is installed, the ramp will be modified before being sent to the device to account for the system and monitor response curves. If a calibrator is not installed, the ramp will be passed directly to the device.</p> </td></tr> <tr><td> <p>D3DSGR_NO_CALIBRATION</p> </td><td> <p>No gamma correction is applied. The supplied gamma table is transferred directly to the device.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="rampRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.GammaRamp"/></strong> structure, representing the gamma correction ramp to be set for the implicit swap chain. </p> </dd></param>	
        /// <remarks>	
        /// <p>There is always at least one swap chain (the implicit swap chain) for each device, because Direct3D 9 has one swap chain as a property of the device. The gamma ramp takes effect immediately; there is no wait for a vertical sync.</p><p>If the device does not support gamma ramps in the swap chain's current presentation mode (full-screen or windowed), no error return is given. Applications can check the <see cref="SharpDX.Direct3D9.Caps2.FullScreenGamma"/> and <see cref="SharpDX.Direct3D9.Caps2.CanCalibrateGamma"/> capability bits in the Caps2 member of the <see cref="SharpDX.Direct3D9.Capabilities"/> structure to determine the capabilities of the device and whether a calibrator is installed.</p><p>For windowed gamma correction presentation, use <strong><see cref="SharpDX.Direct3D9.SwapChain.Present"/></strong> if the hardware supports the feature. In DirectX 8, SetGammaRamp will set the gamma ramp only on a full-screen mode application. For more information about gamma correction, see Gamma (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetGammaRamp']/*"/>	
        /// <msdn-id>bb174434</msdn-id>	
        /// <unmanaged>void IDirect3DDevice9::SetGammaRamp([In] unsigned int iSwapChain,[In] unsigned int Flags,[In] const D3DGAMMARAMP* pRamp)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetGammaRamp</unmanaged-short>	
        internal void SetGammaRamp(int iSwapChain, int flags, ref SharpDX.Direct3D9.GammaRamp rampRef) {
            unsafe {
                var rampRef_ = new SharpDX.Direct3D9.GammaRamp.__Native();
                rampRef.__MarshalTo(ref rampRef_);
                SharpDX.Direct3D9.LocalInterop.Callivoid(_nativePointer, iSwapChain, flags, &rampRef_,((void**)(*(void**)_nativePointer))[21]);		
                rampRef.__MarshalFree(ref rampRef_);
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the gamma correction ramp for the swap chain.</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>An unsigned integer specifying the swap chain.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetGammaRamp']/*"/>	
        /// <msdn-id>bb174390</msdn-id>	
        /// <unmanaged>void IDirect3DDevice9::GetGammaRamp([In] unsigned int iSwapChain,[Out] D3DGAMMARAMP* pRamp)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetGammaRamp</unmanaged-short>	
        public SharpDX.Direct3D9.GammaRamp GetGammaRamp(int iSwapChain) {
            unsafe {
                SharpDX.Direct3D9.GammaRamp rampRef;
                var rampRef_ = new SharpDX.Direct3D9.GammaRamp.__Native();
                SharpDX.Direct3D9.LocalInterop.Callivoid(_nativePointer, iSwapChain, &rampRef_,((void**)(*(void**)_nativePointer))[22]);		
                rampRef = new SharpDX.Direct3D9.GammaRamp();
                rampRef.__MarshalFrom(ref rampRef_);
                return rampRef;
            }
        }
        
        /// <summary>	
        /// <p>Creates a texture resource.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the top-level of the texture, in pixels. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's  pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0, 1 will be taken instead. </p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the top-level of the texture, in pixels. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's  pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0, 1 will be taken instead. </p> </dd></param>	
        /// <param name="levels"><dd>  <p>Number of levels in the texture. If this is zero, Direct3D will generate all texture sublevels down to 1 by 1 pixels for hardware that supports  mipmapped textures. Call <strong><see cref="SharpDX.Direct3D9.BaseTexture.GetLevelCount"/></strong> to see the number of levels generated. </p> </dd></param>	
        /// <param name="usage"><dd>  <p>Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <strong><see cref="SharpDX.Direct3D9.Usage"/></strong> constants. It is  good practice to match the usage parameter with the behavior flags in <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of all levels in the texture. </p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the texture should be placed. </p> </dd></param>	
        /// <param name="textureOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the created texture resource. </p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to  share resources.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>,  <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>An application can discover support for Automatic Generation of Mipmaps (Direct3D 9) in a particular format by calling  <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceFormat_"/></strong> with <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/>. If <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceFormat_"/></strong> returns <see cref="SharpDX.Direct3D9.ResultCode.NoAutomaticGeneration"/>,  <strong><see cref="SharpDX.Direct3D9.Device.CreateTexture"/></strong> will succeed but it will return a one-level texture.</p><p>In Windows Vista CreateTexture can create a texture from a system memory reference allowing the application more flexibility over the use, allocation and deletion of  the system memory.  For example, an application could pass a GDI system memory bitmap reference and get a Direct3D texture interface around it.  Using a system memory  reference with CreateTexture has the following restrictions.</p><ul> <li>The pitch of the texture must be equal to the width multiplied by the number of bytes per pixel.</li> <li>Only textures with a single mipmap level are supported.  The <em>Levels</em> argument must be 1.</li> <li>The <em>Pool</em> argument must be <see cref="SharpDX.Direct3D9.Pool.SystemMemory"/>.</li> <li>The <em>pSharedHandle</em> argument must be a valid reference to a buffer that can hold the system memory point; <em>*pSharedHandle</em> must  be a valid reference to system memory with a size in bytes of texture width * texture height * bytes per pixel of the texture format.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateTexture']/*"/>	
        /// <msdn-id>bb174363</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateTexture([In] unsigned int Width,[In] unsigned int Height,[In] unsigned int Levels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[Out, Fast] IDirect3DTexture9** ppTexture,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateTexture</unmanaged-short>	
        internal void CreateTexture(int width, int height, int levels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, SharpDX.Direct3D9.Texture textureOut, System.IntPtr sharedHandleRef) {
            unsafe {
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, width, height, levels, usage, unchecked((int)format), unchecked((int)pool), &textureOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[23]);		
                ((SharpDX.Direct3D9.Texture)textureOut).NativePointer = textureOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a volume texture resource.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the top-level of the volume texture, in pixels. This value must be a power of two if the <see cref="SharpDX.Direct3D9.TextureCaps.VolumeMapPow2"/> member of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by two results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the top-level of the volume texture, in pixels. This value must be a power of two if the <see cref="SharpDX.Direct3D9.TextureCaps.VolumeMapPow2"/> member of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="depth"><dd>  <p>Depth of the top-level of the volume texture, in pixels. This value must be a power of two if the <see cref="SharpDX.Direct3D9.TextureCaps.VolumeMapPow2"/> member of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> is set. The pixel dimensions of subsequent levels will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="levels"><dd>  <p>Number of levels in the texture. If this is zero, Direct3D will generate all texture sublevels down to 1x1 pixels for hardware that supports mipmapped volume textures. Call <strong><see cref="SharpDX.Direct3D9.BaseTexture.GetLevelCount"/></strong> to see the number of levels generated. </p> </dd></param>	
        /// <param name="usage"><dd>  <p>Usage can be 0, which indicates no usage value. If usage is desired, use <see cref="SharpDX.Direct3D9.Usage.Dynamic"/> or <see cref="SharpDX.Direct3D9.Usage.SoftwareProcessing"/>. For more information, see <strong><see cref="SharpDX.Direct3D9.Usage"/></strong>. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of all levels in the volume texture. </p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the volume texture should be placed. </p> </dd></param>	
        /// <param name="volumeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface, representing the created volume texture resource. </p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateVolumeTexture']/*"/>	
        /// <msdn-id>bb174367</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVolumeTexture([In] unsigned int Width,[In] unsigned int Height,[In] unsigned int Depth,[In] unsigned int Levels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[Out, Fast] IDirect3DVolumeTexture9** ppVolumeTexture,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateVolumeTexture</unmanaged-short>	
        internal void CreateVolumeTexture(int width, int height, int depth, int levels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, SharpDX.Direct3D9.VolumeTexture volumeTextureOut, System.IntPtr sharedHandleRef) {
            unsafe {
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, width, height, depth, levels, usage, unchecked((int)format), unchecked((int)pool), &volumeTextureOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[24]);		
                ((SharpDX.Direct3D9.VolumeTexture)volumeTextureOut).NativePointer = volumeTextureOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a cube texture resource.</p>	
        /// </summary>	
        /// <param name="edgeLength"><dd>  <p>Size of the edges of all the top-level faces of the cube texture. The pixel dimensions of subsequent levels of each face will be the truncated value of half of the previous level's pixel dimension (independently). Each dimension clamps at a size of 1 pixel. Thus, if the division by 2 results in 0 (zero), 1 will be taken instead. </p> </dd></param>	
        /// <param name="levels"><dd>  <p>Number of levels in each face of the cube texture. If this is zero, Direct3D will generate all cube texture sublevels down to 1x1 pixels for each face for hardware that supports mipmapped cube textures.  Call <strong><see cref="SharpDX.Direct3D9.BaseTexture.GetLevelCount"/></strong> to see the number of levels generated. </p> </dd></param>	
        /// <param name="usage"><dd>  <p>Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <strong><see cref="SharpDX.Direct3D9.Usage"/></strong> constants. It is good practice to match the usage parameter in CreateCubeTexture with the behavior flags in <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>. For more information, see Remarks. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of all levels in all faces of the cube texture. </p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the cube texture should be placed. </p> </dd></param>	
        /// <param name="cubeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface, representing the created cube texture resource. </p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>A mipmap (texture) is a collection of successively downsampled (mipmapped) surfaces. On the other hand, a cube texture (created by <strong><see cref="SharpDX.Direct3D9.Device.CreateCubeTexture"/></strong>) is a collection of six textures (mipmaps), one for each face. All faces must be present in the cube texture. Also, a cube map surface must be the same pixel size in all three dimensions (x, y, and z).</p><p>An application can discover support for Automatic Generation of Mipmaps (Direct3D 9) in a particular format by calling <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceFormat_"/></strong> with <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/>. If <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceFormat_"/></strong> returns <see cref="SharpDX.Direct3D9.ResultCode.NoAutomaticGeneration"/>, <strong><see cref="SharpDX.Direct3D9.Device.CreateCubeTexture"/></strong> will succeed but it will return a one-level texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateCubeTexture']/*"/>	
        /// <msdn-id>bb174355</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateCubeTexture([In] unsigned int EdgeLength,[In] unsigned int Levels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[Out, Fast] IDirect3DCubeTexture9** ppCubeTexture,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateCubeTexture</unmanaged-short>	
        internal void CreateCubeTexture(int edgeLength, int levels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, SharpDX.Direct3D9.CubeTexture cubeTextureOut, System.IntPtr sharedHandleRef) {
            unsafe {
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, edgeLength, levels, usage, unchecked((int)format), unchecked((int)pool), &cubeTextureOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[25]);		
                ((SharpDX.Direct3D9.CubeTexture)cubeTextureOut).NativePointer = cubeTextureOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a vertex buffer.</p>	
        /// </summary>	
        /// <param name="length"><dd>  <p>Size of the vertex buffer, in bytes. For FVF vertex buffers, Length must be large enough to contain at least one vertex, but it need not be a multiple of the vertex size. Length is not validated for non-FVF buffers. See Remarks. </p> </dd></param>	
        /// <param name="usage"><dd>  <p>Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <strong><see cref="SharpDX.Direct3D9.Usage"/></strong> constants. It is good practice to match the usage parameter in CreateVertexBuffer with the behavior flags in <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>. For more information, see Remarks. </p> </dd></param>	
        /// <param name="vertexFormat"><dd>  <p>Combination of <see cref="SharpDX.Direct3D9.VertexFormat"/>, a usage specifier that describes the vertex format of the vertices in this buffer. If this parameter is set to a valid FVF code, the created vertex buffer is an FVF vertex buffer (see Remarks). Otherwise, if this parameter is set to zero, the vertex buffer is a non-FVF vertex buffer. </p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing a valid memory class into which to place the resource. Do not set to <see cref="SharpDX.Direct3D9.Pool.Scratch"/>.</p> </dd></param>	
        /// <param name="vertexBufferOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface, representing the created vertex buffer resource. </p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>A vertex buffer can be used with either hardware or software vertex processing. This is determined by how the device and the vertex buffer are created.</p><p>When a device is created, CreateDevice uses the behavior flag to determine whether to process vertices in hardware or software. There are three possibilities:</p><ul> <li>Process vertices in hardware by setting <see cref="SharpDX.Direct3D9.CreateFlags.HardwareVertexProcessing"/>.</li> <li>Process vertices in software by setting <see cref="SharpDX.Direct3D9.CreateFlags.SoftwareVertexProcessing"/>.</li> <li>Process vertices in either hardware or software by setting <see cref="SharpDX.Direct3D9.CreateFlags.MixedVertexProcessing"/>.</li> </ul><p>Mixed-mode devices might need to switch between software and hardware processing (using <strong><see cref="SharpDX.Direct3D9.Device.SetSoftwareVertexProcessing"/></strong>) after the device is created.    </p><p>When a vertex buffer is created, CreateVertexBuffer uses the usage parameter to decide whether to process vertices in hardware or software.</p><ul> <li>If CreateDevice uses <see cref="SharpDX.Direct3D9.CreateFlags.HardwareVertexProcessing"/>, CreateVertexBuffer must use 0.</li> <li>If CreateDevice uses <see cref="SharpDX.Direct3D9.CreateFlags.SoftwareVertexProcessing"/>, CreateVertexBuffer must use either 0 or <see cref="SharpDX.Direct3D9.Usage.SoftwareProcessing"/>. For either value, vertices will be processed in software.</li> <li>If CreateDevice uses <see cref="SharpDX.Direct3D9.CreateFlags.MixedVertexProcessing"/>, CreateVertexBuffer can use either 0 or <see cref="SharpDX.Direct3D9.Usage.SoftwareProcessing"/>.</li> </ul><p>To use a vertex buffer with a mixed mode device, create a single vertex buffer which can be used for both hardware or software processing. Use <strong><see cref="SharpDX.Direct3D9.Device.SetStreamSource"/></strong> to set the current vertex buffer and use <strong><see cref="SharpDX.Direct3D9.Device.SetRenderState"/></strong>, if necessary, to change the device behavior to match. It is recommended that the vertex buffer usage matches the device behavior. Note that a vertex buffer created for software processing cannot be located in video memory.</p><p>The <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface supports rendering of primitives using vertex data stored in vertex buffer objects. Vertex buffers are created from the <see cref="SharpDX.Direct3D9.Device"/>, and are usable only with the <see cref="SharpDX.Direct3D9.Device"/> object from which they are created.</p><p>When set to a nonzero value, which must be a valid FVF code, the FVF parameter indicates that the buffer content is to be characterized by an FVF code. A vertex buffer that is created with an FVF code is referred to as an FVF vertex buffer. For more information, see FVF Vertex Buffers (Direct3D 9). </p><p>Non-FVF buffers can be used to interleave data during multipass rendering or multitexture rendering in a single pass. To do this, one buffer contains geometry data and the others contain texture coordinates for each texture to be rendered. When rendering, the buffer containing the geometry data is interleaved with each of the buffers containing the texture coordinates. If FVF buffers were used instead, each of them would need to contain identical geometry data in addition to the texture coordinate data specific to each texture rendered. This would result in either a speed or memory penalty, depending on the strategy used. For more information about texture coordinates, see Texture Coordinates (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateVertexBuffer']/*"/>	
        /// <msdn-id>bb174364</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVertexBuffer([In] unsigned int Length,[In] D3DUSAGE Usage,[In] D3DFVF FVF,[In] D3DPOOL Pool,[Out, Fast] IDirect3DVertexBuffer9** ppVertexBuffer,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateVertexBuffer</unmanaged-short>	
        internal void CreateVertexBuffer(int length, SharpDX.Direct3D9.Usage usage, SharpDX.Direct3D9.VertexFormat vertexFormat, SharpDX.Direct3D9.Pool pool, SharpDX.Direct3D9.VertexBuffer vertexBufferOut, System.IntPtr sharedHandleRef) {
            unsafe {
                IntPtr vertexBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, length, unchecked((int)usage), unchecked((int)vertexFormat), unchecked((int)pool), &vertexBufferOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[26]);		
                ((SharpDX.Direct3D9.VertexBuffer)vertexBufferOut).NativePointer = vertexBufferOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates an index buffer.</p>	
        /// </summary>	
        /// <param name="length"><dd>  <p>Size of the index buffer, in bytes. </p> </dd></param>	
        /// <param name="usage"><dd>  <p>Usage can be 0, which indicates no usage value. However, if usage is desired, use a combination of one or more <strong><see cref="SharpDX.Direct3D9.Usage"/></strong> constants. It is good practice to match the usage parameter in CreateIndexBuffer with the behavior flags in <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong>. For more information, see Remarks. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of the index buffer. For more information, see Remarks. The valid settings are the following: </p> <p></p> <table> <tr><th>Item</th><th>Description</th></tr> <tr><td> <p><see cref="SharpDX.Direct3D9.Format.Index16"/></p> </td><td> <p>Indices are 16 bits each.</p> </td></tr> <tr><td> <p><see cref="SharpDX.Direct3D9.Format.Index32"/></p> </td><td> <p>Indices are 32 bits each.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing a valid memory class into which to place the resource. </p> </dd></param>	
        /// <param name="indexBufferOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface, representing the created index buffer resource. </p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>This parameter can be used in Direct3D?9 for Windows?Vista to share resources; set it to <strong><c>null</c></strong> to not share a resource. This parameter is not used in Direct3D?9 for operating systems earlier than Windows?Vista; set it to <strong><c>null</c></strong>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY. </p></returns>	
        /// <remarks>	
        /// <p>Index buffers are memory resources used to hold indices, they are similar to both surfaces and vertex buffers. The use of index buffers enables Direct3D to avoid unnecessary data copying and to place the buffer in the optimal memory type for the expected usage.</p><p>To use index buffers, create an index buffer, lock it, fill it with indices, unlock it, pass it to <strong><see cref="SharpDX.Direct3D9.Device.SetIndices"/></strong>, set up the vertices, set up the vertex shader, and call <strong><see cref="SharpDX.Direct3D9.Device.DrawIndexedPrimitive"/></strong> for rendering.</p><p>The MaxVertexIndex member of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure indicates the types of index buffers that are valid for rendering.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateIndexBuffer']/*"/>	
        /// <msdn-id>bb174357</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateIndexBuffer([In] unsigned int Length,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[Out, Fast] IDirect3DIndexBuffer9** ppIndexBuffer,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateIndexBuffer</unmanaged-short>	
        internal void CreateIndexBuffer(int length, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, SharpDX.Direct3D9.IndexBuffer indexBufferOut, System.IntPtr sharedHandleRef) {
            unsafe {
                IntPtr indexBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, length, usage, unchecked((int)format), unchecked((int)pool), &indexBufferOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[27]);		
                ((SharpDX.Direct3D9.IndexBuffer)indexBufferOut).NativePointer = indexBufferOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a render-target surface.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the render-target surface, in pixels. </p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the render-target surface, in pixels. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of the render target. </p> </dd></param>	
        /// <param name="multiSample"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.MultisampleType"/></strong> enumerated type, which describes the multisampling buffer type. This parameter specifies the antialiasing type for this render target. When this surface is passed to <strong><see cref="SharpDX.Direct3D9.Device.SetRenderTarget"/></strong>, its multisample type must be the same as that of the depth-stencil set by <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong>. </p> </dd></param>	
        /// <param name="multisampleQuality"><dd>  <p>Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceMultiSampleType_"/></strong>. Passing a larger value returns the error, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the multisample type must all match.</p> </dd></param>	
        /// <param name="lockable"><dd>  <p>Render targets are not lockable unless the application specifies <strong>TRUE</strong> for Lockable.</p> <p>Note that lockable render targets reduce performance on some graphics hardware. The readback performance (moving data from video memory to system memory) depends on the type of hardware used (AGP vs. PCI Express) and is usually far lower than upload performance (moving data from system to video memory). If you need read access to render targets, use <strong>GetRenderTargetData</strong> instead of lockable render targets.</p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Render-target surfaces are placed in the <see cref="SharpDX.Direct3D9.Pool.Default"/> memory class.</p><p>The creation of lockable, multisampled render targets is not supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateRenderTarget']/*"/>	
        /// <msdn-id>bb174361</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateRenderTarget([In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] D3DMULTISAMPLE_TYPE MultiSample,[In] unsigned int MultisampleQuality,[In] BOOL Lockable,[Out] IDirect3DSurface9** ppSurface,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateRenderTarget</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface CreateRenderTarget(int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.MultisampleType multiSample, int multisampleQuality, SharpDX.Mathematics.Interop.RawBool lockable, System.IntPtr sharedHandleRef) {
            unsafe {
                SharpDX.Direct3D9.Surface surfaceOut;
                IntPtr surfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint24(_nativePointer, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, lockable, &surfaceOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[28]);		
                surfaceOut= (surfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceOut_);	
                __result__.CheckError();
                return surfaceOut;
            }
        }
        
        /// <summary>	
        /// <p>Creates a depth-stencil resource.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the depth-stencil surface, in pixels. </p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the depth-stencil surface, in pixels. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of the depth-stencil surface. This value must be one of the enumerated depth-stencil formats for this device.</p> </dd></param>	
        /// <param name="multiSample"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.MultisampleType"/></strong> enumerated type, describing the multisampling buffer type. This value must be one of the allowed multisample types. When this surface is passed to <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong>, its multisample type must be the same as that of the render target set by <strong><see cref="SharpDX.Direct3D9.Device.SetRenderTarget"/></strong>.</p> </dd></param>	
        /// <param name="multisampleQuality"><dd>  <p>Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceMultiSampleType_"/></strong>. Passing a larger value returns the error <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the MultiSample type must all match.</p> </dd></param>	
        /// <param name="discard"><dd>  <p>Set this flag to <strong>TRUE</strong> to enable z-buffer discarding, and <strong><see cref="SharpDX.Result.False"/></strong> otherwise.				If this flag is set, the contents of the depth stencil buffer will be invalid after calling either <strong><see cref="SharpDX.Direct3D9.Device.Present"/></strong> or <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong> with a different depth surface.</p> <p>This flag has the same behavior as the constant,  <see cref="SharpDX.Direct3D9.PresentFlags.DiscardDepthStencil"/>, in <see cref="SharpDX.Direct3D9.PresentFlags"/>.</p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the created depth-stencil surface resource. </p> </dd></returns>	
        /// <remarks>	
        /// <p>The memory class of the depth-stencil buffer is always <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateDepthStencilSurface']/*"/>	
        /// <msdn-id>bb174356</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateDepthStencilSurface([In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] D3DMULTISAMPLE_TYPE MultiSample,[In] unsigned int MultisampleQuality,[In] BOOL Discard,[Out] IDirect3DSurface9** ppSurface,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateDepthStencilSurface</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface CreateDepthStencilSurface(int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.MultisampleType multiSample, int multisampleQuality, SharpDX.Mathematics.Interop.RawBool discard, System.IntPtr sharedHandleRef) {
            unsafe {
                SharpDX.Direct3D9.Surface surfaceOut;
                IntPtr surfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint24(_nativePointer, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, discard, &surfaceOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[29]);		
                surfaceOut= (surfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceOut_);	
                __result__.CheckError();
                return surfaceOut;
            }
        }
        
        /// <summary>	
        /// <p>Copies rectangular subsets of pixels from one surface to another. </p>	
        /// </summary>	
        /// <param name="sourceSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the source surface. This parameter must point to a different surface than pDestinationSurface. </p> </dd></param>	
        /// <param name="sourceRectRef"><dd>  <p>Pointer to a rectangle on the source surface. Specifying <strong><c>null</c></strong> for this parameter causes the entire surface to be copied. </p> </dd></param>	
        /// <param name="destinationSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the destination surface.</p> </dd></param>	
        /// <param name="destPointRef"><dd>  <p>Pointer to the upper left corner of the destination rectangle. Specifying <strong><c>null</c></strong> for this parameter causes the entire surface to be copied. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is similar to CopyRects in DirectX 8.</p><p>This function has the following restrictions.</p><ul> <li>The source surface must have been created with <see cref="SharpDX.Direct3D9.Pool.SystemMemory"/>.</li> <li>The destination surface must have been created with <see cref="SharpDX.Direct3D9.Pool.Default"/>.</li> <li>Neither surface can be locked or holding an outstanding device context.</li> <li>Neither surface can be created with multisampling. The only valid flag for both surfaces is <see cref="SharpDX.Direct3D9.MultisampleType.None"/>.</li> <li>The surface format cannot be a depth stencil format.</li> <li>The source and dest rects must fit within the surface.</li> <li>No stretching or shrinking is allowed (the rects must be the same size).</li> <li>The source format must match the dest format.</li> </ul><p>The following table shows the supported combinations.</p><table> <tr><th></th><th></th><th>Dest formats</th><th></th><th></th><th></th></tr> <tr><th></th><td></td><td>Texture</td><td>RT texture</td><td>RT</td><td>Off-screen plain</td></tr> <tr><th>Src formats</th><td>Texture</td><td>Yes</td><td>Yes</td><td>Yes*</td><td>Yes</td></tr> <tr><th></th><td>RT texture</td><td>No</td><td>No</td><td>No</td><td>No</td></tr> <tr><th></th><td>RT</td><td>No</td><td>No</td><td>No</td><td>No</td></tr> <tr><th></th><td>Off-screen plain</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr> </table><p>?</p><p>* If the driver does not support the requested copy, it will be emulated using lock and copy.</p><p>If the application needs to copy data from a <see cref="SharpDX.Direct3D9.Pool.Default"/> render target to a <see cref="SharpDX.Direct3D9.Pool.SystemMemory"/> surface, it can use <strong>GetRenderTargetData</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::UpdateSurface']/*"/>	
        /// <msdn-id>bb205857</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::UpdateSurface([In] IDirect3DSurface9* pSourceSurface,[In, Optional] const RECT* pSourceRect,[In] IDirect3DSurface9* pDestinationSurface,[In, Optional] const POINT* pDestPoint)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::UpdateSurface</unmanaged-short>	
        public void UpdateSurface(SharpDX.Direct3D9.Surface sourceSurfaceRef, SharpDX.Mathematics.Interop.RawRectangle? sourceRectRef, SharpDX.Direct3D9.Surface destinationSurfaceRef, SharpDX.Mathematics.Interop.RawPoint? destPointRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawRectangle sourceRectRef_;
                if (sourceRectRef.HasValue)
                    sourceRectRef_ = sourceRectRef.Value;				
                SharpDX.Mathematics.Interop.RawPoint destPointRef_;
                if (destPointRef.HasValue)
                    destPointRef_ = destPointRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((sourceSurfaceRef == null)?IntPtr.Zero:sourceSurfaceRef.NativePointer), (sourceRectRef.HasValue)?&sourceRectRef_:(void*)IntPtr.Zero, (void*)((destinationSurfaceRef == null)?IntPtr.Zero:destinationSurfaceRef.NativePointer), (destPointRef.HasValue)?&destPointRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Updates the dirty portions of a texture.</p>	
        /// </summary>	
        /// <param name="sourceTextureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface, representing the source texture. The source texture must be in system memory (<see cref="SharpDX.Direct3D9.Pool.SystemMemory"/>). </p> </dd></param>	
        /// <param name="destinationTextureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface, representing the destination texture. The destination texture must be in the <see cref="SharpDX.Direct3D9.Pool.Default"/> memory pool. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>You can dirty a portion of a texture by locking it, or by calling one of the following methods. </p><ul> <li> <strong><see cref="SharpDX.Direct3D9.CubeTexture.AddDirtyRectangle"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Texture.AddDirtyRectangle"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.VolumeTexture.AddDirtyBox"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.UpdateSurface"/></strong> </li> </ul><p><strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong> retrieves the dirty portions of the texture by calculating what has been accumulated since the last update operation.</p><p>For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when LockRect or <strong><see cref="SharpDX.Direct3D9.VolumeTexture.LockBox"/></strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. Also, the destination surface of <strong><see cref="SharpDX.Direct3D9.Device.UpdateSurface"/></strong> is marked dirty.</p><p>This method fails if the textures are of different types, if their bottom-level buffers are of different sizes, or if their matching levels do not match. For example, consider a six-level source texture with the following dimensions. </p><pre> 32x16, 16x8, 8x4, 4x2, 2x1, 1x1	
        /// </pre><p>This six-level source texture could be the source for the following one-level destination. </p><pre> 1x1	
        /// </pre><p>For the following two-level destination. </p><pre> 2x1, 1x1	
        /// </pre><p>Or, for the following three-level destination. </p><pre> 4x2, 2x1, 1x1	
        /// </pre><p>In addition, this method will fail if the textures are of different formats. If the destination texture has fewer levels than the source, only the matching levels are copied. If the source texture has fewer levels than the destination, the method will fail. </p><p>If the source texture has dirty regions, the copy can be optimized by restricting the copy to only those regions. It is not guaranteed that only those bytes marked dirty will be copied.</p><p>Here are the possibilities for source and destination surface combinations:</p><ul> <li>If pSourceTexture is a non-autogenerated mipmap and pDestinationTexture is an autogenerated mipmap, only the topmost matching level is updated, and the destination sublevels are regenerated. All other source sublevels are ignored.</li> <li>If both pSourceTexture and pDestinationTexture are autogenerated mipmaps, only the topmost matching level is updated. The sublevels from the source are ignored and the destination sublevels are regenerated.</li> <li>If pSourceTexture is an autogenerated mipmap and pDestinationTexture a non-autogenerated mipmap, UpdateTexture will fail.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::UpdateTexture']/*"/>	
        /// <msdn-id>bb205858</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::UpdateTexture([In] IDirect3DBaseTexture9* pSourceTexture,[In] IDirect3DBaseTexture9* pDestinationTexture)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::UpdateTexture</unmanaged-short>	
        public void UpdateTexture(SharpDX.Direct3D9.BaseTexture sourceTextureRef, SharpDX.Direct3D9.BaseTexture destinationTextureRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((sourceTextureRef == null)?IntPtr.Zero:sourceTextureRef.NativePointer), (void*)((destinationTextureRef == null)?IntPtr.Zero:destinationTextureRef.NativePointer),((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Copies the render-target data from device memory to system memory.</p>	
        /// </summary>	
        /// <param name="renderTargetRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> object, representing a render target. </p> </dd></param>	
        /// <param name="destSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> object, representing a destination surface. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The destination surface must be either an off-screen plain surface or a level of a texture (mipmap or cube texture) created with <see cref="SharpDX.Direct3D9.Pool.SystemMemory"/>.</p><p>The source surface must be a regular render target or a level of a render-target texture (mipmap or cube texture) created with POOL_DEFAULT.</p><p>This method will fail if:</p><ul> <li>The render target is multisampled.</li> <li>The source render target is a different size than the destination surface.</li> <li>The source render target and destination surface formats do not match.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetRenderTargetData']/*"/>	
        /// <msdn-id>bb174405</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRenderTargetData([In] IDirect3DSurface9* pRenderTarget,[In] IDirect3DSurface9* pDestSurface)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetRenderTargetData</unmanaged-short>	
        public void GetRenderTargetData(SharpDX.Direct3D9.Surface renderTargetRef, SharpDX.Direct3D9.Surface destSurfaceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((renderTargetRef == null)?IntPtr.Zero:renderTargetRef.NativePointer), (void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer),((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generates a copy of the device's front buffer and places that copy in a system memory buffer provided by the application. </p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>An unsigned integer specifying the swap chain.</p> </dd></param>	
        /// <param name="destSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface that will receive a copy of the contents of the front buffer. The data is returned in successive rows with no intervening space, starting from the vertically highest row on the device's output to the lowest.</p> <p></p> <p>For windowed mode, the size of the destination surface should be the size of the desktop. For full-screen mode, the size of the destination surface should be the screen size. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p>The buffer pointed to by pDestSurface will be filled with a representation of the front buffer, converted to the standard 32 bits per pixel format <see cref="SharpDX.Direct3D9.Format.A8R8G8B8"/>. </p><p>This method is the only way to capture an antialiased screen shot.</p><p>This function is very slow, by design, and should not be used in any performance-critical path.</p><p>For more information, see Lost Devices and Retrieved Data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetFrontBufferData']/*"/>	
        /// <msdn-id>bb174388</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetFrontBufferData([In] unsigned int iSwapChain,[In] IDirect3DSurface9* pDestSurface)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetFrontBufferData</unmanaged-short>	
        public void GetFrontBufferData(int iSwapChain, SharpDX.Direct3D9.Surface destSurfaceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iSwapChain, (void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer),((void**)(*(void**)_nativePointer))[33]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Copy the contents of the source rectangle to the destination rectangle. The source rectangle can be stretched and filtered by the copy. This function is often used to change the aspect ratio of a video stream.</p>	
        /// </summary>	
        /// <param name="sourceSurfaceRef"><dd>  <p>Pointer to the source surface. See <strong><see cref="SharpDX.Direct3D9.Surface"/></strong>.</p> </dd></param>	
        /// <param name="sourceRectRef"><dd>  <p>Pointer to the source rectangle. A <strong><c>null</c></strong> for this parameter causes the entire source surface to be used.</p> </dd></param>	
        /// <param name="destSurfaceRef"><dd>  <p>Pointer to the destination surface. See <strong><see cref="SharpDX.Direct3D9.Surface"/></strong>.</p> </dd></param>	
        /// <param name="destRectRef"><dd>  <p>Pointer to the destination rectangle. A <strong><c>null</c></strong> for this parameter causes the entire destination surface to be used.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>Filter type. Allowable values are <see cref="SharpDX.Direct3D9.TextureFilter.None"/>, <see cref="SharpDX.Direct3D9.TextureFilter.Point"/>, or <see cref="SharpDX.Direct3D9.TextureFilter.Linear"/>. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>StretchRect Restrictions</p><ul> <li>Driver support varies. See the section on driver support (below) to see which drivers support which source and destination formats.</li> <li>The source and destination surfaces must be created in the default memory pool.</li> <li>If filtering is specified, you must set the appropriate filter caps (see StretchRectFilterCaps in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>).</li> <li>Stretching is not supported between source and destination rectangles on the same surface.</li> <li>Stretching is not supported if the destination surface is an off-screen plain surface but the source is not.</li> <li>You many not stretch between source and destination rectangles if either surface is in a compressed format (see Using Compressed Textures (Direct3D 9)).</li> <li>Stretching supports color-space conversion from YUV to high-precision RGBA only. Since color conversion support is not supported by software emulation, use <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceFormatConversion_"/></strong> to test the hardware for color conversion support.</li> <li>If the source or destination surface is a texture surface (or a cube texture surface), you must use a Direct3D 9 driver that supports <see cref="SharpDX.Direct3D9.DeviceCaps2.CanStretchRectFromTextures"/> (see <see cref="SharpDX.Direct3D9.DeviceCaps2"/>).</li> </ul><p>Additional Restrictions for Depth and Stencil Surfaces</p><ul> <li>The source and destination surfaces must be plain depth stencil surfaces (not textures) (see <strong><see cref="SharpDX.Direct3D9.Device.CreateDepthStencilSurface"/></strong>).</li> <li>Neither of the surfaces can be discardable.</li> <li>The entire surface must be copied (that is: sub-rectangle copies are not allowed).</li> <li>Format conversion, stretching, and shrinking are not supported.</li> <li>StretchRect cannot be called inside of a BeginScene/EndScene pair.</li> </ul><p>Using StretchRect to downsample a Multisample Rendertarget</p><p>You can use StretchRect to copy from one rendertarget to another. If the source rendertarget is multisampled, this results in downsampling the source rendertarget. For instance you could:</p><ul> <li>Create a multisampled rendertarget.</li> <li>Create a second rendertarget of the same size, that is not multisampled.</li> <li>Copy (using StretchRect the multisample rendertarget to the second rendertarget.</li> </ul><p>Note that use of the extra surface involved in using StretchRect to downsample a Multisample Rendertarget will result in a performance hit.</p><p>Driver Support</p><p>There are many restrictions as to which surface combinations are valid for StretchRect. Factors include whether the driver is a Direct3D 9 driver or older, and whether the operation will result in stretching/shrinking.  Since applications are not expected to recognize if the driver is a Direct3D 9 driver or not, the runtime will automatically set a new cap, <see cref="SharpDX.Direct3D9.DeviceCaps2.CanStretchRectFromTextures"/> cap (see <see cref="SharpDX.Direct3D9.DeviceCaps2"/>), for Direct3D 9-level drivers and above.</p><table> <tr><th>DirectX 8 Driver (no stretching)</th><th></th><th></th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Dest formats</th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Texture</th><th>RT texture</th><th>RT</th><th>Off-screen plain</th></tr> <tr><th>Src formats</th><th>Texture</th><td>No</td><td>No</td><td>No</td><td>No</td></tr> <tr><th></th><th>RT texture</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>RT</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>Off-screen plain</th><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr> </table><p>?</p><table> <tr><th>DirectX 8 Driver (stretching)</th><th></th><th></th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Dest formats</th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Texture</th><th>RT texture</th><th>RT</th><th>Off-screen plain</th></tr> <tr><th>Src formats</th><th>Texture</th><td>No</td><td>No</td><td>No</td><td>No</td></tr> <tr><th></th><th>RT texture</th><td>No</td><td>No</td><td>No</td><td>No</td></tr> <tr><th></th><th>RT</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>Off-screen plain</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> </table><p>?</p><table> <tr><th>Direct3D 9 Driver (no stretching)</th><th></th><th></th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Dest formats</th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Texture</th><th>RT texture</th><th>RT</th><th>Off-screen plain</th></tr> <tr><th>Src formats</th><th>Texture</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>RT texture</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>RT</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>Off-screen plain</th><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td></tr> </table><p>?</p><table> <tr><th>Direct3D 9 Driver (stretching)</th><th></th><th></th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Dest formats</th><th></th><th></th><th></th></tr> <tr><th></th><th></th><th>Texture</th><th>RT texture</th><th>RT</th><th>Off-screen plain</th></tr> <tr><th>Src formats</th><th>Texture</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>RT texture</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>RT</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> <tr><th></th><th>Off-screen plain</th><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::StretchRect']/*"/>	
        /// <msdn-id>bb174471</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::StretchRect([In] IDirect3DSurface9* pSourceSurface,[In, Optional] const RECT* pSourceRect,[In] IDirect3DSurface9* pDestSurface,[In, Optional] const RECT* pDestRect,[In] D3DTEXTUREFILTERTYPE Filter)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::StretchRect</unmanaged-short>	
        public void StretchRectangle(SharpDX.Direct3D9.Surface sourceSurfaceRef, SharpDX.Mathematics.Interop.RawRectangle? sourceRectRef, SharpDX.Direct3D9.Surface destSurfaceRef, SharpDX.Mathematics.Interop.RawRectangle? destRectRef, SharpDX.Direct3D9.TextureFilter filter) {
            unsafe {
                SharpDX.Mathematics.Interop.RawRectangle sourceRectRef_;
                if (sourceRectRef.HasValue)
                    sourceRectRef_ = sourceRectRef.Value;				
                SharpDX.Mathematics.Interop.RawRectangle destRectRef_;
                if (destRectRef.HasValue)
                    destRectRef_ = destRectRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((sourceSurfaceRef == null)?IntPtr.Zero:sourceSurfaceRef.NativePointer), (sourceRectRef.HasValue)?&sourceRectRef_:(void*)IntPtr.Zero, (void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer), (destRectRef.HasValue)?&destRectRef_:(void*)IntPtr.Zero, unchecked((int)filter),((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Allows an application to fill a rectangular area of a <see cref="SharpDX.Direct3D9.Pool.Default"/> surface with a specified color.</p>	
        /// </summary>	
        /// <param name="surfaceRef"><dd>  <p>Pointer to the surface to be filled.</p> </dd></param>	
        /// <param name="rectRef"><dd>  <p>Pointer to the source rectangle. Using <strong><c>null</c></strong> means that the entire surface will be filled.</p> </dd></param>	
        /// <param name="color"><dd>  <p>Color used for filling.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method can only be applied to a render target, a render-target texture surface, or an off-screen plain surface with a pool type of <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p><strong><see cref="SharpDX.Direct3D9.Device.ColorFill"/></strong> will work with all formats. However, when using a reference or software device, the only formats supported are <see cref="SharpDX.Direct3D9.Format.X1R5G5B5"/>, <see cref="SharpDX.Direct3D9.Format.A1R5G5B5"/>, <see cref="SharpDX.Direct3D9.Format.R5G6B5"/>, <see cref="SharpDX.Direct3D9.Format.X8R8G8B8"/>, <see cref="SharpDX.Direct3D9.Format.A8R8G8B8"/>, <see cref="SharpDX.Direct3D9.Format.Yuy2"/>, <see cref="SharpDX.Direct3D9.Format.G8R8_G8B8"/>, <see cref="SharpDX.Direct3D9.Format.Uyvy"/>, <see cref="SharpDX.Direct3D9.Format.R8G8_B8G8"/>, <see cref="SharpDX.Direct3D9.Format.R16F"/>, <see cref="SharpDX.Direct3D9.Format.G16R16F"/>, <see cref="SharpDX.Direct3D9.Format.A16B16G16R16F"/>, <see cref="SharpDX.Direct3D9.Format.R32F"/>, <see cref="SharpDX.Direct3D9.Format.G32R32F"/>, and <see cref="SharpDX.Direct3D9.Format.A32B32G32R32F"/>.</p><p>When using a DirectX 7 or DirectX 8.x driver, the only YUV formats supported are <see cref="SharpDX.Direct3D9.Format.Uyvy"/> and <see cref="SharpDX.Direct3D9.Format.Yuy2"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::ColorFill']/*"/>	
        /// <msdn-id>bb174353</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::ColorFill([In] IDirect3DSurface9* pSurface,[In, Optional] const RECT* pRect,[In] D3DCOLOR color)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::ColorFill</unmanaged-short>	
        public void ColorFill(SharpDX.Direct3D9.Surface surfaceRef, SharpDX.Mathematics.Interop.RawRectangle? rectRef, SharpDX.Mathematics.Interop.RawColorBGRA color) {
            unsafe {
                SharpDX.Mathematics.Interop.RawRectangle rectRef_;
                if (rectRef.HasValue)
                    rectRef_ = rectRef.Value;				
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint26(_nativePointer, (void*)((surfaceRef == null)?IntPtr.Zero:surfaceRef.NativePointer), (rectRef.HasValue)?&rectRef_:(void*)IntPtr.Zero, color,((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create an off-screen surface.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the surface.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the surface.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Format of the surface. See <see cref="SharpDX.Direct3D9.Format"/>. </p> </dd></param>	
        /// <param name="pool"><dd>  <p>Surface pool type. See <strong><see cref="SharpDX.Direct3D9.Pool"/></strong>.</p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface created.</p> </dd></returns>	
        /// <remarks>	
        /// <p><see cref="SharpDX.Direct3D9.Pool.Scratch"/> will return a surface that has identical characteristics to a surface created by the DirectX 8.x method CreateImageSurface.</p><p><see cref="SharpDX.Direct3D9.Pool.Default"/> is the appropriate pool for use with the <strong><see cref="SharpDX.Direct3D9.Device.StretchRectangle"/></strong> and <strong><see cref="SharpDX.Direct3D9.Device.ColorFill"/></strong>.</p><p><see cref="SharpDX.Direct3D9.Pool.Managed"/> is not allowed when creating an offscreen plain surface. For more information about memory pools, see <strong><see cref="SharpDX.Direct3D9.Pool"/></strong>.</p><p>Off-screen plain surfaces are always lockable, regardless of their pool types.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateOffscreenPlainSurface']/*"/>	
        /// <msdn-id>bb174358</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateOffscreenPlainSurface([In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[Out] IDirect3DSurface9** ppSurface,[In] void** pSharedHandle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateOffscreenPlainSurface</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface CreateOffscreenPlainSurface(int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, System.IntPtr sharedHandleRef) {
            unsafe {
                SharpDX.Direct3D9.Surface surfaceOut;
                IntPtr surfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, width, height, unchecked((int)format), unchecked((int)pool), &surfaceOut_, (void*)sharedHandleRef,((void**)(*(void**)_nativePointer))[36]);		
                surfaceOut= (surfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceOut_);	
                __result__.CheckError();
                return surfaceOut;
            }
        }
        
        /// <summary>	
        /// <p>Sets a new color buffer for the device.</p>	
        /// </summary>	
        /// <param name="renderTargetIndex"><dd>  <p>Index of the render target. See Remarks.</p> </dd></param>	
        /// <param name="renderTargetRef"><dd>  <p>Pointer to a new color buffer. If <strong><c>null</c></strong>, the color buffer for the corresponding RenderTargetIndex is disabled. Devices always must be associated with a color buffer. The new render-target surface must have at least <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> specified.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. This method will return <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> if either:</p><ul> <li>pRenderTarget = <strong><c>null</c></strong> and RenderTargetIndex = 0</li> <li>pRenderTarget is != <strong><c>null</c></strong> and the render target is invalid.</li> </ul></returns>	
        /// <remarks>	
        /// <p>The device can support multiple render targets. The number of render targets supported by a device is contained in the NumSimultaneousRTs member of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>. See Multiple Render Targets (Direct3D 9).</p><p>Setting a new render target will cause the viewport (see Viewports and Clipping (Direct3D 9)) to be set to the full size of the new render target.</p><p>Some hardware tests the compatibility of the depth stencil buffer with the color buffer. If this is done, it is only done in a debug build.</p><p>Restrictions for using this method include the following:</p><ul> <li>The multisample type must be the same for the render target and the depth stencil surface.</li> <li>The formats must be compatible for the render target and the depth stencil surface. See <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDepthStencilMatch_"/></strong>.</li> <li>The size of the depth stencil surface must be greater than or equal to the size of the render target.</li> </ul><p>These restrictions are validated only when using the debug runtime when any of the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> Draw methods are called.</p><p>Cube textures differ from other surfaces in that they are collections of surfaces. To call <strong><see cref="SharpDX.Direct3D9.Device.SetRenderTarget"/></strong> with a cube texture, you must select an individual face using <strong><see cref="SharpDX.Direct3D9.CubeTexture.GetCubeMapSurface"/></strong> and pass the resulting surface to <strong><see cref="SharpDX.Direct3D9.Device.SetRenderTarget"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetRenderTarget']/*"/>	
        /// <msdn-id>bb174455</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetRenderTarget([In] unsigned int RenderTargetIndex,[In] IDirect3DSurface9* pRenderTarget)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetRenderTarget</unmanaged-short>	
        public void SetRenderTarget(int renderTargetIndex, SharpDX.Direct3D9.Surface renderTargetRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, renderTargetIndex, (void*)((renderTargetRef == null)?IntPtr.Zero:renderTargetRef.NativePointer),((void**)(*(void**)_nativePointer))[37]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a render-target surface.</p>	
        /// </summary>	
        /// <param name="renderTargetIndex"><dd>  <p>Index of the render target. See Remarks.</p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the returned render-target surface for this device. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Typically, methods that return state will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. This method however, will work even on a pure device because it returns an interface.</p><p>The device can now support multiple render targets. The number of render targets supported by a device is contained in the NumSimultaneousRTs member of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>. See Multiple Render Targets (Direct3D 9).</p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetRenderTarget']/*"/>	
        /// <msdn-id>bb174404</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRenderTarget([In] unsigned int RenderTargetIndex,[Out] IDirect3DSurface9** ppRenderTarget)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetRenderTarget</unmanaged-short>	
        public SharpDX.Direct3D9.Surface GetRenderTarget(int renderTargetIndex) {
            unsafe {
                SharpDX.Direct3D9.Surface renderTargetOut;
                IntPtr renderTargetOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, renderTargetIndex, &renderTargetOut_,((void**)(*(void**)_nativePointer))[38]);		
                renderTargetOut= (renderTargetOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(renderTargetOut_);	
                __result__.CheckError();
                return renderTargetOut;
            }
        }
        
        /// <summary>	
        /// <p>Sets the depth stencil surface.</p>	
        /// </summary>	
        /// <param name="newZStencilRef"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface representing the depth stencil surface. Setting this to <strong><c>null</c></strong> disables the depth stencil operation.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If pZStencilSurface is other than <strong><c>null</c></strong>, the return value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> when the stencil surface is invalid. </p></returns>	
        /// <remarks>	
        /// <p>Restrictions for using this method include the following:</p><ul> <li>The multisample type must be the same for the render target and the depth stencil surface.</li> <li>The formats must be compatible for the render target and the depth stencil surface. See <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDepthStencilMatch_"/></strong>.</li> <li>The size of the depth stencil surface must be greater than or equal to the size of the render target.</li> </ul><p>These restrictions are validated only when using the debug runtime when any of the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> Draw methods are called.</p><p>Cube textures differ from other surfaces in that they are collections of surfaces. To call <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong> with a cube texture, you must select an individual face using <strong><see cref="SharpDX.Direct3D9.CubeTexture.GetCubeMapSurface"/></strong> and pass the resulting surface to <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetDepthStencilSurface']/*"/>	
        /// <msdn-id>bb174431</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetDepthStencilSurface([In] IDirect3DSurface9* pNewZStencil)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetDepthStencilSurface</unmanaged-short>	
        internal void SetDepthStencilSurface(SharpDX.Direct3D9.Surface newZStencilRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((newZStencilRef == null)?IntPtr.Zero:newZStencilRef.NativePointer),((void**)(*(void**)_nativePointer))[39]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the depth-stencil surface owned by the Direct3DDevice object.</p>	
        /// </summary>	
        /// <param name="zStencilSurfaceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the returned depth-stencil surface. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.If the device doesn't have a depth stencil buffer associated with it, the return value will be <see cref="SharpDX.Direct3D9.ResultCode.NotFound"/>. Otherwise, if the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetDepthStencilSurface']/*"/>	
        /// <msdn-id>bb174384</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetDepthStencilSurface([Out] IDirect3DSurface9** ppZStencilSurface)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetDepthStencilSurface</unmanaged-short>	
        internal void GetDepthStencilSurface(out SharpDX.Direct3D9.Surface zStencilSurfaceOut) {
            unsafe {
                IntPtr zStencilSurfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &zStencilSurfaceOut_,((void**)(*(void**)_nativePointer))[40]);		
                zStencilSurfaceOut= (zStencilSurfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(zStencilSurfaceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Begins a scene. </p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. The method will fail with <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> if <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> is called  while already in a <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong>/<strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> pair. This happens only  when <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> is called twice without first calling <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>Applications must call <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> before performing any rendering and must call <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> when rendering is complete and before calling <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> again.</p><p>If <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> fails, the device was unable to begin the scene, and there is no need to  call <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong>. In fact, calls to <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> will fail if the  previous <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> failed. This applies to any application that creates multiple swap chains.</p><p>There should be one <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong>/<strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> pair between any successive calls to  present (either <strong><see cref="SharpDX.Direct3D9.Device.Present"/></strong> or <strong><see cref="SharpDX.Direct3D9.SwapChain.Present"/></strong>). <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> should  be called once before any rendering is performed, and <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> should be called once after all rendering for a frame has been submitted to the runtime. Multiple non-nested <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong>/<strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> pairs between calls to present are legal, but having more than one pair may incur a performance hit. To enable maximal parallelism between the CPU and the graphics accelerator, it is advantageous to  call <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> as far ahead of calling present as possible.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::BeginScene']/*"/>	
        /// <msdn-id>bb174350</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::BeginScene()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::BeginScene</unmanaged-short>	
        public void BeginScene() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[41]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Ends a scene that was begun by calling <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. The method will fail with <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> if <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> is called while already in a <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong>/<strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> pair. This happens only when <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> is called twice without first calling <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>When this method succeeds, the scene has been queued up for rendering by the driver. This is not a synchronous method, so the scene is not guaranteed to have completed rendering when this method returns.</p><p>Applications must call <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> before performing any rendering and must call <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> when rendering is complete and before calling <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> again.</p><p>If <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> fails, the device was unable to begin the scene, and there is no need to call <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong>. In fact, calls to  <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> will fail if the previous <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> failed. This applies to any application that creates multiple swap chains.</p><p>There should be at most one <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong>/<strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> pair between any successive calls to present (either <strong><see cref="SharpDX.Direct3D9.Device.Present"/></strong> or <strong><see cref="SharpDX.Direct3D9.SwapChain.Present"/></strong>). <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> should be called once before any rendering is performed, and <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> should be called once after all rendering for a frame has been submitted to the runtime. To enable maximal parallelism between the CPU and the graphics accelerator, it is advantageous to call <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> as far ahead of calling present as possible.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::EndScene']/*"/>	
        /// <msdn-id>bb174375</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::EndScene()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::EndScene</unmanaged-short>	
        public void EndScene() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[42]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Clears one or more surfaces such as a render target, multiple render targets, a stencil buffer, and a depth buffer.</p>	
        /// </summary>	
        /// <param name="count">No documentation.</param>	
        /// <param name="rectsRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="color">No documentation.</param>	
        /// <param name="z">No documentation.</param>	
        /// <param name="stencil">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Use this method to clear a surface including: a render target, all render targets in an MRT, a stencil buffer, or a depth buffer. Flags determines how many surfaces are cleared. Use pRects to clear a subset of a surface defined by an array of rectangles.</p><p><strong><see cref="SharpDX.Direct3D9.Device.Clear_"/></strong> will fail if you:</p><ul> <li>Try to clear either the depth buffer or the stencil buffer of a render target that does not have an attached depth buffer.</li> <li>Try to clear the stencil buffer when the depth buffer does not contain stencil data.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::Clear']/*"/>	
        /// <msdn-id>bb174352</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::Clear([In] unsigned int Count,[In, Buffer, Optional] const D3DRECT* pRects,[In] D3DCLEAR Flags,[In] D3DCOLOR Color,[In] float Z,[In] unsigned int Stencil)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::Clear</unmanaged-short>	
        internal void Clear_(int count, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef, SharpDX.Direct3D9.ClearFlags flags, SharpDX.Mathematics.Interop.RawColorBGRA color, float z, int stencil) {
            unsafe {
                SharpDX.Mathematics.Interop.RawRectangle[] rectsRef__ = rectsRef;
                SharpDX.Result __result__;
                fixed (void* rectsRef_ = rectsRef__)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint27(_nativePointer, count, rectsRef_, unchecked((int)flags), color, z, stencil,((void**)(*(void**)_nativePointer))[43]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a single device transformation-related state.</p>	
        /// </summary>	
        /// <param name="state"><dd>  <p>Device-state variable that is being modified. This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.TransformState"/></strong> enumerated type, or the <strong>D3DTS_WORLDMATRIX</strong> macro. </p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> structure that modifies the current transformation. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if one of the arguments is invalid. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetTransform']/*"/>	
        /// <msdn-id>bb174463</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetTransform([In] int State,[In] const D3DMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetTransform</unmanaged-short>	
        internal void SetTransform_(int state, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, state, matrixRef_,((void**)(*(void**)_nativePointer))[44]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a matrix describing a transformation state.</p>	
        /// </summary>	
        /// <param name="state"><dd>  <p>Device state variable that is being modified. This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.TransformState"/></strong> enumerated type, or the <strong>D3DTS_WORLDMATRIX</strong> macro. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a  <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> structure, describing the returned transformation state. </p> </dd></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other flag values in <see cref="SharpDX.Direct3D9.CreateFlags"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetTransform']/*"/>	
        /// <msdn-id>bb174414</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetTransform([In] D3DTRANSFORMSTATETYPE State,[Out] D3DMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetTransform</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawMatrix GetTransform(SharpDX.Direct3D9.TransformState state) {
            unsafe {
                SharpDX.Mathematics.Interop.RawMatrix matrixRef;
                matrixRef = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)state), &matrixRef,((void**)(*(void**)_nativePointer))[45]);		
                __result__.CheckError();
                return matrixRef;
            }
        }
        
        /// <summary>	
        /// <p>Multiplies a device's world, view, or projection matrices by a specified matrix. </p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.TransformState"/></strong> enumerated type, or the <strong>D3DTS_WORLDMATRIX</strong> macro that identifies which device matrix is to be modified. The most common setting, <strong>D3DTS_WORLDMATRIX</strong>(0), modifies the world matrix, but you can specify that the method modify the view or projection matrices, if needed. </p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> structure that modifies the current transformation. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> if one of the arguments is invalid. </p></returns>	
        /// <remarks>	
        /// <p>The multiplication order is pMatrix times State.</p><p>An application might use the <strong><see cref="SharpDX.Direct3D9.Device.MultiplyTransform"/></strong> method to work with hierarchies of transformations. For example, the geometry and transformations describing an arm might be arranged in the following hierarchy.</p><pre> shoulder_transformation upper_arm geometry elbow transformation lower_arm geometry wrist transformation hand geometry	
        /// </pre><p>An application might use the following series of calls to render this hierarchy. Not all the parameters are shown in this pseudocode. </p><pre> <see cref="SharpDX.Direct3D9.Device.SetTransform_"/>(D3DTS_WORLDMATRIX(0),  shoulder_transform)	
        /// <see cref="SharpDX.Direct3D9.Device.DrawPrimitives"/>(upper_arm)	
        /// <see cref="SharpDX.Direct3D9.Device.MultiplyTransform"/>(D3DTS_WORLDMATRIX(0),  elbow_transform)	
        /// <see cref="SharpDX.Direct3D9.Device.DrawPrimitives"/>(lower_arm)	
        /// <see cref="SharpDX.Direct3D9.Device.MultiplyTransform"/>(D3DTS_WORLDMATRIX(0),  wrist_transform)	
        /// <see cref="SharpDX.Direct3D9.Device.DrawPrimitives"/>(hand)</pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::MultiplyTransform']/*"/>	
        /// <msdn-id>bb174422</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::MultiplyTransform([In] D3DTRANSFORMSTATETYPE arg0,[In] const D3DMATRIX* arg1)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::MultiplyTransform</unmanaged-short>	
        public void MultiplyTransform(SharpDX.Direct3D9.TransformState arg0, ref SharpDX.Mathematics.Interop.RawMatrix arg1) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)arg0), arg1_,((void**)(*(void**)_nativePointer))[46]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the viewport parameters for the device.</p>	
        /// </summary>	
        /// <param name="viewportRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawViewport"/></strong> structure, specifying the viewport parameters to set. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, it will return <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. This will happen if pViewport is invalid, or if pViewport describes a region that cannot exist within the render target surface.</p></returns>	
        /// <remarks>	
        /// <p>Direct3D sets the following default values for the viewport.</p><p></p><pre> <see cref="SharpDX.Mathematics.Interop.RawViewport"/> vp;	
        /// vp.X      = 0;	
        /// vp.Y      = 0;	
        /// vp.Width  = RenderTarget.Width;	
        /// vp.Height = RenderTarget.Height;	
        /// vp.MinZ   = 0.0f;	
        /// vp.MaxZ   = 1.0f;	
        /// </pre><p><strong><see cref="SharpDX.Direct3D9.Device.SetViewport"/></strong> can be used to draw on part of the screen. Make sure to call it before any geometry is drawn so the viewport settings will take effect.</p><p>To draw multiple views within a scene, repeat the <strong><see cref="SharpDX.Direct3D9.Device.SetViewport"/></strong> and draw geometry sequence for each view.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetViewport']/*"/>	
        /// <msdn-id>bb174469</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetViewport([In] const D3DVIEWPORT9* pViewport)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetViewport</unmanaged-short>	
        internal void SetViewport(SharpDX.Mathematics.Interop.RawViewport viewportRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &viewportRef,((void**)(*(void**)_nativePointer))[47]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the viewport parameters currently set for the device.</p>	
        /// </summary>	
        /// <param name="viewportRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawViewport"/></strong> structure, representing the returned viewport parameters. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the pViewport parameter is invalid. </p></returns>	
        /// <remarks>	
        /// <p>Typically, methods that return state will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. This method however, will work even on a pure device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetViewport']/*"/>	
        /// <msdn-id>bb174420</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetViewport([Out] D3DVIEWPORT9* pViewport)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetViewport</unmanaged-short>	
        internal void GetViewport(out SharpDX.Mathematics.Interop.RawViewport viewportRef) {
            unsafe {
                viewportRef = new SharpDX.Mathematics.Interop.RawViewport();
                SharpDX.Result __result__;
                fixed (void* viewportRef_ = &viewportRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, viewportRef_,((void**)(*(void**)_nativePointer))[48]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the material properties for the device.</p>	
        /// </summary>	
        /// <param name="materialRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure, describing the material properties to set. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> if the pMaterial parameter is invalid. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetMaterial']/*"/>	
        /// <msdn-id>bb174437</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetMaterial([In] const D3DMATERIAL9* pMaterial)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetMaterial</unmanaged-short>	
        internal void SetMaterial(ref SharpDX.Direct3D9.Material materialRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* materialRef_ = &materialRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, materialRef_,((void**)(*(void**)_nativePointer))[49]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the current material properties for the device.</p>	
        /// </summary>	
        /// <param name="materialRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure to fill with the currently set material properties. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> if the pMaterial parameter is invalid. </p></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other values in <see cref="SharpDX.Direct3D9.CreateFlags"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetMaterial']/*"/>	
        /// <msdn-id>bb174394</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetMaterial([Out] D3DMATERIAL9* pMaterial)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetMaterial</unmanaged-short>	
        internal void GetMaterial(out SharpDX.Direct3D9.Material materialRef) {
            unsafe {
                materialRef = new SharpDX.Direct3D9.Material();
                SharpDX.Result __result__;
                fixed (void* materialRef_ = &materialRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, materialRef_,((void**)(*(void**)_nativePointer))[50]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Assigns a set of lighting properties for this device.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the set of lighting properties to set. If a set of lighting properties exists at this index, it is overwritten by the new properties specified in pLight. </p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Light"/></strong> structure, containing the lighting parameters to set. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>Set light properties by preparing a <strong><see cref="SharpDX.Direct3D9.Light"/></strong> structure and then calling the <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong> method. The  <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong> method accepts the index at which the device should place the set of light properties to its internal list of light properties, and the address of a prepared <strong><see cref="SharpDX.Direct3D9.Light"/></strong> structure that defines those properties. You can call <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong> with new information as needed to update the light's illumination properties.</p><p>The system allocates memory to accommodate a set of lighting properties each time you call the <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong> method with an index that has never been assigned properties. Applications can set a number of lights, with only a subset of the assigned lights enabled at a time. Check the MaxActiveLights member of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure when you retrieve device capabilities to determine the maximum number of active lights supported by that device. If you no longer need a light, you can disable it or overwrite it with a new set of light properties.</p><p>The following example prepares and sets properties for a white point-light whose emitted light will not attenuate over distance.</p><pre> // Assume d3dDevice is a valid reference to an <see cref="SharpDX.Direct3D9.Device"/> interface.	
        /// <see cref="SharpDX.Direct3D9.Light"/> d3dLight;	
        /// <see cref="SharpDX.Result"/>   hr; // Initialize the structure.	
        /// ZeroMemory(&amp;d3dLight, sizeof(d3dLight)); // Set up a white point light.	
        /// d3dLight.Type = <see cref="SharpDX.Direct3D9.LightType.Point"/>;	
        /// d3dLight.Diffuse.r  = 1.0f;	
        /// d3dLight.Diffuse.g  = 1.0f;	
        /// d3dLight.Diffuse.b  = 1.0f;	
        /// d3dLight.Ambient.r  = 1.0f;	
        /// d3dLight.Ambient.g  = 1.0f;	
        /// d3dLight.Ambient.b  = 1.0f;	
        /// d3dLight.Specular.r = 1.0f;	
        /// d3dLight.Specular.g = 1.0f;	
        /// d3dLight.Specular.b = 1.0f; // Position it high in the scene and behind the user.	
        /// // Remember, these coordinates are in world space, so	
        /// // the user could be anywhere in world space, too. 	
        /// // For the purposes of this example, assume the user	
        /// // is at the origin of world space.	
        /// d3dLight.Position.x = 0.0f;	
        /// d3dLight.Position.y = 1000.0f;	
        /// d3dLight.Position.z = -100.0f; // Don't attenuate.	
        /// d3dLight.Attenuation0 = 1.0f; 	
        /// d3dLight.Range        = 1000.0f; // Set the property information for the first light.	
        /// hr = d3dDevice-&gt;SetLight(0, &amp;d3dLight);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure	
        /// </pre><p>Enable a light source by calling the <strong><see cref="SharpDX.Direct3D9.Device.EnableLight"/></strong> method for the device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetLight']/*"/>	
        /// <msdn-id>bb174436</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetLight([In] unsigned int Index,[In] const D3DLIGHT9* arg1)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetLight</unmanaged-short>	
        public void SetLight(int index, ref SharpDX.Direct3D9.Light arg1) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, arg1_,((void**)(*(void**)_nativePointer))[51]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a set of lighting properties that this device uses.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the lighting property set to retrieve. This method will fail if a lighting property has not been set for this index by calling the <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong> method. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Light"/></strong> structure that is filled with the retrieved lighting-parameter set. </p> </dd></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other values in <see cref="SharpDX.Direct3D9.CreateFlags"/>.</p><p>Retrieve all the properties for an existing light source by calling the <strong><see cref="SharpDX.Direct3D9.Device.GetLight"/></strong> method for the device. When calling the <strong><see cref="SharpDX.Direct3D9.Device.GetLight"/></strong> method, pass the zero-based index of the light source for which the properties will be retrieved as the first parameter, and supply the address of a <strong><see cref="SharpDX.Direct3D9.Light"/></strong> structure as the second parameter. The device fills the <strong><see cref="SharpDX.Direct3D9.Light"/></strong> structure to describe the lighting properties it uses for the light source at that index.</p><pre> // Assume d3dDevice is a valid reference to an <see cref="SharpDX.Direct3D9.Device"/> interface.	
        /// <see cref="SharpDX.Result"/> hr;	
        /// D3DLight9 light; // Get the property information for the first light.	
        /// hr = pd3dDevice-&gt;GetLight(0, &amp;light);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure	
        /// </pre><p>If you supply an index outside the range of the light sources assigned in the device, the <strong><see cref="SharpDX.Direct3D9.Device.GetLight"/></strong> method fails, returning <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p><p>When you assign a set of light properties for a light source in a scene, the light source can be activated by calling the <strong><see cref="SharpDX.Direct3D9.Device.EnableLight"/></strong> method for the device. New light sources are disabled by default. The <strong><see cref="SharpDX.Direct3D9.Device.EnableLight"/></strong> method accepts two parameters. Set the first parameter to the zero-based index of the light source to be affected by the method, and set the second parameter to <strong>TRUE</strong> to enable the light or <strong><see cref="SharpDX.Result.False"/></strong> to disable it. The following code example illustrates the use of this method by enabling the first light source in the device's list of light source properties.</p><pre> // Assume d3dDevice is a valid reference to an <see cref="SharpDX.Direct3D9.Device"/> interface.	
        /// <see cref="SharpDX.Result"/> hr; hr = pd3dDevice-&gt;LightEnable(0, TRUE);	
        /// if (SUCCEEDED(hr)) // Handle Success	
        /// else // Handle failure	
        /// </pre><p>Check the MaxActiveLights member of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure when you retrieve device capabilities to determine the maximum number of active lights supported by that device.</p><p>If you enable or disable a light that has no properties that are set with <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong>, the <strong><see cref="SharpDX.Direct3D9.Device.EnableLight"/></strong> method creates a light source with the properties listed in following table and enables or disables it.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetLight']/*"/>	
        /// <msdn-id>bb174392</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetLight([In] unsigned int Index,[Out] D3DLIGHT9* arg1)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetLight</unmanaged-short>	
        public SharpDX.Direct3D9.Light GetLight(int index) {
            unsafe {
                SharpDX.Direct3D9.Light arg1;
                arg1 = new SharpDX.Direct3D9.Light();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, &arg1,((void**)(*(void**)_nativePointer))[52]);		
                __result__.CheckError();
                return arg1;
            }
        }
        
        /// <summary>	
        /// <p>Enables or disables a set of lighting parameters within a device.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the set of lighting parameters that are the target of this method. </p> </dd></param>	
        /// <param name="enable"><dd>  <p>Value that indicates if the set of lighting parameters are being enabled or disabled. Set this parameter to <strong>TRUE</strong> to enable lighting with the parameters at the specified index, or <strong><see cref="SharpDX.Result.False"/></strong> to disable it. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>If a value for LightIndex is outside the range of the light property sets assigned within the device, the <strong><see cref="SharpDX.Direct3D9.Device.EnableLight"/></strong> method creates a light source represented by a <strong><see cref="SharpDX.Direct3D9.Light"/></strong> structure with the following properties and sets its enabled state to the value specified in bEnable.</p><table> <tr><th>Member</th><th>Default</th></tr> <tr><td> Type </td><td><see cref="SharpDX.Direct3D9.LightType.Directional"/></td></tr> <tr><td> Diffuse </td><td>(R:1, G:1, B:1, A:0)</td></tr> <tr><td> Specular </td><td>(R:0, G:0, B:0, A:0)</td></tr> <tr><td> Ambient </td><td>(R:0, G:0, B:0, A:0)</td></tr> <tr><td> Position </td><td>(0, 0, 0)</td></tr> <tr><td> Direction </td><td>(0, 0, 1)</td></tr> <tr><td> Range </td><td>0</td></tr> <tr><td> Falloff </td><td>0</td></tr> <tr><td> Attenuation0 </td><td>0</td></tr> <tr><td> Attenuation1 </td><td>0</td></tr> <tr><td> Attenuation2 </td><td>0</td></tr> <tr><td> Theta </td><td>0</td></tr> <tr><td> Phi </td><td>0</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::LightEnable']/*"/>	
        /// <msdn-id>bb174421</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::LightEnable([In] unsigned int Index,[In] BOOL Enable)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::LightEnable</unmanaged-short>	
        public void EnableLight(int index, SharpDX.Mathematics.Interop.RawBool enable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint28(_nativePointer, index, enable,((void**)(*(void**)_nativePointer))[53]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the activity status - enabled or disabled - for a set of lighting parameters within a device.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Zero-based index of the set of lighting parameters that are the target of this method. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a variable to fill with the status of the specified lighting parameters. After the call, a nonzero value at this address indicates that the specified lighting parameters are enabled; a value of 0 indicates that they are disabled. </p> </dd></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other values in <see cref="SharpDX.Direct3D9.CreateFlags"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetLightEnable']/*"/>	
        /// <msdn-id>bb174393</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetLightEnable([In] unsigned int Index,[Out] BOOL* pEnable)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetLightEnable</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsLightEnabled(int index) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool enableRef;
                enableRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, &enableRef,((void**)(*(void**)_nativePointer))[54]);		
                __result__.CheckError();
                return enableRef;
            }
        }
        
        /// <summary>	
        /// <p>Sets the coefficients of a user-defined clipping plane for the device.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index of the clipping plane for which the plane equation coefficients are to be set. </p> </dd></param>	
        /// <param name="planeRef"><dd>  <p>Pointer to an address of a four-element array of values that represent the clipping plane coefficients to be set, in the form of the general plane equation. See Remarks. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. This error indicates that the value in Index exceeds the maximum clipping plane index supported by the device or that the array at pPlane is not large enough to contain four floating-point values. </p></returns>	
        /// <remarks>	
        /// <p>The coefficients that this method sets take the form of the general plane equation. If the values in the array at pPlane were labeled A, B, C, and D in the order that they appear in the array, they would fit into the general plane equation so that Ax + By + Cz + Dw = 0. A point with homogeneous coordinates (x, y, z, w) is visible in the half space of the plane if Ax + By + Cz + Dw &gt;= 0. Points that exist behind the clipping plane are clipped from the scene.</p><p>When the fixed function pipeline is used the plane equations are assumed to be in world space. When the programmable pipeline is used the plane equations are assumed to be in the clipping space (the same space as output vertices).</p><p>This method does not enable the clipping plane equation being set. To enable a clipping plane, set the corresponding bit in the DWORD value applied to the <see cref="SharpDX.Direct3D9.RenderState.ClipPlaneEnable"/> render state.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetClipPlane']/*"/>	
        /// <msdn-id>bb174426</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetClipPlane([In] unsigned int Index,[In] const SHARPDX_VECTOR4* pPlane)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetClipPlane</unmanaged-short>	
        public void SetClipPlane(int index, SharpDX.Mathematics.Interop.RawVector4 planeRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, &planeRef,((void**)(*(void**)_nativePointer))[55]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the coefficients of a user-defined clipping plane for the device.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index of the clipping plane for which the plane equation coefficients are retrieved. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a four-element array of values that represent the coefficients of the clipping plane in the form of the general plane equation. See Remarks. </p> </dd></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other values in <see cref="SharpDX.Direct3D9.CreateFlags"/>." </p><p>The coefficients that this method reports take the form of the general plane equation. If the values in the array at pPlane were labeled A, B, C, and D in the order that they appear in the array, they would fit into the general plane equation so that Ax + By + Cz + Dw = 0. A point with homogeneous coordinates (x, y, z, w) is visible in the half space of the plane if Ax + By + Cz + Dw &gt;= 0. Points that exist on or behind the clipping plane are clipped from the scene.</p><p>The plane equation used by this method exists in world space and is set by a previous call to the <strong><see cref="SharpDX.Direct3D9.Device.SetClipPlane"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetClipPlane']/*"/>	
        /// <msdn-id>bb174380</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetClipPlane([In] unsigned int Index,[Out] float* pPlane)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetClipPlane</unmanaged-short>	
        public float GetClipPlane(int index) {
            unsafe {
                float planeRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, &planeRef,((void**)(*(void**)_nativePointer))[56]);		
                __result__.CheckError();
                return planeRef;
            }
        }
        
        /// <summary>	
        /// <p>Sets a single device render-state parameter.</p>	
        /// </summary>	
        /// <param name="state"><dd>  <p>Device state variable that is being modified. This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.RenderState"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="value"><dd>  <p>New value for the device render state to be set. The meaning of this parameter is dependent on the value specified for <em>State</em>. For example, if <em>State</em> were <see cref="SharpDX.Direct3D9.RenderState.ShadeMode"/>, the second parameter would be one member of the <strong><see cref="SharpDX.Direct3D9.ShadeMode"/></strong> enumerated type. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if one of the arguments is invalid. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetRenderState']/*"/>	
        /// <msdn-id>bb174454</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetRenderState([In] D3DRENDERSTATETYPE State,[In] unsigned int Value)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetRenderState</unmanaged-short>	
        public void SetRenderState(SharpDX.Direct3D9.RenderState state, int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)state), value,((void**)(*(void**)_nativePointer))[57]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a render-state value for a device.</p>	
        /// </summary>	
        /// <param name="state"><dd>  <p>Device state variable that is being queried. This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.RenderState"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="valueRef"><dd>  <p>Pointer to a variable that receives the value of the queried render state variable when the method returns. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> if one of the arguments is invalid. </p></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other values in <see cref="SharpDX.Direct3D9.CreateFlags"/>." </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetRenderState']/*"/>	
        /// <msdn-id>bb174403</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetRenderState([In] D3DRENDERSTATETYPE State,[In] void* pValue)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetRenderState</unmanaged-short>	
        internal void GetRenderState(SharpDX.Direct3D9.RenderState state, System.IntPtr valueRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)state), (void*)valueRef,((void**)(*(void**)_nativePointer))[58]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new state block that contains the values for all device states, vertex-related states, or pixel-related states.</p>	
        /// </summary>	
        /// <param name="type"><dd>  <p>Type of state data that the method should capture. This parameter can be set to a value defined in the <strong><see cref="SharpDX.Direct3D9.StateBlockType"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="sBOut"><dd>  <p>Pointer to a state block interface. See <strong><see cref="SharpDX.Direct3D9.StateBlock"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Vertex-related device states typically refer to those states that affect how the system processes vertices. Pixel-related states generally refer to device states that affect how the system processes pixel or depth-buffer data during rasterization. Some states are contained in both groups. </p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>In Direct3D 9, a state block contains state data, for the states it was requested to capture, when the object is created. To change the value of the state block, call <strong><see cref="SharpDX.Direct3D9.StateBlock.Capture"/></strong> or <strong><see cref="SharpDX.Direct3D9.Device.BeginStateBlock"/></strong>/<strong><see cref="SharpDX.Direct3D9.Device.EndStateBlock"/></strong>. There is no state saved when a state block object is created in Direct3D 10.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateStateBlock']/*"/>	
        /// <msdn-id>bb174362</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateStateBlock([In] D3DSTATEBLOCKTYPE Type,[Out, Fast] IDirect3DStateBlock9** ppSB)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateStateBlock</unmanaged-short>	
        internal void CreateStateBlock(SharpDX.Direct3D9.StateBlockType type, SharpDX.Direct3D9.StateBlock sBOut) {
            unsafe {
                IntPtr sBOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)type), &sBOut_,((void**)(*(void**)_nativePointer))[59]);		
                ((SharpDX.Direct3D9.StateBlock)sBOut).NativePointer = sBOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Signals Direct3D to begin recording a device-state block.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Applications can ensure that all recorded states are valid by calling the <strong><see cref="SharpDX.Direct3D9.Device.ValidateDevice"/></strong> method prior to calling this method.</p><p>The following methods can be recorded in a state block, after calling <strong><see cref="SharpDX.Direct3D9.Device.BeginStateBlock"/></strong> and before <strong><see cref="SharpDX.Direct3D9.Device.EndStateBlock"/></strong>. </p><ul> <li> <strong><see cref="SharpDX.Direct3D9.Device.EnableLight"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetClipPlane"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetCurrentTexturePalette"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetVertexFormat"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetIndices"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetMaterial"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetNPatchMode"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShader"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShaderConstantB"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShaderConstantF"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShaderConstantI"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetRenderState"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetSamplerState"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetScissorRect"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetStreamSource"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetStreamSourceFrequency"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetTexture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetTextureStageState"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetTransform_"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetViewport"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetVertexDeclaration"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShader"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShaderConstantB"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShaderConstantF"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShaderConstantI"/></strong> </li> </ul><p>The ordering of state changes in a state block is not guaranteed. If the same state is specified multiple times in a state block, only the last value is used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::BeginStateBlock']/*"/>	
        /// <msdn-id>bb174351</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::BeginStateBlock()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::BeginStateBlock</unmanaged-short>	
        public void BeginStateBlock() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[60]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Signals Direct3D to stop recording a device-state block and retrieve a reference to the state block interface.</p>	
        /// </summary>	
        /// <returns><dd>  <p>Pointer to a state block interface. See <strong><see cref="SharpDX.Direct3D9.StateBlock"/></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::EndStateBlock']/*"/>	
        /// <msdn-id>bb174376</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::EndStateBlock([In] IDirect3DStateBlock9** ppSB)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::EndStateBlock</unmanaged-short>	
        public SharpDX.Direct3D9.StateBlock EndStateBlock() {
            unsafe {
                SharpDX.Direct3D9.StateBlock sBOut;
                IntPtr sBOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &sBOut_,((void**)(*(void**)_nativePointer))[61]);		
                sBOut= (sBOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.StateBlock(sBOut_);	
                __result__.CheckError();
                return sBOut;
            }
        }
        
        /// <summary>	
        /// <p>Sets the clip status.</p>	
        /// </summary>	
        /// <param name="clipStatusRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ClipStatus"/></strong> structure, describing the clip status settings to be set. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If one of the arguments is invalid, the return value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see <see cref="SharpDX.Direct3D9.CreateFlags"/>.</p><p>When clipping is enabled during vertex processing (by <strong><see cref="SharpDX.Direct3D9.Device.ProcessVertices"/></strong>, <strong><see cref="SharpDX.Direct3D9.Device.DrawPrimitives"/></strong>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <strong><see cref="SharpDX.Direct3D9.ClipStatus"/></strong>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When <see cref="SharpDX.Direct3D9.RenderState.Clipping"/> is set to <strong><see cref="SharpDX.Result.False"/></strong>, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing.</p><p>Clip status is not updated by <strong><see cref="SharpDX.Direct3D9.Device.DrawRectanglePatch"/></strong> and <strong><see cref="SharpDX.Direct3D9.Device.DrawTrianglePatch"/></strong> because there is no software emulation for them.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetClipStatus']/*"/>	
        /// <msdn-id>bb174427</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetClipStatus([In] const D3DCLIPSTATUS9* pClipStatus)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetClipStatus</unmanaged-short>	
        internal void SetClipStatus(SharpDX.Direct3D9.ClipStatus clipStatusRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &clipStatusRef,((void**)(*(void**)_nativePointer))[62]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the clip status.</p>	
        /// </summary>	
        /// <param name="clipStatusRef"><dd>  <p> Pointer to a <strong><see cref="SharpDX.Direct3D9.ClipStatus"/></strong> structure that describes the clip status. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p><p><see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the argument is invalid.</p></returns>	
        /// <remarks>	
        /// <p>When clipping is enabled during vertex processing (by <strong><see cref="SharpDX.Direct3D9.Device.ProcessVertices"/></strong>, <strong><see cref="SharpDX.Direct3D9.Device.DrawPrimitives"/></strong>, or other drawing functions), Direct3D computes a clip code for every vertex. The clip code is a combination of D3DCS_* bits. When a vertex is outside a particular clipping plane, the corresponding bit is set in the clipping code. Direct3D maintains the clip status using <strong><see cref="SharpDX.Direct3D9.ClipStatus"/></strong>, which has ClipUnion and ClipIntersection members. ClipUnion is a bitwise "OR" of all vertex clip codes and ClipIntersection is a bitwise "AND" of all vertex clip codes. Initial values are zero for ClipUnion and 0xFFFFFFFF for ClipIntersection. When <see cref="SharpDX.Direct3D9.RenderState.Clipping"/> is set to <strong><see cref="SharpDX.Result.False"/></strong>, ClipUnion and ClipIntersection are set to zero. Direct3D updates the clip status during drawing calls. To compute clip status for a particular object, set ClipUnion and ClipIntersection to their initial value and continue drawing.</p><p>Clip status is not updated by <strong><see cref="SharpDX.Direct3D9.Device.DrawRectanglePatch"/></strong> and <strong><see cref="SharpDX.Direct3D9.Device.DrawTrianglePatch"/></strong> because there is no software emulation for them.</p><p>Clip status is used during software vertex processing. Therefore, this method is not supported on pure or nonpure hardware processing devices. For more information about pure devices, see <see cref="SharpDX.Direct3D9.CreateFlags"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetClipStatus']/*"/>	
        /// <msdn-id>bb174381</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetClipStatus([Out] D3DCLIPSTATUS9* pClipStatus)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetClipStatus</unmanaged-short>	
        internal void GetClipStatus(out SharpDX.Direct3D9.ClipStatus clipStatusRef) {
            unsafe {
                clipStatusRef = new SharpDX.Direct3D9.ClipStatus();
                SharpDX.Result __result__;
                fixed (void* clipStatusRef_ = &clipStatusRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, clipStatusRef_,((void**)(*(void**)_nativePointer))[63]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a texture assigned to a stage for a device.</p>	
        /// </summary>	
        /// <param name="stage"><dd>  <p>Stage identifier of the texture to retrieve. Stage identifiers are zero-based.</p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface, representing the returned texture. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Typically, methods that return state will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. This method however, will work even on a pure device because it returns an interface.</p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetTexture']/*"/>	
        /// <msdn-id>bb174412</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetTexture([In] unsigned int Stage,[Out] IDirect3DBaseTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetTexture</unmanaged-short>	
        public SharpDX.Direct3D9.BaseTexture GetTexture(int stage) {
            unsafe {
                SharpDX.Direct3D9.BaseTexture textureOut;
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, stage, &textureOut_,((void**)(*(void**)_nativePointer))[64]);		
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.BaseTexture(textureOut_);	
                __result__.CheckError();
                return textureOut;
            }
        }
        
        /// <summary>	
        /// <p>Assigns a texture to a stage for a device.</p>	
        /// </summary>	
        /// <param name="stage"><dd>  <p>Zero based sampler number.  Textures are bound to samplers; samplers define sampling state such as the filtering mode and the address wrapping mode. Textures are referenced differently by the programmable and the fixed function pipeline: </p> <ul> <li>Programmable shaders reference textures using the sampler number. The number of samplers available to a programmable shader is dependent on the shader version. For vertex shaders, see Sampler (Direct3D 9 asm-vs). For pixel shaders see Sampler (Direct3D 9 asm-ps).</li> <li>The fixed function pipeline on the other hand, references textures by texture stage number. The maximum number of samplers is determined from two caps: MaxSimultaneousTextures and MaxTextureBlendStages of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure.</li> </ul> <p>There are two other special cases for stage/sampler numbers.</p> <ul> <li>A special number called D3DDMAPSAMPLER is used for Displacement Mapping (Direct3D 9).</li> <li>A programmable vertex shader uses a special number defined by a <see cref="SharpDX.Direct3D9.VertexTextureSampler"/> when accessing Vertex Textures in vs_3_0 (DirectX HLSL).</li> </ul> </dd></param>	
        /// <param name="textureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface, representing the texture being set.  </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p><strong>SetTexture</strong> is not allowed if the texture is created with a pool type of <see cref="SharpDX.Direct3D9.Pool.Scratch"/>. <strong>SetTexture</strong> is not allowed with a pool type of <see cref="SharpDX.Direct3D9.Pool.SystemMemory"/> texture unless DevCaps is set with <see cref="SharpDX.Direct3D9.DeviceCaps.TextureSystemMemory"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetTexture']/*"/>	
        /// <msdn-id>bb174461</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetTexture([In] unsigned int Stage,[In] IDirect3DBaseTexture9* pTexture)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetTexture</unmanaged-short>	
        public void SetTexture(int stage, SharpDX.Direct3D9.BaseTexture textureRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, stage, (void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer),((void**)(*(void**)_nativePointer))[65]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a state value for an assigned texture.</p>	
        /// </summary>	
        /// <param name="stage"><dd>  <p>Stage identifier of the texture for which the state is retrieved. Stage identifiers are zero-based. Devices can have up to eight set textures, so the maximum value allowed for Stage is 7. </p> </dd></param>	
        /// <param name="type"><dd>  <p>Texture state to retrieve. This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.TextureStage"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="valueRef"><dd>  <p>Pointer a variable to fill with the retrieved state value. The meaning of the retrieved value is determined by the Type parameter. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other flag values in <see cref="SharpDX.Direct3D9.CreateFlags"/>." </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetTextureStageState']/*"/>	
        /// <msdn-id>bb174413</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetTextureStageState([In] unsigned int Stage,[In] D3DTEXTURESTAGESTATETYPE Type,[In] void* pValue)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetTextureStageState</unmanaged-short>	
        internal void GetTextureStageState(int stage, SharpDX.Direct3D9.TextureStage type, System.IntPtr valueRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, stage, unchecked((int)type), (void*)valueRef,((void**)(*(void**)_nativePointer))[66]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the state value for the currently assigned texture.</p>	
        /// </summary>	
        /// <param name="stage"><dd>  <p>Stage identifier of the texture for which the state value is set. Stage identifiers are zero-based. Devices can have up to eight set textures, so the maximum value allowed for Stage is 7. </p> </dd></param>	
        /// <param name="type"><dd>  <p>Texture state to set. This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.TextureStage"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="value"><dd>  <p>State value to set. The meaning of this value is determined by the Type parameter. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetTextureStageState']/*"/>	
        /// <msdn-id>bb174462</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetTextureStageState([In] unsigned int Stage,[In] D3DTEXTURESTAGESTATETYPE Type,[In] unsigned int Value)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetTextureStageState</unmanaged-short>	
        public void SetTextureStageState(int stage, SharpDX.Direct3D9.TextureStage type, int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, stage, unchecked((int)type), value,((void**)(*(void**)_nativePointer))[67]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the sampler state value.</p>	
        /// </summary>	
        /// <param name="sampler"><dd>  <p>The sampler stage index.</p> </dd></param>	
        /// <param name="type"><dd>  <p>This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.SamplerState"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="valueRef"><dd>  <p>State value to get. The meaning of this value is determined by the Type parameter. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method will not return device state for a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. If you want to use this method, you must create your device with any of the other values in <see cref="SharpDX.Direct3D9.CreateFlags"/>." </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetSamplerState']/*"/>	
        /// <msdn-id>bb174406</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetSamplerState([In] unsigned int Sampler,[In] D3DSAMPLERSTATETYPE Type,[In] void* pValue)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetSamplerState</unmanaged-short>	
        internal void GetSamplerState(int sampler, SharpDX.Direct3D9.SamplerState type, System.IntPtr valueRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, sampler, unchecked((int)type), (void*)valueRef,((void**)(*(void**)_nativePointer))[68]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the sampler state value.</p>	
        /// </summary>	
        /// <param name="sampler"><dd>  <p>The sampler stage index. For more info about sampler stage, see Sampling Stage Registers in vs_3_0 (DirectX HLSL).</p> </dd></param>	
        /// <param name="type"><dd>  <p>This parameter can be any member of the <strong><see cref="SharpDX.Direct3D9.SamplerState"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="value"><dd>  <p>State value to set. The meaning of this value is determined by the Type parameter. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetSamplerState']/*"/>	
        /// <msdn-id>bb174456</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetSamplerState([In] unsigned int Sampler,[In] D3DSAMPLERSTATETYPE Type,[In] unsigned int Value)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetSamplerState</unmanaged-short>	
        public void SetSamplerState(int sampler, SharpDX.Direct3D9.SamplerState type, int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, sampler, unchecked((int)type), value,((void**)(*(void**)_nativePointer))[69]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Reports the device's ability to render the current texture-blending operations and arguments in a single pass.</p>	
        /// </summary>	
        /// <param name="numPassesRef"><dd>  <p>Pointer to a DWORD value to fill with the number of rendering passes needed to complete the desired effect through multipass rendering. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.ConflictingRenderState"/>, <see cref="SharpDX.Direct3D9.ResultCode.ConflictingTextureFilter"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>, <see cref="SharpDX.Direct3D9.ResultCode.TooManyOperations"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedAlphaArgument"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedAlphaOperation"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedColorArgument"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedColorOperation"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedFactorValue"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedTextureFilter"/>, <see cref="SharpDX.Direct3D9.ResultCode.WrongTextureFormat"/>,.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct3D9.Device.ValidateDevice"/></strong> method should be used to validate scenarios only when other capabilities are deficient. For example, in a multistage texturing scenario, you could query the MaxTextureBlendStages and MaxSimultaneousTextures members of a <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure to determine if multistage texturing is possible on the device.</p><p>Current hardware does not necessarily implement all possible combinations of operations and arguments. You can determine whether a particular blending operation can be performed with given arguments by setting the desired blending operation, and then calling the <strong><see cref="SharpDX.Direct3D9.Device.ValidateDevice"/></strong> method. </p><p>The <strong><see cref="SharpDX.Direct3D9.Device.ValidateDevice"/></strong> method uses the current render states, textures, and texture-stage states to perform validation at the time of the call. Changes to these factors after the call invalidate the previous result, and the method must be called again before rendering a scene.</p><p>For best performance, call <strong><see cref="SharpDX.Direct3D9.Device.ValidateDevice"/></strong> at initialization time; do not use it within a render loop.</p><p>Using diffuse iterated values, either as an argument or as an operation (D3DTA_DIFFUSED3DTOP_BLENDDIFFUSEALPHA) is rarely supported on current hardware. Most hardware can introduce iterated color data only at the last texture operation stage.</p><p>Try to specify the texture (<see cref="SharpDX.Direct3D9.TextureArgument.Texture"/>) for each stage as the first argument, rather than the second argument.</p><p>Many cards do not support use of diffuse or scalar values at arbitrary texture stages. Often, these are available only at the first or last texture-blending stage.</p><p>Many cards do not have a blending unit associated with the first texture that is capable of more than replicating alpha to color channels or inverting the input. Therefore, your application might need to use only the second texture stage, if possible. On such hardware, the first unit is presumed to be in its default state, which has the first color argument set to <see cref="SharpDX.Direct3D9.TextureArgument.Texture"/> with the <see cref="SharpDX.Direct3D9.TextureOperation.SelectArg1"/> operation.</p><p>Operations on the output alpha that are more intricate than or substantially different from the color operations are less likely to be supported. </p><p>Some hardware does not support simultaneous use of <see cref="SharpDX.Direct3D9.TextureArgument.TFactor"/> and <see cref="SharpDX.Direct3D9.TextureArgument.Diffuse"/>.</p><p>Many cards do not support simultaneous use of multiple textures and mipmapped trilinear filtering. If trilinear filtering has been requested for a texture involved in multitexture blending operations and validation fails, turn off trilinear filtering and revalidate. In this case, you might want to perform multipass rendering instead.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::ValidateDevice']/*"/>	
        /// <msdn-id>bb205859</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::ValidateDevice([In] unsigned int* pNumPasses)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::ValidateDevice</unmanaged-short>	
        public void ValidateDevice(int numPassesRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &numPassesRef,((void**)(*(void**)_nativePointer))[70]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets palette entries.</p>	
        /// </summary>	
        /// <param name="paletteNumber"><dd>  <p>An ordinal value identifying the particular palette upon which the operation is to be performed. </p> </dd></param>	
        /// <param name="entriesRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, representing the palette entries to set. The number of <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structures pointed to by pEntries is assumed to be 256. See Remarks. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>For Direct3D 9 applications, any palette sent to this method must conform to the <see cref="SharpDX.Direct3D9.TextureCaps.AlphaPalette"/> capability bit of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure. If <see cref="SharpDX.Direct3D9.TextureCaps.AlphaPalette"/> is not set, every entry in the palette must have alpha set to 1.0 or this method will fail with <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. If <see cref="SharpDX.Direct3D9.TextureCaps.AlphaPalette"/> is set, then any set of alpha values are allowed. Note that the debug runtime will print a warning message if all palette entries have alpha set to 0. </p><p>A single logical palette is associated with the device, and is shared by all texture stages.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetPaletteEntries']/*"/>	
        /// <msdn-id>bb174439</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPaletteEntries([In] unsigned int PaletteNumber,[In, Buffer] const PALETTEENTRY* pEntries)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetPaletteEntries</unmanaged-short>	
        public void SetPaletteEntries(int paletteNumber, SharpDX.Direct3D9.PaletteEntry[] entriesRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* entriesRef_ = entriesRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, paletteNumber, entriesRef_,((void**)(*(void**)_nativePointer))[71]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves palette entries.</p>	
        /// </summary>	
        /// <param name="paletteNumber"><dd>  <p>An ordinal value identifying the particular palette to retrieve. </p> </dd></param>	
        /// <param name="entriesRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, representing the returned palette entries. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>For more information about <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong>, see the Platform SDK.</p><p><strong>Note</strong>??As of Direct3D 9, the peFlags member of the <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure does not work the way it is documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetPaletteEntries']/*"/>	
        /// <msdn-id>bb174397</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPaletteEntries([In] unsigned int PaletteNumber,[In, Buffer] PALETTEENTRY* pEntries)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetPaletteEntries</unmanaged-short>	
        internal void GetPaletteEntries(int paletteNumber, SharpDX.Direct3D9.PaletteEntry[] entriesRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* entriesRef_ = entriesRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, paletteNumber, entriesRef_,((void**)(*(void**)_nativePointer))[72]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the current texture palette.</p>	
        /// </summary>	
        /// <param name="paletteNumber"><dd>  <p>Value that specifies the texture palette to set as the current texture palette. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>A single logical palette is associated with the device, and is shared by all texture stages.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetCurrentTexturePalette']/*"/>	
        /// <msdn-id>bb174428</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetCurrentTexturePalette([In] unsigned int PaletteNumber)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetCurrentTexturePalette</unmanaged-short>	
        internal void SetCurrentTexturePalette(int paletteNumber) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, paletteNumber,((void**)(*(void**)_nativePointer))[73]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the current texture palette.</p>	
        /// </summary>	
        /// <param name="paletteNumber"><dd>  <p>Pointer to a returned value that identifies the current texture palette. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetCurrentTexturePalette']/*"/>	
        /// <msdn-id>bb174383</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetCurrentTexturePalette([Out] unsigned int* PaletteNumber)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetCurrentTexturePalette</unmanaged-short>	
        internal void GetCurrentTexturePalette(out int paletteNumber) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* paletteNumber_ = &paletteNumber)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, paletteNumber_,((void**)(*(void**)_nativePointer))[74]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the scissor rectangle.</p>	
        /// </summary>	
        /// <param name="rectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that defines the rendering area within the render target if scissor test is enabled. This parameter may not be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The scissor rectangle is used as a rectangular clipping region.</p><p>See Rectangles (Direct3D 9) for further information on the use of rectangles in DirectX.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetScissorRect']/*"/>	
        /// <msdn-id>bb174457</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetScissorRect([In] const RECT* pRect)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetScissorRect</unmanaged-short>	
        internal void SetScissorRect(SharpDX.Mathematics.Interop.RawRectangle rectRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &rectRef,((void**)(*(void**)_nativePointer))[75]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the scissor rectangle.</p>	
        /// </summary>	
        /// <param name="rectRef"><dd>  <p>Returns a reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that defines the rendering area within the render target if scissor test is enabled.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The scissor rectangle is used as a rectangular clipping region.</p><p>See Rectangles (Direct3D 9) for further information on the use of rectangles in DirectX.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetScissorRect']/*"/>	
        /// <msdn-id>bb174407</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetScissorRect([Out] RECT* pRect)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetScissorRect</unmanaged-short>	
        internal void GetScissorRect(out SharpDX.Mathematics.Interop.RawRectangle rectRef) {
            unsafe {
                rectRef = new SharpDX.Mathematics.Interop.RawRectangle();
                SharpDX.Result __result__;
                fixed (void* rectRef_ = &rectRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, rectRef_,((void**)(*(void**)_nativePointer))[76]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to switch between software and hardware vertex processing.</p>	
        /// </summary>	
        /// <param name="bSoftware"><dd>  <p><strong>TRUE</strong> to specify software vertex processing; <strong><see cref="SharpDX.Result.False"/></strong> to specify hardware vertex processing.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>The restrictions for changing modes are as follows:</p><ul> <li>If a device is created with <see cref="SharpDX.Direct3D9.CreateFlags.SoftwareVertexProcessing"/>, the vertex processing will be done in software and cannot be changed.</li> <li>If a device is created with <see cref="SharpDX.Direct3D9.CreateFlags.HardwareVertexProcessing"/>, the vertex processing will be done in hardware and cannot be changed.</li> <li>If a device is created with <see cref="SharpDX.Direct3D9.CreateFlags.MixedVertexProcessing"/>, the vertex processing will be done in hardware by default. The processing can be switched to software (or back to hardware) using <strong><see cref="SharpDX.Direct3D9.Device.SetSoftwareVertexProcessing"/></strong>.</li> </ul><p>An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use IDirect3DDevice8::SetRenderState with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate DWORD argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks.</p><p>In Direct3D 9, use <strong>SetSoftwareVertexProcessing</strong> instead. This new API is not recorded by StateBlocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetSoftwareVertexProcessing']/*"/>	
        /// <msdn-id>bb174458</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetSoftwareVertexProcessing([In] BOOL bSoftware)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetSoftwareVertexProcessing</unmanaged-short>	
        internal void SetSoftwareVertexProcessing(SharpDX.Mathematics.Interop.RawBool bSoftware) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint17(_nativePointer, bSoftware,((void**)(*(void**)_nativePointer))[77]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the vertex processing (hardware or software) mode.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if software vertex processing is set. Otherwise, it returns <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>An application can create a mixed-mode device to use both the software vertex processing and the hardware vertex processing. To switch between the two vertex processing modes in DirectX 8.x, use <strong><see cref="SharpDX.Direct3D9.Device.SetRenderState"/></strong> with the render state D3DRS_SOFTWAREVERTEXPROCESSING and the appropriate <see cref="SharpDX.Mathematics.Interop.RawBool"/> argument. The drawback of the render state approach was the difficulty in defining the semantics for state blocks. Applications and the runtime had to do extra work and be careful while recording and playing back state blocks.</p><p>In Direct3D 9, use <strong><see cref="SharpDX.Direct3D9.Device.SetSoftwareVertexProcessing"/></strong> instead. This new API is not recorded by StateBlocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetSoftwareVertexProcessing']/*"/>	
        /// <msdn-id>bb174408</msdn-id>	
        /// <unmanaged>BOOL IDirect3DDevice9::GetSoftwareVertexProcessing()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetSoftwareVertexProcessing</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetSoftwareVertexProcessing() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[78]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Enable or disable N-patches.</p>	
        /// </summary>	
        /// <param name="nSegments"><dd>  <p>Specifies the number of subdivision segments. If the number of segments is less than 1.0, N-patches are disabled. The default value is 0.0. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetNPatchMode']/*"/>	
        /// <msdn-id>bb174438</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetNPatchMode([In] float nSegments)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetNPatchMode</unmanaged-short>	
        internal void SetNPatchMode(float nSegments) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, nSegments,((void**)(*(void**)_nativePointer))[79]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the N-patch mode segments.</p>	
        /// </summary>	
        /// <returns><p>Specifies the number of subdivision segments. If the number of segments is less than 1.0, N-patches are disabled. The default value is 0.0. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetNPatchMode']/*"/>	
        /// <msdn-id>bb174395</msdn-id>	
        /// <unmanaged>float IDirect3DDevice9::GetNPatchMode()</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetNPatchMode</unmanaged-short>	
        internal float GetNPatchMode() {
            unsafe {
                float __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callifloat(_nativePointer,((void**)(*(void**)_nativePointer))[80]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.</p>	
        /// </summary>	
        /// <param name="primitiveType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.PrimitiveType"/></strong> enumerated type, describing the type of primitive to render. </p> </dd></param>	
        /// <param name="startVertex"><dd>  <p>Index of the first vertex to load. Beginning at StartVertex the correct number of vertices will be read out of the vertex buffer. </p> </dd></param>	
        /// <param name="primitiveCount"><dd>  <p>Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure. PrimitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be  <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>When converting a legacy application to Direct3D 9, you must add a call to either <strong><see cref="SharpDX.Direct3D9.Device.SetVertexFormat"/></strong> to use the fixed function pipeline, or <strong><see cref="SharpDX.Direct3D9.Device.SetVertexDeclaration"/></strong> to use a vertex shader before you make any Draw calls.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::DrawPrimitive']/*"/>	
        /// <msdn-id>bb174371</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawPrimitive([In] D3DPRIMITIVETYPE PrimitiveType,[In] unsigned int StartVertex,[In] unsigned int PrimitiveCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::DrawPrimitive</unmanaged-short>	
        public void DrawPrimitives(SharpDX.Direct3D9.PrimitiveType primitiveType, int startVertex, int primitiveCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)primitiveType), startVertex, primitiveCount,((void**)(*(void**)_nativePointer))[81]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Based on indexing, renders the specified geometric primitive into an array of vertices.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.PrimitiveType"/></strong> enumerated type, describing the type of primitive to render. <see cref="SharpDX.Direct3D9.PrimitiveType.PointList"/> is not supported with this method. See Remarks. </p> </dd></param>	
        /// <param name="baseVertexIndex"><dd>  <p>Offset from the start of the vertex buffer to the first vertex. See Scenario 4.</p> </dd></param>	
        /// <param name="minVertexIndex"><dd>  <p>Minimum vertex index for vertices used during this call. This is a zero based index relative to BaseVertexIndex.</p> </dd></param>	
        /// <param name="numVertices"><dd>  <p>Number of vertices used during this call. The first vertex is located at index: BaseVertexIndex + MinIndex.</p> </dd></param>	
        /// <param name="startIndex"><dd>  <p>Index of the first index to use when accesssing the vertex buffer. Beginning at StartIndex to index vertices from the vertex buffer.</p> </dd></param>	
        /// <param name="primCount"><dd>  <p>Number of primitives to render. The number of vertices used is a function of the primitive count and the primitive type. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method draws indexed primitives from the current set of data input streams. MinIndex  and all the indices in the index stream are relative to the BaseVertexIndex.</p><p>The MinIndex  and NumVertices  parameters specify the range of vertex indices used for each <strong><see cref="SharpDX.Direct3D9.Device.DrawIndexedPrimitive"/></strong> call. These are used to optimize vertex processing of indexed primitives by processing a sequential range of vertices prior to indexing into these vertices. It is invalid for any indices used during this call to reference any vertices outside of this range.</p><p><strong><see cref="SharpDX.Direct3D9.Device.DrawIndexedPrimitive"/></strong> fails if no index array is set.</p><p>The <see cref="SharpDX.Direct3D9.PrimitiveType.PointList"/> member of the <strong><see cref="SharpDX.Direct3D9.PrimitiveType"/></strong> enumerated type is not supported and is not a valid type for this method.</p><p>When converting a legacy application to Direct3D 9, you must add a call to either <strong><see cref="SharpDX.Direct3D9.Device.SetVertexFormat"/></strong> to use the fixed function pipeline, or <strong><see cref="SharpDX.Direct3D9.Device.SetVertexDeclaration"/></strong> to use a vertex shader before you make any Draw calls.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::DrawIndexedPrimitive']/*"/>	
        /// <msdn-id>bb174369</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawIndexedPrimitive([In] D3DPRIMITIVETYPE arg0,[In] int BaseVertexIndex,[In] unsigned int MinVertexIndex,[In] unsigned int NumVertices,[In] unsigned int startIndex,[In] unsigned int primCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::DrawIndexedPrimitive</unmanaged-short>	
        public void DrawIndexedPrimitive(SharpDX.Direct3D9.PrimitiveType arg0, int baseVertexIndex, int minVertexIndex, int numVertices, int startIndex, int primCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)arg0), baseVertexIndex, minVertexIndex, numVertices, startIndex, primCount,((void**)(*(void**)_nativePointer))[82]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Renders data specified by a user memory reference as a sequence of geometric primitives of the specified type.</p>	
        /// </summary>	
        /// <param name="primitiveType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.PrimitiveType"/></strong> enumerated type, describing the type of primitive to render. </p> </dd></param>	
        /// <param name="primitiveCount"><dd>  <p>Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure. </p> </dd></param>	
        /// <param name="vertexStreamZeroDataRef"><dd>  <p>User memory reference to the vertex data.</p> </dd></param>	
        /// <param name="vertexStreamZeroStride"><dd>  <p>The number of bytes of data for each vertex. This value may not be 0.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is intended for use in applications that are unable to store their vertex data in vertex buffers. This method supports only a single vertex stream. The effect of this call is to use the provided vertex data reference and stride for vertex stream 0. It is invalid to have the declaration of the current vertex shader refer to vertex streams other than stream 0.</p><p>Following any <strong><see cref="SharpDX.Direct3D9.Device.DrawPrimitiveUP"/></strong> call, the stream 0 settings, referenced by <strong><see cref="SharpDX.Direct3D9.Device.GetStreamSource"/></strong>, are set to <strong><c>null</c></strong>.</p><p>The vertex data passed to <strong><see cref="SharpDX.Direct3D9.Device.DrawPrimitiveUP"/></strong> does not need to persist after the call. Direct3D completes its access to that data prior to returning from the call.</p><p>When converting a legacy application to Direct3D 9, you must add a call to either <strong><see cref="SharpDX.Direct3D9.Device.SetVertexFormat"/></strong> to use the fixed function pipeline, or <strong><see cref="SharpDX.Direct3D9.Device.SetVertexDeclaration"/></strong> to use a vertex shader before you make any Draw calls.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::DrawPrimitiveUP']/*"/>	
        /// <msdn-id>bb174372</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawPrimitiveUP([In] D3DPRIMITIVETYPE PrimitiveType,[In] unsigned int PrimitiveCount,[In] const void* pVertexStreamZeroData,[In] unsigned int VertexStreamZeroStride)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::DrawPrimitiveUP</unmanaged-short>	
        internal void DrawPrimitiveUP(SharpDX.Direct3D9.PrimitiveType primitiveType, int primitiveCount, System.IntPtr vertexStreamZeroDataRef, int vertexStreamZeroStride) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)primitiveType), primitiveCount, (void*)vertexStreamZeroDataRef, vertexStreamZeroStride,((void**)(*(void**)_nativePointer))[83]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Renders the specified geometric primitive with data specified by a user memory reference.</p>	
        /// </summary>	
        /// <param name="primitiveType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.PrimitiveType"/></strong> enumerated type, describing the type of primitive to render. </p> </dd></param>	
        /// <param name="minVertexIndex"><dd>  <p>Minimum vertex index. This is a zero-based index.</p> </dd></param>	
        /// <param name="numVertices"><dd>  <p> Number of vertices used during this call. The first vertex is located at index: MinVertexIndex.</p> </dd></param>	
        /// <param name="primitiveCount"><dd>  <p>Number of primitives to render. The maximum number of primitives allowed is determined by checking the MaxPrimitiveCount member of the <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure (the number of indices is a function of the primitive count and the primitive type).</p> </dd></param>	
        /// <param name="indexDataRef"><dd>  <p>User memory reference to the index data. </p> </dd></param>	
        /// <param name="indexDataFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of the index data. The valid settings are either: </p> <ul> <li> <see cref="SharpDX.Direct3D9.Format.Index16"/> </li> <li> <see cref="SharpDX.Direct3D9.Format.Index32"/> </li> </ul> </dd></param>	
        /// <param name="vertexStreamZeroDataRef"><dd>  <p>User memory reference to the vertex data. The vertex data must be in stream 0.</p> </dd></param>	
        /// <param name="vertexStreamZeroStride"><dd>  <p>The number of bytes of data for each vertex. This value may not be 0.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is intended for use in applications that are unable to store their vertex data in vertex buffers. This method supports only a single vertex stream, which must be declared as stream 0.</p><p>Following any <strong><see cref="SharpDX.Direct3D9.Device.DrawIndexedPrimitiveUP"/></strong> call, the stream 0 settings, referenced by <strong><see cref="SharpDX.Direct3D9.Device.GetStreamSource"/></strong>, are set to <strong><c>null</c></strong>. Also, the index buffer setting for <strong><see cref="SharpDX.Direct3D9.Device.SetIndices"/></strong> is set to <strong><c>null</c></strong>.</p><p>The vertex data passed to <strong><see cref="SharpDX.Direct3D9.Device.DrawIndexedPrimitiveUP"/></strong> does not need to persist after the call. Direct3D completes its access to that data prior to returning from the call.</p><p>When converting a legacy application to Direct3D 9, you must add a call to either <strong><see cref="SharpDX.Direct3D9.Device.SetVertexFormat"/></strong> to use the fixed function pipeline, or <strong><see cref="SharpDX.Direct3D9.Device.SetVertexDeclaration"/></strong> to use a vertex shader before you make any Draw calls.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::DrawIndexedPrimitiveUP']/*"/>	
        /// <msdn-id>bb174370</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawIndexedPrimitiveUP([In] D3DPRIMITIVETYPE PrimitiveType,[In] unsigned int MinVertexIndex,[In] unsigned int NumVertices,[In] unsigned int PrimitiveCount,[In] const void* pIndexData,[In] D3DFORMAT IndexDataFormat,[In] const void* pVertexStreamZeroData,[In] unsigned int VertexStreamZeroStride)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::DrawIndexedPrimitiveUP</unmanaged-short>	
        internal void DrawIndexedPrimitiveUP(SharpDX.Direct3D9.PrimitiveType primitiveType, int minVertexIndex, int numVertices, int primitiveCount, System.IntPtr indexDataRef, SharpDX.Direct3D9.Format indexDataFormat, System.IntPtr vertexStreamZeroDataRef, int vertexStreamZeroStride) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)primitiveType), minVertexIndex, numVertices, primitiveCount, (void*)indexDataRef, unchecked((int)indexDataFormat), (void*)vertexStreamZeroDataRef, vertexStreamZeroStride,((void**)(*(void**)_nativePointer))[84]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Applies the vertex processing defined by the vertex shader to the set of input data streams, generating a single stream of interleaved vertex data to the destination vertex buffer. </p>	
        /// </summary>	
        /// <param name="srcStartIndex"><dd>  <p>Index of first vertex to load. </p> </dd></param>	
        /// <param name="destIndex"><dd>  <p>Index of first vertex in the destination vertex buffer into which the results are placed. </p> </dd></param>	
        /// <param name="vertexCount"><dd>  <p>Number of vertices to process. </p> </dd></param>	
        /// <param name="destBufferRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface, the destination vertex buffer representing the stream of interleaved vertex data. </p> </dd></param>	
        /// <param name="vertexDeclRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.VertexDeclaration"/></strong> interface that represents the output vertex data declaration. When vertex shader 3.0 or above is set as the current vertex shader, the output vertex declaration must be present.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Processing options. Set this parameter to 0 for default processing. Set to D3DPV_DONOTCOPYDATA to prevent the system from copying vertex data not affected by the vertex operation into the destination buffer. The D3DPV_DONOTCOPYDATA value may be combined with one or more <see cref="SharpDX.Direct3D9.LockFlags"/> values appropriate for the destination buffer.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>The order of operations for this method is as follows:</p><ul> <li>Transform vertices to projection space using the world + view + projection matrix.</li> <li>Compute screen coordinates using viewport settings.</li> <li>If clipping is enabled, compute clipping codes and store them in an internal buffer, associated with the destination vertex buffer. If a vertex is inside the viewing frustum, its screen coordinates are computed. If the vertex is outside the viewing frustum, the vertex is stored in the destination vertex buffer in projection space coordinates.</li> <li>Other notes: The user does not have access to the internal clip code buffer. No clipping is done on triangles or any other primitives.</li> </ul><p>The destination vertex buffer, pDestBuffer, must be created with a nonzero FVF parameter in <strong><see cref="SharpDX.Direct3D9.Device.CreateVertexBuffer"/></strong>. The FVF code specified during the call to the <strong><see cref="SharpDX.Direct3D9.Device.CreateVertexBuffer"/></strong> method specifies the vertex elements present in the destination vertex buffer.</p><p>When Direct3D generates texture coordinates, or copies or transforms input texture coordinates, and the output texture coordinate format defines more texture coordinate components than Direct3D generates, Direct3D does not change these extra components.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::ProcessVertices']/*"/>	
        /// <msdn-id>bb174424</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::ProcessVertices([In] unsigned int SrcStartIndex,[In] unsigned int DestIndex,[In] unsigned int VertexCount,[In] IDirect3DVertexBuffer9* pDestBuffer,[In] IDirect3DVertexDeclaration9* pVertexDecl,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::ProcessVertices</unmanaged-short>	
        public void ProcessVertices(int srcStartIndex, int destIndex, int vertexCount, SharpDX.Direct3D9.VertexBuffer destBufferRef, SharpDX.Direct3D9.VertexDeclaration vertexDeclRef, SharpDX.Direct3D9.LockFlags flags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, srcStartIndex, destIndex, vertexCount, (void*)((destBufferRef == null)?IntPtr.Zero:destBufferRef.NativePointer), (void*)((vertexDeclRef == null)?IntPtr.Zero:vertexDeclRef.NativePointer), unchecked((int)flags),((void**)(*(void**)_nativePointer))[85]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a vertex shader declaration from the device and the vertex elements.</p>	
        /// </summary>	
        /// <param name="vertexElementsRef"><dd>  <p>An array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> vertex elements.</p> </dd></param>	
        /// <param name="declOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.VertexDeclaration"/></strong> reference that returns the created vertex shader declaration.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>See the Vertex Declaration (Direct3D 9) page for a detailed description of how to map vertex declarations between different versions of DirectX.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateVertexDeclaration']/*"/>	
        /// <msdn-id>bb174365</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVertexDeclaration([In, Buffer] const D3DVERTEXELEMENT9* pVertexElements,[Out, Fast] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateVertexDeclaration</unmanaged-short>	
        internal void CreateVertexDeclaration(SharpDX.Direct3D9.VertexElement[] vertexElementsRef, SharpDX.Direct3D9.VertexDeclaration declOut) {
            unsafe {
                IntPtr declOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* vertexElementsRef_ = vertexElementsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, vertexElementsRef_, &declOut_,((void**)(*(void**)_nativePointer))[86]);		
                ((SharpDX.Direct3D9.VertexDeclaration)declOut).NativePointer = declOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a Vertex Declaration (Direct3D 9).</p>	
        /// </summary>	
        /// <param name="declRef">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. The return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>A vertex declaration is an <see cref="SharpDX.Direct3D9.VertexDeclaration"/> object that defines the data members of a vertex (i.e. texture coordinates, colors, normals, etc.). This data can be useful for implementing vertex shaders and pixel shaders.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetVertexDeclaration']/*"/>	
        /// <msdn-id>bb174464</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexDeclaration([In] IDirect3DVertexDeclaration9* pDecl)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetVertexDeclaration</unmanaged-short>	
        internal void SetVertexDeclaration(SharpDX.Direct3D9.VertexDeclaration declRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((declRef == null)?IntPtr.Zero:declRef.NativePointer),((void**)(*(void**)_nativePointer))[87]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a vertex shader declaration.</p>	
        /// </summary>	
        /// <param name="declOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.VertexDeclaration"/></strong> object that is returned.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. The return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetVertexDeclaration']/*"/>	
        /// <msdn-id>bb174415</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexDeclaration([Out] IDirect3DVertexDeclaration9** ppDecl)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetVertexDeclaration</unmanaged-short>	
        internal void GetVertexDeclaration(out SharpDX.Direct3D9.VertexDeclaration declOut) {
            unsafe {
                IntPtr declOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &declOut_,((void**)(*(void**)_nativePointer))[88]);		
                declOut= (declOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VertexDeclaration(declOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the current vertex stream declaration.</p>	
        /// </summary>	
        /// <param name="vertexFormat"><dd>  <p>DWORD containing the fixed function vertex type. For more information, see <see cref="SharpDX.Direct3D9.VertexFormat"/>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Here are the steps necessary to initialize and use vertices that have a position, diffuse and specular color, and texture coordinates:</p><ol> <li>Define the custom vertex type and FVF code.	  <pre> struct LVertex	
        /// { FLOAT    x, y, z; <see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/> specular, diffuse; FLOAT    tu, tv;	
        /// }; const DWORD VertexFVF = (<see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Diffuse"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Specular"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Texture1"/> );	
        /// </pre>  </li> <li>Create a vertex buffer with enough room for four vertices using <strong><see cref="SharpDX.Direct3D9.Device.CreateVertexBuffer"/></strong>.  <pre> g_d3dDevice-&gt;CreateVertexBuffer( 4*sizeof(LVertex),   <see cref="SharpDX.Direct3D9.Usage.WriteOnly"/>, VertexFVF, <see cref="SharpDX.Direct3D9.Pool.Default"/>, &amp;pBigSquareVB, <c>null</c> );	
        /// </pre>  </li> <li>Set the values for each vertex.  <pre> LVertex * v;	
        /// pBigSquareVB-&gt;Lock( 0, 0, (BYTE**)&amp;v, 0 ); v[0].x  = 0.0f;  v[0].y  = 10.0;  v[0].z  = 10.0f;	
        /// v[0].diffuse  = 0xffff0000;	
        /// v[0].specular = 0xff00ff00;	
        /// v[0].tu = 0.0f;  v[0].tv = 0.0f; v[1].x  = 0.0f;  v[1].y  = 0.0f;  v[1].z  = 10.0f;	
        /// v[1].diffuse  = 0xff00ff00;	
        /// v[1].specular = 0xff00ffff;	
        /// v[1].tu = 0.0f;  v[1].tv = 0.0f; v[2].x  = 10.0f; v[2].y  = 10.0f; v[2].z  = 10.0f;	
        /// v[2].diffuse  = 0xffff00ff;	
        /// v[2].specular = 0xff000000;	
        /// v[2].tu = 0.0f;  v[2].tv = 0.0f; v[3].x  = 0.0f; v[3].y  = 10.0f;  v[3].z = 10.0f;	
        /// v[3].diffuse  = 0xffffff00;	
        /// v[3].specular = 0xffff0000;	
        /// v[3].tu = 0.0f; v[3].tv = 0.0f; pBigSquareVB-&gt;Unlock();	
        /// </pre>  </li> <li>The vertex buffer has been initialized and is ready to render. The following code example shows how to use the legacy FVF to draw a square.  <pre> g_d3dDevice-&gt;SetFVF(VertexFVF);	
        /// g_d3dDevice-&gt;SetStreamSource(0, pBigSquareVB, 0, sizeof(LVertex));	
        /// g_d3dDevice-&gt;DrawPrimitive(<see cref="SharpDX.Direct3D9.PrimitiveType.TriangleStrip"/>, 0 ,2);	
        /// </pre>  </li> </ol><p>Here are the steps necessary to initialize and use vertices that have a position, a normal, and texture coordinates:</p><ol> <li>Define the custom vertex type and FVF code. <pre> struct Vertex	
        /// { FLOAT x, y, z; FLOAT nx, ny, nz; FLOAT tu, tv;	
        /// }; const DWORD VertexFVF = ( <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Texture1"/> );	
        /// </pre>  </li> <li>Create a vertex buffer with enough room for four vertices using <strong><see cref="SharpDX.Direct3D9.Device.CreateVertexBuffer"/></strong> (similar to the example above).</li> <li>Set the values for each vertex.  <pre> Vertex * v;	
        /// pBigSquareVB-&gt;Lock(0, 0, (BYTE**)&amp;v, 0); v[0].x  = 0.0f;  v[0].y  = 10.0;  v[0].z  = 10.0f;	
        /// v[0].nx = 0.0f;  v[0].ny = 1.0f;  v[0].nz = 0.0f;	
        /// v[0].tu = 0.0f;  v[0].tv = 0.0f; v[1].x  = 0.0f;  v[1].y  = 0.0f;  v[1].z  = 10.0f;	
        /// v[1].nx = 0.0f;  v[1].ny = 1.0f;  v[1].nz = 0.0f;	
        /// v[1].tu = 0.0f;  v[1].tv = 0.0f; v[2].x  = 10.0f; v[2].y  = 10.0f; v[2].z  = 10.0f;	
        /// v[2].nx = 0.0f;  v[2].ny = 1.0f;  v[2].nz = 0.0f;	
        /// v[2].tu = 0.0f;  v[2].tv = 0.0f; v[3].x  = 0.0f; v[3].y  = 10.0f;  v[3].z = 10.0f;	
        /// v[3].nx = 0.0f; v[3].ny = 1.0f;   v[3].nz = 0.0f;	
        /// v[3].tu = 0.0f; v[3].tv = 0.0f; pBigSquareVB-&gt;Unlock();	
        /// </pre>  </li> <li>Draw the object (similar to the example above).</li> </ol>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetFVF']/*"/>	
        /// <msdn-id>bb174433</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetFVF([In] D3DFVF FVF)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetFVF</unmanaged-short>	
        internal void SetVertexFormat(SharpDX.Direct3D9.VertexFormat vertexFormat) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)vertexFormat),((void**)(*(void**)_nativePointer))[89]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the fixed vertex function declaration.</p>	
        /// </summary>	
        /// <param name="ertexFormatRef"><dd>  <p>A DWORD reference to the fixed function vertex type. For more information, see <see cref="SharpDX.Direct3D9.VertexFormat"/>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The fixed vertex function declaration is a set of FVF flags that determine how vertices processed by the fixed function pipeline will be used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetFVF']/*"/>	
        /// <msdn-id>bb174389</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetFVF([Out] D3DFVF* pFVF)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetFVF</unmanaged-short>	
        internal void GetVertexFormat(out SharpDX.Direct3D9.VertexFormat ertexFormatRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* ertexFormatRef_ = &ertexFormatRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, ertexFormatRef_,((void**)(*(void**)_nativePointer))[90]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a vertex shader.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to an array of tokens that represents the vertex shader, including any embedded debug and symbol table information.  </p> <ul> <li>Use a function such as <strong><see cref="SharpDX.Direct3D9.D3DX9.CompileShader"/></strong> to create the array from a HLSL shader.</li> <li>Use a function like <strong><see cref="SharpDX.Direct3D9.D3DX9.AssembleShader"/></strong> to create the token array from an assembly language shader.</li> <li>Use a function like <strong><see cref="SharpDX.Direct3D9.EffectCompiler.CompileShader"/></strong> to create the array from an effect.</li> </ul> </dd></param>	
        /// <param name="shaderOut"><dd>  <p>Pointer to the returned vertex shader interface (see <strong><see cref="SharpDX.Direct3D9.VertexShader"/></strong>).</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>When a device is created, <strong><see cref="SharpDX.Direct3D9.Direct3D.CreateDevice"/></strong> uses the behavior flag to determine whether to process vertices in hardware or software. There are three possibilities:</p><ul> <li>Process vertices in hardware by setting <see cref="SharpDX.Direct3D9.CreateFlags.HardwareVertexProcessing"/>.</li> <li>Process vertices in software by setting <see cref="SharpDX.Direct3D9.CreateFlags.SoftwareVertexProcessing"/>.</li> <li>Process vertices in either hardware or software by setting <see cref="SharpDX.Direct3D9.CreateFlags.MixedVertexProcessing"/>. To switch a mixed-mode device between software and hardware processing, use <strong><see cref="SharpDX.Direct3D9.Device.SetSoftwareVertexProcessing"/></strong>.</li> </ul><p>For an example using <strong><see cref="SharpDX.Direct3D9.D3DX9.CompileShader"/></strong>, see HLSLwithoutEffects Sample.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateVertexShader']/*"/>	
        /// <msdn-id>bb174366</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateVertexShader([In] const void* pFunction,[Out, Fast] IDirect3DVertexShader9** ppShader)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateVertexShader</unmanaged-short>	
        internal void CreateVertexShader(System.IntPtr functionRef, SharpDX.Direct3D9.VertexShader shaderOut) {
            unsafe {
                IntPtr shaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)functionRef, &shaderOut_,((void**)(*(void**)_nativePointer))[91]);		
                ((SharpDX.Direct3D9.VertexShader)shaderOut).NativePointer = shaderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the vertex shader.</p>	
        /// </summary>	
        /// <param name="shaderRef"><dd>  <p>Vertex shader interface. For more information, see <strong><see cref="SharpDX.Direct3D9.VertexShader"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>To set a fixed-function vertex shader (after having set a programmable vertex shader), call <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShader"/></strong>(<c>null</c>) to release the programmable shader, and then call <strong><see cref="SharpDX.Direct3D9.Device.SetVertexFormat"/></strong> with the fixed-function vertex format.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetVertexShader']/*"/>	
        /// <msdn-id>bb174465</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShader([In] IDirect3DVertexShader9* pShader)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetVertexShader</unmanaged-short>	
        internal void SetVertexShader(SharpDX.Direct3D9.VertexShader shaderRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer),((void**)(*(void**)_nativePointer))[92]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the currently set vertex shader.</p>	
        /// </summary>	
        /// <param name="shaderOut"><dd>  <p>Pointer to a vertex shader interface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If ppShader is invalid, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned. </p></returns>	
        /// <remarks>	
        /// <p>Typically, methods that return state will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>. This method however, will work even on a pure device because it returns an interface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetVertexShader']/*"/>	
        /// <msdn-id>bb174416</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShader([Out] IDirect3DVertexShader9** ppShader)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetVertexShader</unmanaged-short>	
        internal void GetVertexShader(out SharpDX.Direct3D9.VertexShader shaderOut) {
            unsafe {
                IntPtr shaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &shaderOut_,((void**)(*(void**)_nativePointer))[93]);		
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VertexShader(shaderOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a floating-point vertex shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4fCount"><dd>  <p>Number of four float vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetVertexShaderConstantF']/*"/>	
        /// <msdn-id>bb174467</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShaderConstantF([In] unsigned int StartRegister,[In] const void* pConstantData,[In] unsigned int Vector4fCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetVertexShaderConstantF</unmanaged-short>	
        internal void SetVertexShaderConstantF(int startRegister, System.IntPtr constantDataRef, int vector4fCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, vector4fCount,((void**)(*(void**)_nativePointer))[94]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a floating-point vertex shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4fCount"><dd>  <p>Number of four float vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetVertexShaderConstantF']/*"/>	
        /// <msdn-id>bb174418</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShaderConstantF([In] unsigned int StartRegister,[In, Buffer] float* pConstantData,[In] unsigned int Vector4fCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetVertexShaderConstantF</unmanaged-short>	
        internal void GetVertexShaderConstantF(int startRegister, float[] constantDataRef, int vector4fCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* constantDataRef_ = constantDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, constantDataRef_, vector4fCount,((void**)(*(void**)_nativePointer))[95]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an integer vertex shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4iCount"><dd>  <p>Number of four integer vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetVertexShaderConstantI']/*"/>	
        /// <msdn-id>bb174468</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShaderConstantI([In] unsigned int StartRegister,[In] const void* pConstantData,[In] unsigned int Vector4iCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetVertexShaderConstantI</unmanaged-short>	
        internal void SetVertexShaderConstantI(int startRegister, System.IntPtr constantDataRef, int vector4iCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, vector4iCount,((void**)(*(void**)_nativePointer))[96]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an integer vertex shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4iCount"><dd>  <p>Number of four integer vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetVertexShaderConstantI']/*"/>	
        /// <msdn-id>bb174419</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShaderConstantI([In] unsigned int StartRegister,[In, Buffer] int* pConstantData,[In] unsigned int Vector4iCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetVertexShaderConstantI</unmanaged-short>	
        internal void GetVertexShaderConstantI(int startRegister, int[] constantDataRef, int vector4iCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* constantDataRef_ = constantDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, constantDataRef_, vector4iCount,((void**)(*(void**)_nativePointer))[97]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a Boolean vertex shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="boolCount"><dd>  <p>Number of boolean values in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetVertexShaderConstantB']/*"/>	
        /// <msdn-id>bb174466</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetVertexShaderConstantB([In] unsigned int StartRegister,[In] const void* pConstantData,[In] unsigned int BoolCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetVertexShaderConstantB</unmanaged-short>	
        internal void SetVertexShaderConstantB(int startRegister, System.IntPtr constantDataRef, int boolCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, boolCount,((void**)(*(void**)_nativePointer))[98]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a Boolean vertex shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="boolCount"><dd>  <p>Number of Boolean values in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetVertexShaderConstantB']/*"/>	
        /// <msdn-id>bb174417</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetVertexShaderConstantB([In] unsigned int StartRegister,[In] void* pConstantData,[In] unsigned int BoolCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetVertexShaderConstantB</unmanaged-short>	
        internal void GetVertexShaderConstantB(int startRegister, System.IntPtr constantDataRef, int boolCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, boolCount,((void**)(*(void**)_nativePointer))[99]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Binds a vertex buffer to a device data stream. For more information, see Setting the Stream Source (Direct3D 9).</p>	
        /// </summary>	
        /// <param name="streamNumber">No documentation.</param>	
        /// <param name="streamDataRef">No documentation.</param>	
        /// <param name="offsetInBytes">No documentation.</param>	
        /// <param name="stride">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>When a FVF vertex shader is used, the stride of the vertex stream must match the vertex size, computed from the FVF. When a declaration is used, the stride should be greater than or equal to the stream size computed from the declaration.</p><p>When calling SetStreamSource, the stride is normally required to be equal to the vertex size. However, there are times when you may want to draw multiple instances of the same or similar geometry (such as when using instancing to draw). For this case, use a zero stride to tell the runtime not to increment the vertex buffer offset (ie: use the same vertex data for all instances). For more information about instancing, see Efficiently Drawing Multiple Instances of Geometry (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetStreamSource']/*"/>	
        /// <msdn-id>bb174459</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetStreamSource([In] unsigned int StreamNumber,[In] IDirect3DVertexBuffer9* pStreamData,[In] unsigned int OffsetInBytes,[In] unsigned int Stride)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetStreamSource</unmanaged-short>	
        public void SetStreamSource(int streamNumber, SharpDX.Direct3D9.VertexBuffer streamDataRef, int offsetInBytes, int stride) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, streamNumber, (void*)((streamDataRef == null)?IntPtr.Zero:streamDataRef.NativePointer), offsetInBytes, stride,((void**)(*(void**)_nativePointer))[100]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a vertex buffer bound to the specified data stream.</p>	
        /// </summary>	
        /// <param name="streamNumber"><dd>  <p>Specifies the data stream, in the range from 0 to the maximum number of streams minus one. </p> </dd></param>	
        /// <param name="streamDataOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface, representing the returned vertex buffer bound to the specified data stream. </p> </dd></param>	
        /// <param name="offsetInBytesRef"><dd>  <p>Pointer containing the offset from the beginning of the stream to the beginning of the vertex data. The offset is measured in bytes. See Remarks.</p> </dd></param>	
        /// <param name="strideRef"><dd>  <p>Pointer to a returned stride of the component, in bytes. See Remarks. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>A stream is defined as a uniform array of component data, where each component consists of one or more elements representing a single entity such as position, normal, color, and so on.</p><p>When a FVF vertex shader is used, the stride of the vertex stream must match the vertex size, computed from the FVF. When a declaration is used, the stride should be greater than or equal to the stream size computed from the declaration.</p><p> Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetStreamSource']/*"/>	
        /// <msdn-id>bb174409</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetStreamSource([In] unsigned int StreamNumber,[Out] IDirect3DVertexBuffer9** ppStreamData,[Out] unsigned int* pOffsetInBytes,[Out] unsigned int* pStride)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetStreamSource</unmanaged-short>	
        public void GetStreamSource(int streamNumber, out SharpDX.Direct3D9.VertexBuffer streamDataOut, out int offsetInBytesRef, out int strideRef) {
            unsafe {
                IntPtr streamDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* offsetInBytesRef_ = &offsetInBytesRef)
                    fixed (void* strideRef_ = &strideRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, streamNumber, &streamDataOut_, offsetInBytesRef_, strideRef_,((void**)(*(void**)_nativePointer))[101]);		
                streamDataOut= (streamDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VertexBuffer(streamDataOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the stream source frequency divider value. This may be used to draw several instances of geometry.</p>	
        /// </summary>	
        /// <param name="streamNumber"><dd>  <p>Stream source number.</p> </dd></param>	
        /// <param name="setting"><dd>  <p>This parameter may have two different values. See remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>There are two constants defined in d3d9types.h that are designed to use with SetStreamSourceFreq: <see cref="SharpDX.Direct3D9.StreamSource.IndexedData"/> and <see cref="SharpDX.Direct3D9.StreamSource.InstanceData"/>. To see how to use the constants, see Efficiently Drawing Multiple Instances of Geometry (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetStreamSourceFreq']/*"/>	
        /// <msdn-id>bb174460</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetStreamSourceFreq([In] unsigned int StreamNumber,[In] unsigned int Setting)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetStreamSourceFreq</unmanaged-short>	
        internal void SetStreamSourceFrequency(int streamNumber, int setting) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, streamNumber, setting,((void**)(*(void**)_nativePointer))[102]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the stream source frequency divider value.</p>	
        /// </summary>	
        /// <param name="streamNumber"><dd>  <p>Stream source number.</p> </dd></param>	
        /// <param name="settingRef"><dd>  <p>Returns the frequency divider value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>Vertex shaders can now be invoked more than once per vertex. See Drawing Non-Indexed Geometry.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetStreamSourceFreq']/*"/>	
        /// <msdn-id>bb174410</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetStreamSourceFreq([In] unsigned int StreamNumber,[Out] unsigned int* pSetting)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetStreamSourceFreq</unmanaged-short>	
        public void GetStreamSourceFrequency(int streamNumber, out int settingRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* settingRef_ = &settingRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, streamNumber, settingRef_,((void**)(*(void**)_nativePointer))[103]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets index data.</p>	
        /// </summary>	
        /// <param name="indexDataRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface, representing the index data to be set. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>When an application no longer holds a references to this interface, the interface will automatically be freed.</p><p>The <strong><see cref="SharpDX.Direct3D9.Device.SetIndices"/></strong> method sets the current index array to an index buffer. The single set of indices is used to index all streams. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetIndices']/*"/>	
        /// <msdn-id>bb174435</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetIndices([In] IDirect3DIndexBuffer9* pIndexData)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetIndices</unmanaged-short>	
        internal void SetIndices(SharpDX.Direct3D9.IndexBuffer indexDataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((indexDataRef == null)?IntPtr.Zero:indexDataRef.NativePointer),((void**)(*(void**)_nativePointer))[104]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves index data.</p>	
        /// </summary>	
        /// <param name="indexDataOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface, representing the returned index data. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p> Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetIndices']/*"/>	
        /// <msdn-id>bb174391</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetIndices([Out] IDirect3DIndexBuffer9** ppIndexData)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetIndices</unmanaged-short>	
        internal void GetIndices(out SharpDX.Direct3D9.IndexBuffer indexDataOut) {
            unsafe {
                IntPtr indexDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &indexDataOut_,((void**)(*(void**)_nativePointer))[105]);		
                indexDataOut= (indexDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.IndexBuffer(indexDataOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a pixel shader.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the pixel shader function token array, specifying the blending operations. This value cannot be <strong><c>null</c></strong>. </p> </dd></param>	
        /// <param name="shaderOut"><dd>  <p>Pointer to the returned pixel shader interface. See <strong><see cref="SharpDX.Direct3D9.PixelShader"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreatePixelShader']/*"/>	
        /// <msdn-id>bb174359</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreatePixelShader([In] const void* pFunction,[Out, Fast] IDirect3DPixelShader9** ppShader)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreatePixelShader</unmanaged-short>	
        internal void CreatePixelShader(System.IntPtr functionRef, SharpDX.Direct3D9.PixelShader shaderOut) {
            unsafe {
                IntPtr shaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)functionRef, &shaderOut_,((void**)(*(void**)_nativePointer))[106]);		
                ((SharpDX.Direct3D9.PixelShader)shaderOut).NativePointer = shaderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the current pixel shader to a previously created pixel shader.</p>	
        /// </summary>	
        /// <param name="shaderRef"><dd>  <p>Pixel shader interface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetPixelShader']/*"/>	
        /// <msdn-id>bb174450</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShader([In] IDirect3DPixelShader9* pShader)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetPixelShader</unmanaged-short>	
        internal void SetPixelShader(SharpDX.Direct3D9.PixelShader shaderRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer),((void**)(*(void**)_nativePointer))[107]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the currently set pixel shader.</p>	
        /// </summary>	
        /// <param name="shaderOut"><dd>  <p>Pointer to a pixel shader interface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method will not work on a device that is created using <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetPixelShader']/*"/>	
        /// <msdn-id>bb174398</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShader([Out] IDirect3DPixelShader9** ppShader)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetPixelShader</unmanaged-short>	
        internal void GetPixelShader(out SharpDX.Direct3D9.PixelShader shaderOut) {
            unsafe {
                IntPtr shaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &shaderOut_,((void**)(*(void**)_nativePointer))[108]);		
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.PixelShader(shaderOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a floating-point shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4fCount"><dd>  <p>Number of four float vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetPixelShaderConstantF']/*"/>	
        /// <msdn-id>bb174452</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShaderConstantF([In] unsigned int StartRegister,[In] const void* pConstantData,[In] unsigned int Vector4fCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetPixelShaderConstantF</unmanaged-short>	
        internal void SetPixelShaderConstantF(int startRegister, System.IntPtr constantDataRef, int vector4fCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, vector4fCount,((void**)(*(void**)_nativePointer))[109]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a floating-point shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4fCount"><dd>  <p>Number of four float vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetPixelShaderConstantF']/*"/>	
        /// <msdn-id>bb174400</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShaderConstantF([In] unsigned int StartRegister,[In, Buffer] float* pConstantData,[In] unsigned int Vector4fCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetPixelShaderConstantF</unmanaged-short>	
        internal void GetPixelShaderConstantF(int startRegister, float[] constantDataRef, int vector4fCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* constantDataRef_ = constantDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, constantDataRef_, vector4fCount,((void**)(*(void**)_nativePointer))[110]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an integer shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4iCount"><dd>  <p>Number of four integer vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetPixelShaderConstantI']/*"/>	
        /// <msdn-id>bb174453</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShaderConstantI([In] unsigned int StartRegister,[In] const void* pConstantData,[In] unsigned int Vector4iCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetPixelShaderConstantI</unmanaged-short>	
        internal void SetPixelShaderConstantI(int startRegister, System.IntPtr constantDataRef, int vector4iCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, vector4iCount,((void**)(*(void**)_nativePointer))[111]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets an integer shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="vector4iCount"><dd>  <p>Number of four integer vectors in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetPixelShaderConstantI']/*"/>	
        /// <msdn-id>bb174401</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShaderConstantI([In] unsigned int StartRegister,[In, Buffer] int* pConstantData,[In] unsigned int Vector4iCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetPixelShaderConstantI</unmanaged-short>	
        internal void GetPixelShaderConstantI(int startRegister, int[] constantDataRef, int vector4iCount) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* constantDataRef_ = constantDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, constantDataRef_, vector4iCount,((void**)(*(void**)_nativePointer))[112]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a Boolean shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="boolCount"><dd>  <p>Number of boolean values in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::SetPixelShaderConstantB']/*"/>	
        /// <msdn-id>bb174451</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::SetPixelShaderConstantB([In] unsigned int StartRegister,[In] const void* pConstantData,[In] unsigned int BoolCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::SetPixelShaderConstantB</unmanaged-short>	
        internal void SetPixelShaderConstantB(int startRegister, System.IntPtr constantDataRef, int boolCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, boolCount,((void**)(*(void**)_nativePointer))[113]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a Boolean shader constant.</p>	
        /// </summary>	
        /// <param name="startRegister"><dd>  <p>Register number that will contain the first constant value.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>Pointer to an array of constants.</p> </dd></param>	
        /// <param name="boolCount"><dd>  <p>Number of Boolean values in the array of constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::GetPixelShaderConstantB']/*"/>	
        /// <msdn-id>bb174399</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::GetPixelShaderConstantB([In] unsigned int StartRegister,[In] void* pConstantData,[In] unsigned int BoolCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::GetPixelShaderConstantB</unmanaged-short>	
        internal void GetPixelShaderConstantB(int startRegister, System.IntPtr constantDataRef, int boolCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, startRegister, (void*)constantDataRef, boolCount,((void**)(*(void**)_nativePointer))[114]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Draws a rectangular patch using the currently set streams.</p>	
        /// </summary>	
        /// <param name="handle"><dd>  <p>Handle to the rectangular patch to draw. </p> </dd></param>	
        /// <param name="numSegsRef"><dd>  <p>Pointer to an array of four floating-point values that identify the number of segments each edge of the rectangle patch should be divided into when tessellated. See <strong><see cref="SharpDX.Direct3D9.RectanglePatchInfo"/></strong>. </p> </dd></param>	
        /// <param name="rectPatchInfoRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.RectanglePatchInfo"/></strong> structure, describing the rectangular patch to draw. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be  <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>For static patches: Set the vertex shader, set the appropriate streams, supply patch information in the pRectPatchInfo parameter, and specify a handle so that Direct3D can capture and cache information. Call <strong><see cref="SharpDX.Direct3D9.Device.DrawRectanglePatch"/></strong> subsequently with pRectPatchInfo set to <strong><c>null</c></strong> to efficiently draw the patch. When drawing a cached patch, the currently set streams are ignored. Override the cached pNumSegs by specifying a new value for pNumSegs. When rendering a cached patch, you must set the same vertex shader that was set when it was captured.</p><p>Calling <strong><see cref="SharpDX.Direct3D9.Device.DrawRectanglePatch"/></strong> with a handle invalidates the same handle cached by a previous <strong><see cref="SharpDX.Direct3D9.Device.DrawTrianglePatch"/></strong> call.</p><p>For dynamic patches, the patch data changes for every rendering of the patch, so it is not efficient to cache information. The application can convey this to Direct3D by setting Handle to 0. In this case, Direct3D draws the patch using the currently set streams and the pNumSegs values, and does not cache any information. It is not valid to simultaneously set Handle to 0 and pRectPatchInfo to <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::DrawRectPatch']/*"/>	
        /// <msdn-id>bb174373</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawRectPatch([In] unsigned int Handle,[In, Buffer] const float* pNumSegs,[In] const void* pRectPatchInfo)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::DrawRectPatch</unmanaged-short>	
        internal void DrawRectanglePatch(int handle, float[] numSegsRef, System.IntPtr rectPatchInfoRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* numSegsRef_ = numSegsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, handle, numSegsRef_, (void*)rectPatchInfoRef,((void**)(*(void**)_nativePointer))[115]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Draws a triangular patch using the currently set streams.</p>	
        /// </summary>	
        /// <param name="handle"><dd>  <p>Handle to the triangular patch to draw. </p> </dd></param>	
        /// <param name="numSegsRef"><dd>  <p>Pointer to an array of three floating-point values that identify the number of segments each edge of the triangle patch should be divided into when tessellated. See <strong><see cref="SharpDX.Direct3D9.TrianglePatchInfo"/></strong>. </p> </dd></param>	
        /// <param name="triPatchInfoRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.TrianglePatchInfo"/></strong> structure, describing the triangular high-order patch to draw. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be  <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>For static patches: Set the vertex shader, set the appropriate streams, supply patch information in the pTriPatchInfo parameter, and specify a handle so that Direct3D can capture and cache information. To efficiently draw the patch, call <strong><see cref="SharpDX.Direct3D9.Device.DrawTrianglePatch"/></strong> with pTriPatchInfo set to <strong><c>null</c></strong>. When drawing a cached patch, the currently set streams are ignored. Override the cached pNumSegs by specifying a new value for pNumSegs. When rendering a cached patch, you must set the same vertex shader that was set when it was captured.</p><p>Calling <strong><see cref="SharpDX.Direct3D9.Device.DrawTrianglePatch"/></strong> with a handle invalidates the same handle cached by a previous <strong><see cref="SharpDX.Direct3D9.Device.DrawRectanglePatch"/></strong> call.</p><p>For dynamic patches, the patch data changes for every rendering of the patch so it is not efficient to cache information. The application can convey this to Direct3D by setting Handle to 0. In this case, Direct3D draws the patch using the currently set streams and the pNumSegs values, and does not cache any information. It is not valid to simultaneously set Handle to 0 and pTriPatchInfo to <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::DrawTriPatch']/*"/>	
        /// <msdn-id>bb174374</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::DrawTriPatch([In] unsigned int Handle,[In, Buffer] const float* pNumSegs,[In] const void* pTriPatchInfo)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::DrawTriPatch</unmanaged-short>	
        internal void DrawTrianglePatch(int handle, float[] numSegsRef, System.IntPtr triPatchInfoRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* numSegsRef_ = numSegsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, handle, numSegsRef_, (void*)triPatchInfoRef,((void**)(*(void**)_nativePointer))[116]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Frees a cached high-order patch.</p>	
        /// </summary>	
        /// <param name="handle"><dd>  <p>Handle of the cached high-order patch to delete. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be  <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::DeletePatch']/*"/>	
        /// <msdn-id>bb174368</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::DeletePatch([In] unsigned int Handle)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::DeletePatch</unmanaged-short>	
        public void DeletePatch(int handle) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, handle,((void**)(*(void**)_nativePointer))[117]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a status query.</p>	
        /// </summary>	
        /// <param name="type"><dd>  <p>Identifies the query type. For more information, see <strong><see cref="SharpDX.Direct3D9.QueryType"/></strong>.</p> </dd></param>	
        /// <param name="queryOut"><dd>  <p>Returns a reference to the query interface that manages the query object. See <strong><see cref="SharpDX.Direct3D9.Query"/></strong>. </p> <p>This parameter can be set to <strong><c>null</c></strong> to see if a query is supported. If the query is not supported, the method returns <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/> or  E_OUTOFMEMORY. </p></returns>	
        /// <remarks>	
        /// <p>This method is provided for both synchronous and asynchronous queries. It takes the place of GetInfo, which is no longer supported in Direct3D 9.</p><p>Synchronous and asynchronous queries are created with <strong><see cref="SharpDX.Direct3D9.Device.CreateQuery"/></strong> with <strong><see cref="SharpDX.Direct3D9.QueryType"/></strong>. When a query has been created and the API calls have been made that are being queried, use <strong><see cref="SharpDX.Direct3D9.Query.Issue"/></strong> to issue a query and  <strong><see cref="SharpDX.Direct3D9.Query.GetData"/></strong> to get the results of the query.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9::CreateQuery']/*"/>	
        /// <msdn-id>bb174360</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9::CreateQuery([In] D3DQUERYTYPE Type,[Out, Fast] IDirect3DQuery9** ppQuery)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9::CreateQuery</unmanaged-short>	
        internal void CreateQuery(SharpDX.Direct3D9.QueryType type, SharpDX.Direct3D9.Query queryOut) {
            unsafe {
                IntPtr queryOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)type), &queryOut_,((void**)(*(void**)_nativePointer))[118]);		
                ((SharpDX.Direct3D9.Query)queryOut).NativePointer = queryOut_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.DeviceEx"/> interface to render primitives, create resources, work with system-level variables, adjust gamma ramp levels, work with palettes, and create shaders. The <see cref="SharpDX.Direct3D9.DeviceEx"/> interface derives from the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.DeviceEx"/></strong> interface is obtained by calling <strong><see cref="SharpDX.Direct3D9.Direct3DEx.CreateDeviceEx"/></strong>.</p><p>The LPDIRECT3DDEVICE9EX and PDIRECT3DDEVICE9EX types are defined as references to the <see cref="SharpDX.Direct3D9.DeviceEx"/> interface:</p><p> </p><pre> typedef struct <see cref="SharpDX.Direct3D9.DeviceEx"/> *LPDIRECT3DDEVICE9EX, *PDIRECT3DDEVICE9EX;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex']/*"/>	
    /// <msdn-id>bb174337</msdn-id>	
    /// <unmanaged>IDirect3DDevice9Ex</unmanaged>	
    /// <unmanaged-short>IDirect3DDevice9Ex</unmanaged-short>	
    [Guid("B18B10CE-2649-405a-870F-95F777D4313A")]
    public partial class DeviceEx : SharpDX.Direct3D9.Device {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.DeviceEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceEx(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.DeviceEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.DeviceEx(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.DeviceEx(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get or sets the priority of the GPU thread.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Use <strong><see cref="SharpDX.Direct3D9.DeviceEx.SetGPUThreadPriority"/></strong> to set the priority of a thread.</p><p>This method will retrieve the priority of the thread stored with the Direct3D device even if it was created with the <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/> flag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::GetGPUThreadPriority']/*"/>	
        /// <msdn-id>bb174341</msdn-id>	
        /// <unmanaged>GetGPUThreadPriority / SetGPUThreadPriority</unmanaged>	
        /// <unmanaged-short>GetGPUThreadPriority</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetGPUThreadPriority([Out] int* pPriority)</unmanaged>
        public int GPUThreadPriority {
                get { int __output__; GetGPUThreadPriority(out __output__); return __output__; }
                set { SetGPUThreadPriority(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves or sets the number of frames of data that the system is allowed to queue.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue.</p><p>It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::GetMaximumFrameLatency']/*"/>	
        /// <msdn-id>bb174342</msdn-id>	
        /// <unmanaged>GetMaximumFrameLatency / SetMaximumFrameLatency</unmanaged>	
        /// <unmanaged-short>GetMaximumFrameLatency</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetMaximumFrameLatency([Out] unsigned int* pMaxLatency)</unmanaged>
        public int MaximumFrameLatency {
                get { int __output__; GetMaximumFrameLatency(out __output__); return __output__; }
                set { SetMaximumFrameLatency(value); }
        }
        
        /// <summary>	
        /// <p>Prepare the texture sampler for monochrome convolution filtering on a single-color texture.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>The width of the filter kernel; ranging from 1 - <strong>D3DCONVOLUTIONMONO_MAXWIDTH</strong>. The default value is 1.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The height of the filter kernel; ranging from 1 - <strong>D3DCONVOLUTIONMONO_MAXHEIGHT</strong>. The default value is 1.</p> </dd></param>	
        /// <param name="rows"><dd>  <p>An array of weights, one weight for each kernel sub-element in the width. This parameter must be <strong><c>null</c></strong>, which will set the weights equal to the default value.</p> </dd></param>	
        /// <param name="columns"><dd>  <p>An array of weights, one weight for each kernel sub-element in the height. This parameter must be <strong><c>null</c></strong>, which will set the weights equal to the default value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is designed to filter a single color texture. A monochrome convolution filter is a 2D box filter with all of the weights set to 1.0;  the filter kernel resolution ranges from 1 x 1 to 7 x 7. When monochrome texture filtering is set to a texture sampler and texture sampling is performed at location, then Direct3D performs convolution. </p><p>Restrictions include:</p><ul> <li>The filter specified by this method is recorded in state blocks as a part of <strong><see cref="SharpDX.Direct3D9.StateBlockType.PixelState"/></strong>.</li> <li>The only texture address mode supported is: <see cref="SharpDX.Direct3D9.TextureAddressCaps.Border"/>; the border color is always 0.</li> <li>This method is not supported for mipmaps.</li> <li>Using a non-monochrome texture with convolution filtering will generate a driver error.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::SetConvolutionMonoKernel']/*"/>	
        /// <msdn-id>bb174345</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::SetConvolutionMonoKernel([In] unsigned int width,[In] unsigned int height,[In, Buffer] float* rows,[In, Buffer] float* columns)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::SetConvolutionMonoKernel</unmanaged-short>	
        public void SetConvolutionMonoKernel(int width, int height, float[] rows, float[] columns) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* rows_ = rows)
                    fixed (void* columns_ = columns)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, width, height, rows_, columns_,((void**)(*(void**)_nativePointer))[119]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Copy a text string to one surface using an alphabet of glyphs on another surface. Composition is done by the GPU using bitwise operations.</p>	
        /// </summary>	
        /// <param name="srcRef"><dd>  <p>A reference to a source surface (prepared by <strong><see cref="SharpDX.Direct3D9.Surface"/></strong>) that supplies the alphabet glyphs. This surface must be created with the <strong><see cref="SharpDX.Direct3D9.Usage.TextApi"/></strong> flag.</p> </dd></param>	
        /// <param name="dstRef"><dd>  <p>A reference to the destination surface (prepared by <strong><see cref="SharpDX.Direct3D9.Surface"/></strong>) that receives the glyph data. The surface must be part of a texture.</p> </dd></param>	
        /// <param name="srcRectDescsRef"><dd>  <p>A reference to a vertex buffer (see <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong>) containing rectangles (see <strong>D3DCOMPOSERECTDESC</strong>) that enclose the desired glyphs in the source surface.</p> </dd></param>	
        /// <param name="numRects"><dd>  <p>The number of rectangles or glyphs that are used in the operation. The number applies to both the source and destination surfaces. The range is 0 to <strong>D3DCOMPOSERECTS_MAXNUMRECTS</strong>.</p> </dd></param>	
        /// <param name="dstRectDescsRef"><dd>  <p>A reference to a vertex buffer (see <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong>) containing rectangles (see <strong>D3DCOMPOSERECTDESTINATION</strong>) that describe the destination to which the indicated glyph from the source surface will be copied.</p> </dd></param>	
        /// <param name="operation"><dd>  <p>Specifies how to combine the source and destination surfaces. See <strong><see cref="SharpDX.Direct3D9.ComposeRectOperation"/></strong>.</p> </dd></param>	
        /// <param name="xoffset"><dd>  <p>A value added to the <em>x</em> coordinates of all destination rectangles. This value can be negative, which may cause the glyph to be rejected or clipped if the result is beyond the bounds of the surface.</p> </dd></param>	
        /// <param name="yoffset"><dd>  <p>A value added to the <em>y</em> coordinates of all destination rectangles. This value can be negative, which may cause the glyph to be rejected or clipped if the result is beyond the bounds of the surface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p></returns>	
        /// <remarks>	
        /// <p>Glyphs from a one-bit source surface are put together into another one-bit texture surface with this method. The destination surface can then be used as the source for a normal texturing operation that will filter and scale the strings of text onto some other non-monochrome surface.</p><p>This method has several constraints (which are similar to <strong>StretchRect</strong>):</p><ul> <li>Surfaces cannot be locked.</li> <li>The source and destination surfaces cannot be the same surface.</li> <li>The source and destination surfaces must be created with the <see cref="SharpDX.Direct3D9.Format.A1"/> format.</li> <li>The source surface and both vertex buffers must be created with the <strong><see cref="SharpDX.Direct3D9.Pool.Default"/></strong> flag.</li> <li>The destination surface must be created with either the <strong><see cref="SharpDX.Direct3D9.Pool.Default"/></strong> or <strong><see cref="SharpDX.Direct3D9.Pool.SystemMemory"/></strong> flags.</li> <li>The source rectangles must be within the source surface.</li> </ul><p>The method is not recorded in state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::ComposeRects']/*"/>	
        /// <msdn-id>bb174340</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::ComposeRects([In] IDirect3DSurface9* pSrc,[In] IDirect3DSurface9* pDst,[In] IDirect3DVertexBuffer9* pSrcRectDescs,[In] unsigned int NumRects,[In] IDirect3DVertexBuffer9* pDstRectDescs,[In] D3DCOMPOSERECTSOP Operation,[In] int Xoffset,[In] int Yoffset)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::ComposeRects</unmanaged-short>	
        public void ComposeRects(SharpDX.Direct3D9.Surface srcRef, SharpDX.Direct3D9.Surface dstRef, SharpDX.Direct3D9.VertexBuffer srcRectDescsRef, int numRects, SharpDX.Direct3D9.VertexBuffer dstRectDescsRef, SharpDX.Direct3D9.ComposeRectOperation operation, int xoffset, int yoffset) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((srcRef == null)?IntPtr.Zero:srcRef.NativePointer), (void*)((dstRef == null)?IntPtr.Zero:dstRef.NativePointer), (void*)((srcRectDescsRef == null)?IntPtr.Zero:srcRectDescsRef.NativePointer), numRects, (void*)((dstRectDescsRef == null)?IntPtr.Zero:dstRectDescsRef.NativePointer), unchecked((int)operation), xoffset, yoffset,((void**)(*(void**)_nativePointer))[120]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Swap the swapchain's next buffer with the front buffer.</p>	
        /// </summary>	
        /// <param name="sourceRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure indicating region on the source surface to copy in window client coordinates. Only applies when the swapchain was created with the <strong><see cref="SharpDX.Direct3D9.SwapEffect.Copy"/></strong> flag. If <strong><c>null</c></strong>, the entire source surface is presented. If the rectangle exceeds the source surface, it is clipped to the source surface.</p> </dd></param>	
        /// <param name="destRectRef"><dd>  <p>Pointer to <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure indicating the target region on the destination surface in window client coordinates. Only applies when the swapchain was created with the <strong><see cref="SharpDX.Direct3D9.SwapEffect.Copy"/></strong> flag. If <strong><c>null</c></strong>, the entire client area is filled. If the rectangle exceeds the destination client area, it is clipped to the destination client area.</p> </dd></param>	
        /// <param name="hDestWindowOverride"><dd>  <p>Pointer to a destination window whose client area is taken as the target for this presentation. If this value is <strong><c>null</c></strong>, the runtime uses the <strong>hDeviceWindow</strong> member of <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> for the presentation.</p> <p><strong>Note</strong>??If you create a swap chain with <see cref="SharpDX.Direct3D9.SwapEffect.FlipEx"/>, you must pass <strong><c>null</c></strong> to <em>hDestWindowOverride</em></p> </dd></param>	
        /// <param name="dirtyRegionRef"><dd>  <p>Pointer to a <strong><see cref="System.IntPtr"/></strong> structure indicating the smallest set of pixels that need to be transferred. This value must be <strong><c>null</c></strong> unless the swapchain was created with the <strong><see cref="SharpDX.Direct3D9.SwapEffect.Copy"/></strong> flag. For more information about swapchains, see Flipping Surfaces (Direct3D 9).</p> <p>If this value is non-<strong><c>null</c></strong>, the contained region is expressed in back buffer coordinates. The method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation can choose to copy the whole source rectangle.</p> </dd></param>	
        /// <param name="dwFlags"><dd>  <p>Allows the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. Valid values are 0, or any combination of <see cref="SharpDX.Direct3D9.Present"/> flags. </p> <ul> <li>If dwFlags = 0, this method behaves as it did prior to Direct3D 9. Present will spin until the hardware is free, without returning an error.</li> <li>If dwFlags = <see cref="SharpDX.Direct3D9.Present.DoNotFlip"/> the display driver is called with the front buffer as both the source and target surface. The driver responds by scheduling a frame synch, but not changing the displayed surface. This flag is only available in full-screen mode or when using <see cref="SharpDX.Direct3D9.SwapEffect.FlipEx"/> in windowed mode.</li> <li>If dwFlags = <see cref="SharpDX.Direct3D9.Present.DoNotWait"/>, and the hardware is busy processing or waiting for a vertical sync interval, the method will return <see cref="SharpDX.Direct3D9.ResultCode.WasStillDrawing"/>.</li> <li>If dwFlags = <see cref="SharpDX.Direct3D9.Present.ForceImmediate"/>, <see cref="SharpDX.Direct3D9.PresentInterval.Immediate"/> is enforced on this Present call. This flag can only be specified when using <see cref="SharpDX.Direct3D9.SwapEffect.FlipEx"/>. This behavior is the same for windowed and full-screen modes.</li> <li>If dwFlags = <see cref="SharpDX.Direct3D9.Present.LinearContent"/>, gamma correction is performed from linear space to sRGB for windowed swap chains. This flag will take effect only when the driver exposes <see cref="SharpDX.Direct3D9.Caps3.LinearToSrgbPresentation"/> (see Gamma (Direct3D 9)).</li> </ul> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Result.Ok"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceHung"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/>, or <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/> (see <strong>D3DERR</strong>). See Lost Device Behavior Changes for more information about lost, hung, and removed devices.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 9Ex:</p> <p><strong><see cref="SharpDX.Direct3D9.SwapEffect.FlipEx"/></strong> is only available in Direct3D9Ex running on Windows 7 (or more current operating system).</p> </td></tr> </table><p>?</p></returns>	
        /// <remarks>	
        /// <p>Similar to the <strong><see cref="SharpDX.Direct3D9.Device.Present"/></strong> Method, PresentEx adds a dwflags parameter.</p><p>When the swapchain is created with <strong><see cref="SharpDX.Direct3D9.SwapEffect.FlipEx"/></strong> flag, <strong>pSourceRect</strong>, <strong>pDestRect</strong> and <strong>pDirtyRegion</strong> values must be set to <strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::PresentEx']/*"/>	
        /// <msdn-id>bb174343</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::PresentEx([In] const void* pSourceRect,[In] const void* pDestRect,[In] HWND hDestWindowOverride,[In] const RGNDATA* pDirtyRegion,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::PresentEx</unmanaged-short>	
        internal void PresentEx(System.IntPtr sourceRectRef, System.IntPtr destRectRef, System.IntPtr hDestWindowOverride, System.IntPtr dirtyRegionRef, int dwFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)sourceRectRef, (void*)destRectRef, (void*)hDestWindowOverride, (void*)dirtyRegionRef, dwFlags,((void**)(*(void**)_nativePointer))[121]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the priority of the GPU thread.</p>	
        /// </summary>	
        /// <param name="priorityRef"><dd>  <p>Current GPU priority. Valid values range from -7 to 7.</p> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Direct3D9.ResultCode.Success"/> or <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/> (see D3DERR).</p></returns>	
        /// <remarks>	
        /// <p>Use <strong><see cref="SharpDX.Direct3D9.DeviceEx.SetGPUThreadPriority"/></strong> to set the priority of a thread.</p><p>This method will retrieve the priority of the thread stored with the Direct3D device even if it was created with the <see cref="SharpDX.Direct3D9.CreateFlags.PureDevice"/> flag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::GetGPUThreadPriority']/*"/>	
        /// <msdn-id>bb174341</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetGPUThreadPriority([Out] int* pPriority)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::GetGPUThreadPriority</unmanaged-short>	
        internal void GetGPUThreadPriority(out int priorityRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* priorityRef_ = &priorityRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, priorityRef_,((void**)(*(void**)_nativePointer))[122]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set the priority on the GPU thread.</p>	
        /// </summary>	
        /// <param name="priority"><dd>  <p>The thread priority, ranging from -7 to 7.</p> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Direct3D9.ResultCode.Success"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, or <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/> (see D3DERR).</p></returns>	
        /// <remarks>	
        /// <p>GPU thread priority is not reset when a device is lost. The effects of calls to this method are not recorded in state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::SetGPUThreadPriority']/*"/>	
        /// <msdn-id>bb174346</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::SetGPUThreadPriority([In] int Priority)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::SetGPUThreadPriority</unmanaged-short>	
        internal void SetGPUThreadPriority(int priority) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, priority,((void**)(*(void**)_nativePointer))[123]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Suspend execution of the calling thread until the next vertical blank signal.</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>Swap chain index. This is an optional, zero-based index used to specify a swap chain on a multihead card.</p> </dd></param>	
        /// <returns><p>This method will always return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method allows applications to efficiently throttle their frame rate to that of the monitor associated with the device. Following a vertical blank, the amount of time it takes for the thread to wake up is typically very short.</p><p>In some scenarios the hardware may stop generating vertical blank signals when nothing is being displayed on the monitor. In this case, the method will wait approximately 100ms and return with <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::WaitForVBlank']/*"/>	
        /// <msdn-id>bb174349</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::WaitForVBlank([In] unsigned int iSwapChain)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::WaitForVBlank</unmanaged-short>	
        public void WaitForVBlank(int iSwapChain) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iSwapChain,((void**)(*(void**)_nativePointer))[124]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Checks an array of resources to determine if it is likely that they will cause a large stall at Draw time because the system must make the resources GPU-accessible.</p>	
        /// </summary>	
        /// <param name="resourceArrayRef"><dd>  <p>An array of <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> references that indicate the resources to check.</p> </dd></param>	
        /// <param name="numResources"><dd>  <p>A value indicating the number of resources passed into the <em>pResourceArray</em> parameter up to a maximum of 65535.</p> </dd></param>	
        /// <returns><p>If all the resources are in GPU-accessible memory, the method will return <see cref="SharpDX.Result.Ok"/>. The system may need to perform a remapping operation to promote the resources, but will not have to copy data.</p><p> If no allocation that comprises the resources is on disk, but at least one allocation is not in GPU-accessible memory, the method will return <see cref="SharpDX.Direct3D9.ResultCode.ResidentInSharedMemory"/>. The system may need to perform a copy to promote the resource.</p><p> If at least one allocation that comprises the resources is on disk, this method will return S_NOT_RESIDENT.  The system may need to perform a copy to promote the resource.</p></returns>	
        /// <remarks>	
        /// <p>This API is no more than a reasonable guess at residency, since resources may have been demoted by the time the application uses them.</p><p>The expected usage pattern is as follows. If the application determines that a set of resources are not resident, then the application will substitute a lower-LOD version of the resource and continue with rendering. The video memory manager API, offers a feature to allow the application to express that it would like these lower-LOD resources to be made more likely to stay resident in GPU-accessible memory. It is the app's responsibility to create, fill and destroy these lower-LOD versions, if it so chooses.</p><p>The application also needs to begin promotion of the higher-LOD versions when the residency check indicates that the resource is not resident in GPU-accessible memory. Since a per-process lock exists in kernel mode, a performant implementation will spawn a separate process whose sole job is to promote resources. The application communicates resource identity between the two process by means of the Sharing Resources shared surfaces API and promotes them by means of the <strong>SetPriority</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::CheckResourceResidency']/*"/>	
        /// <msdn-id>bb174339</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CheckResourceResidency([In, Buffer] IDirect3DResource9** pResourceArray,[In] unsigned int NumResources)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::CheckResourceResidency</unmanaged-short>	
        internal SharpDX.Result CheckResourceResidency(SharpDX.Direct3D9.Resource[] resourceArrayRef, int numResources) {
            unsafe {
                IntPtr* resourceArrayRef_ = (IntPtr*)0;
                if ( resourceArrayRef != null ) {
                    IntPtr* resourceArrayRef__ = stackalloc IntPtr[resourceArrayRef.Length];
                    resourceArrayRef_ = resourceArrayRef__;
                    for (int i = 0; i < resourceArrayRef.Length; i++)                        
                        resourceArrayRef_[i] =  (resourceArrayRef[i] == null)? IntPtr.Zero : resourceArrayRef[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, resourceArrayRef_, numResources,((void**)(*(void**)_nativePointer))[125]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Checks an array of resources to determine if it is likely that they will cause a large stall at Draw time because the system must make the resources GPU-accessible.</p>	
        /// </summary>	
        /// <param name="resourceArrayRef"><dd>  <p>An array of <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> references that indicate the resources to check.</p> </dd></param>	
        /// <param name="numResources"><dd>  <p>A value indicating the number of resources passed into the <em>pResourceArray</em> parameter up to a maximum of 65535.</p> </dd></param>	
        /// <returns><p>If all the resources are in GPU-accessible memory, the method will return <see cref="SharpDX.Result.Ok"/>. The system may need to perform a remapping operation to promote the resources, but will not have to copy data.</p><p> If no allocation that comprises the resources is on disk, but at least one allocation is not in GPU-accessible memory, the method will return <see cref="SharpDX.Direct3D9.ResultCode.ResidentInSharedMemory"/>. The system may need to perform a copy to promote the resource.</p><p> If at least one allocation that comprises the resources is on disk, this method will return S_NOT_RESIDENT.  The system may need to perform a copy to promote the resource.</p></returns>	
        /// <remarks>	
        /// <p>This API is no more than a reasonable guess at residency, since resources may have been demoted by the time the application uses them.</p><p>The expected usage pattern is as follows. If the application determines that a set of resources are not resident, then the application will substitute a lower-LOD version of the resource and continue with rendering. The video memory manager API, offers a feature to allow the application to express that it would like these lower-LOD resources to be made more likely to stay resident in GPU-accessible memory. It is the app's responsibility to create, fill and destroy these lower-LOD versions, if it so chooses.</p><p>The application also needs to begin promotion of the higher-LOD versions when the residency check indicates that the resource is not resident in GPU-accessible memory. Since a per-process lock exists in kernel mode, a performant implementation will spawn a separate process whose sole job is to promote resources. The application communicates resource identity between the two process by means of the Sharing Resources shared surfaces API and promotes them by means of the <strong>SetPriority</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::CheckResourceResidency']/*"/>	
        /// <msdn-id>bb174339</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CheckResourceResidency([In, Buffer] IDirect3DResource9** pResourceArray,[In] unsigned int NumResources)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::CheckResourceResidency</unmanaged-short>	
        internal SharpDX.Result CheckResourceResidency(SharpDX.ComArray<SharpDX.Direct3D9.Resource> resourceArrayRef, int numResources) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((resourceArrayRef == null)?IntPtr.Zero:resourceArrayRef.NativePointer), numResources,((void**)(*(void**)_nativePointer))[125]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Checks an array of resources to determine if it is likely that they will cause a large stall at Draw time because the system must make the resources GPU-accessible.</p>	
        /// </summary>	
        /// <param name="resourceArrayRef"><dd>  <p>An array of <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> references that indicate the resources to check.</p> </dd></param>	
        /// <param name="numResources"><dd>  <p>A value indicating the number of resources passed into the <em>pResourceArray</em> parameter up to a maximum of 65535.</p> </dd></param>	
        /// <returns><p>If all the resources are in GPU-accessible memory, the method will return <see cref="SharpDX.Result.Ok"/>. The system may need to perform a remapping operation to promote the resources, but will not have to copy data.</p><p> If no allocation that comprises the resources is on disk, but at least one allocation is not in GPU-accessible memory, the method will return <see cref="SharpDX.Direct3D9.ResultCode.ResidentInSharedMemory"/>. The system may need to perform a copy to promote the resource.</p><p> If at least one allocation that comprises the resources is on disk, this method will return S_NOT_RESIDENT.  The system may need to perform a copy to promote the resource.</p></returns>	
        /// <remarks>	
        /// <p>This API is no more than a reasonable guess at residency, since resources may have been demoted by the time the application uses them.</p><p>The expected usage pattern is as follows. If the application determines that a set of resources are not resident, then the application will substitute a lower-LOD version of the resource and continue with rendering. The video memory manager API, offers a feature to allow the application to express that it would like these lower-LOD resources to be made more likely to stay resident in GPU-accessible memory. It is the app's responsibility to create, fill and destroy these lower-LOD versions, if it so chooses.</p><p>The application also needs to begin promotion of the higher-LOD versions when the residency check indicates that the resource is not resident in GPU-accessible memory. Since a per-process lock exists in kernel mode, a performant implementation will spawn a separate process whose sole job is to promote resources. The application communicates resource identity between the two process by means of the Sharing Resources shared surfaces API and promotes them by means of the <strong>SetPriority</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::CheckResourceResidency']/*"/>	
        /// <msdn-id>bb174339</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CheckResourceResidency([In, Buffer] IDirect3DResource9** pResourceArray,[In] unsigned int NumResources)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::CheckResourceResidency</unmanaged-short>	
        private SharpDX.Result CheckResourceResidency(System.IntPtr resourceArrayRef, int numResources) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)resourceArrayRef, numResources,((void**)(*(void**)_nativePointer))[125]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set the number of frames that the system is allowed to queue for rendering.</p>	
        /// </summary>	
        /// <param name="maxLatency"><dd>  <p>The maximum number of back buffer frames that a driver can queue. The value is typically 3, but can range from 1 to 20. A value of 0 will reset latency to the default. For multi-head devices, <em>MaxLatency</em> is specified per-head.</p> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Direct3D9.ResultCode.Success"/> or <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/> (see D3DERR).</p></returns>	
        /// <remarks>	
        /// <p>Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue.</p><p>It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::SetMaximumFrameLatency']/*"/>	
        /// <msdn-id>bb174347</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::SetMaximumFrameLatency([In] unsigned int MaxLatency)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::SetMaximumFrameLatency</unmanaged-short>	
        internal void SetMaximumFrameLatency(int maxLatency) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, maxLatency,((void**)(*(void**)_nativePointer))[126]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of frames of data that the system is allowed to queue.</p>	
        /// </summary>	
        /// <param name="maxLatencyRef"><dd>  <p>Returns the number of frames that can be queued for render. The value is typically 3, but can range from 1 to 20.</p> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Direct3D9.ResultCode.Success"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/>, <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, or <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/> (see D3DERR).</p></returns>	
        /// <remarks>	
        /// <p>Frame latency is the number of frames that are allowed to be stored in a queue, before submission for rendering. Latency is often used to control how the CPU chooses between responding to user input and frames that are in the render queue.</p><p>It is often beneficial for applications that have no user input (for example, video playback) to queue more than 3 frames of data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::GetMaximumFrameLatency']/*"/>	
        /// <msdn-id>bb174342</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetMaximumFrameLatency([Out] unsigned int* pMaxLatency)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::GetMaximumFrameLatency</unmanaged-short>	
        internal void GetMaximumFrameLatency(out int maxLatencyRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* maxLatencyRef_ = &maxLatencyRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, maxLatencyRef_,((void**)(*(void**)_nativePointer))[127]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.</p>	
        /// </summary>	
        /// <param name="hDestinationWindow"><dd>  <p>The destination window handle to check for occlusion. When this parameter is <strong><c>null</c></strong>, <see cref="SharpDX.Direct3D9.ResultCode.PresentOccluded"/> is returned when another device has fullscreen ownership. When the window handle is not <strong><c>null</c></strong>, window's client area is checked for occlusion. A window is occluded if any part of it is obscured by another application.</p> </dd></param>	
        /// <returns><p>Possible return values include: <see cref="SharpDX.Direct3D9.ResultCode.Success"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceHung"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceRemoved"/>, or <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/> (see D3DERR), or <see cref="SharpDX.Direct3D9.ResultCode.PresentModeChanged"/>, or <see cref="SharpDX.Direct3D9.ResultCode.PresentOccluded"/> (see S_PRESENT).</p></returns>	
        /// <remarks>	
        /// <p>This method replaces <strong><see cref="SharpDX.Direct3D9.Device.TestCooperativeLevel"/></strong>, which always returns <see cref="SharpDX.Result.Ok"/> in Direct3D 9Ex applications.</p><p>We recommend not to call <strong>CheckDeviceState</strong> every frame. Instead, call <strong>CheckDeviceState</strong> only if the <strong><see cref="SharpDX.Direct3D9.DeviceEx.PresentEx"/></strong> method returns a failure code.</p><p>See Lost Device Behavior Changes for more information about lost, hung, and removed devices.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::CheckDeviceState']/*"/>	
        /// <msdn-id>bb174338</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CheckDeviceState([In] HWND hDestinationWindow)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::CheckDeviceState</unmanaged-short>	
        internal SharpDX.Result CheckDeviceState_(System.IntPtr hDestinationWindow) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)hDestinationWindow,((void**)(*(void**)_nativePointer))[128]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Creates a render-target surface.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the render-target surface, in pixels. </p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the render-target surface, in pixels. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of the render target. </p> </dd></param>	
        /// <param name="multiSample"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.MultisampleType"/></strong> enumerated type, which describes the multisampling buffer type. This parameter specifies the antialiasing type for this render target. When this surface is passed to <strong><see cref="SharpDX.Direct3D9.Device.SetRenderTarget"/></strong>, its multisample type must be the same as that of the depth-stencil set by <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong>. </p> </dd></param>	
        /// <param name="multisampleQuality"><dd>  <p>Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceMultiSampleType_"/></strong>. Passing a larger value returns the error, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the multisample type must all match.</p> </dd></param>	
        /// <param name="lockable"><dd>  <p>Render targets are not lockable unless the application specifies <strong>TRUE</strong> for Lockable.</p> <p>Note that lockable render targets reduce performance on some graphics hardware. The readback performance (moving data from video memory to system memory) depends on the type of hardware used (AGP vs. PCI Express) and is usually far lower than upload performance (moving data from system to video memory). If you need read access to render targets, use <strong>GetRenderTargetData</strong> instead of lockable render targets.</p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>Combination of one or more <strong><see cref="SharpDX.Direct3D9.Usage"/></strong> constants which can be OR'd together. Value of 0 indicates no usage.</p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Render-target surfaces are placed in the <see cref="SharpDX.Direct3D9.Pool.Default"/> memory class.</p><p>The creation of lockable, multisampled render targets is not supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::CreateRenderTargetEx']/*"/>	
        /// <msdn-id>bb509713</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CreateRenderTargetEx([In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] D3DMULTISAMPLE_TYPE MultiSample,[In] unsigned int MultisampleQuality,[In] BOOL Lockable,[Out] IDirect3DSurface9** ppSurface,[In] void** pSharedHandle,[In] unsigned int Usage)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::CreateRenderTargetEx</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface CreateRenderTargetEx(int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.MultisampleType multiSample, int multisampleQuality, SharpDX.Mathematics.Interop.RawBool lockable, System.IntPtr sharedHandleRef, int usage) {
            unsafe {
                SharpDX.Direct3D9.Surface surfaceOut;
                IntPtr surfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint55(_nativePointer, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, lockable, &surfaceOut_, (void*)sharedHandleRef, usage,((void**)(*(void**)_nativePointer))[129]);		
                surfaceOut= (surfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceOut_);	
                __result__.CheckError();
                return surfaceOut;
            }
        }
        
        /// <summary>	
        /// <p>Create an off-screen surface.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the surface.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the surface.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Format of the surface. See <see cref="SharpDX.Direct3D9.Format"/>. </p> </dd></param>	
        /// <param name="pool"><dd>  <p>Surface pool type. See <strong><see cref="SharpDX.Direct3D9.Pool"/></strong>.</p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>Combination of one or more <strong><see cref="SharpDX.Direct3D9.Usage"/></strong> constants which can be OR'd together. Value of 0 indicates no usage.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface created.</p> </dd></returns>	
        /// <remarks>	
        /// <p><see cref="SharpDX.Direct3D9.Pool.Scratch"/> will return a surface that has identical characteristics to a surface created by the DirectX 8.x method CreateImageSurface.</p><p><see cref="SharpDX.Direct3D9.Pool.Default"/> is the appropriate pool for use with the <strong><see cref="SharpDX.Direct3D9.Device.StretchRectangle"/></strong> and <strong><see cref="SharpDX.Direct3D9.Device.ColorFill"/></strong>.</p><p><see cref="SharpDX.Direct3D9.Pool.Managed"/> is not allowed when creating an offscreen plain surface. For more information about memory pools, see <strong><see cref="SharpDX.Direct3D9.Pool"/></strong>.</p><p>Off-screen plain surfaces are always lockable, regardless of their pool types.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::CreateOffscreenPlainSurfaceEx']/*"/>	
        /// <msdn-id>bb509712</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CreateOffscreenPlainSurfaceEx([In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[Out] IDirect3DSurface9** ppSurface,[In] void** pSharedHandle,[In] unsigned int Usage)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::CreateOffscreenPlainSurfaceEx</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface CreateOffscreenPlainSurfaceEx(int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, System.IntPtr sharedHandleRef, int usage) {
            unsafe {
                SharpDX.Direct3D9.Surface surfaceOut;
                IntPtr surfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, width, height, unchecked((int)format), unchecked((int)pool), &surfaceOut_, (void*)sharedHandleRef, usage,((void**)(*(void**)_nativePointer))[130]);		
                surfaceOut= (surfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceOut_);	
                __result__.CheckError();
                return surfaceOut;
            }
        }
        
        /// <summary>	
        /// <p>Creates a depth-stencil surface.</p>	
        /// </summary>	
        /// <param name="width"><dd>  <p>Width of the depth-stencil surface, in pixels. </p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the depth-stencil surface, in pixels. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the format of the depth-stencil surface. This value must be one of the enumerated depth-stencil formats for this device.</p> </dd></param>	
        /// <param name="multiSample"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.MultisampleType"/></strong> enumerated type, describing the multisampling buffer type. This value must be one of the allowed multisample types. When this surface is passed to <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong>, its multisample type must be the same as that of the render target set by <strong><see cref="SharpDX.Direct3D9.Device.SetRenderTarget"/></strong>.</p> </dd></param>	
        /// <param name="multisampleQuality"><dd>  <p>Quality level. The valid range is between zero and one less than the level returned by pQualityLevels used by  <strong><see cref="SharpDX.Direct3D9.Direct3D.CheckDeviceMultiSampleType_"/></strong>. Passing a larger value returns the error <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. The MultisampleQuality values of paired render targets, depth stencil surfaces, and the MultiSample type must all match.</p> </dd></param>	
        /// <param name="discard"><dd>  <p>Set this flag to <strong>TRUE</strong> to enable z-buffer discarding, and <strong><see cref="SharpDX.Result.False"/></strong> otherwise.				If this flag is set, the contents of the depth stencil buffer will be invalid after calling either <strong><see cref="SharpDX.Direct3D9.Device.Present"/></strong> or <strong><see cref="SharpDX.Direct3D9.Device.SetDepthStencilSurface"/></strong> with a different depth surface.</p> <p>This flag has the same behavior as the constant,  <see cref="SharpDX.Direct3D9.PresentFlags.DiscardDepthStencil"/>, in <see cref="SharpDX.Direct3D9.PresentFlags"/>.</p> </dd></param>	
        /// <param name="sharedHandleRef"><dd>  <p>Reserved. Set this parameter to <strong><c>null</c></strong>. This parameter can be used in Direct3D 9 for Windows Vista to share resources.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>Combination of one or more <strong><see cref="SharpDX.Direct3D9.Usage"/></strong> constants which can be OR'd together. Value of 0 indicates no usage.</p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the created depth-stencil surface resource. </p> </dd></returns>	
        /// <remarks>	
        /// <p>The memory class of the depth-stencil buffer is always <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::CreateDepthStencilSurfaceEx']/*"/>	
        /// <msdn-id>bb509711</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::CreateDepthStencilSurfaceEx([In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] D3DMULTISAMPLE_TYPE MultiSample,[In] unsigned int MultisampleQuality,[In] BOOL Discard,[Out] IDirect3DSurface9** ppSurface,[In] void** pSharedHandle,[In] unsigned int Usage)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::CreateDepthStencilSurfaceEx</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface CreateDepthStencilSurfaceEx(int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.MultisampleType multiSample, int multisampleQuality, SharpDX.Mathematics.Interop.RawBool discard, System.IntPtr sharedHandleRef, int usage) {
            unsafe {
                SharpDX.Direct3D9.Surface surfaceOut;
                IntPtr surfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint55(_nativePointer, width, height, unchecked((int)format), unchecked((int)multiSample), multisampleQuality, discard, &surfaceOut_, (void*)sharedHandleRef, usage,((void**)(*(void**)_nativePointer))[131]);		
                surfaceOut= (surfaceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceOut_);	
                __result__.CheckError();
                return surfaceOut;
            }
        }
        
        /// <summary>	
        /// <p>Resets the type, size, and format of the swap chain with all other surfaces persistent.</p>	
        /// </summary>	
        /// <param name="presentationParametersRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structure, describing the new presentation parameters. This value cannot be <strong><c>null</c></strong>.  </p> <p>When switching to full-screen mode, Direct3D will try to find a desktop format that matches the back buffer format, so that back buffer and front buffer formats will be identical (to eliminate the need for color conversion).</p> <p>When this method returns:</p> <ul> <li>BackBufferCount, BackBufferWidth, and BackBufferHeight are set to zero.</li> <li>BackBufferFormat is set to <see cref="SharpDX.Direct3D9.Format"/> for windowed mode only; a full-screen mode must specify a format.</li> </ul> </dd></param>	
        /// <param name="fullscreenDisplayModeRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayModeEx"/></strong> structure that describes the properties of the desired display mode. This value must be provided for fullscreen applications, but can be <strong><c>null</c></strong> for windowed applications. </p> </dd></param>	
        /// <returns><p>The method can return: <see cref="SharpDX.Direct3D9.ResultCode.Success"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> or <see cref="SharpDX.Direct3D9.ResultCode.DeviceHung"/> (see D3DERR). </p><p>If this method returns <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> or <see cref="SharpDX.Direct3D9.ResultCode.DeviceHung"/> then the application can only call <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong>, <strong><see cref="SharpDX.Direct3D9.DeviceEx.CheckDeviceState_"/></strong> or release the interface reference; any other API call will cause an exception.</p></returns>	
        /// <remarks>	
        /// <p>If a call to <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong> fails, the device will be placed in the lost state (as indicated by a return value of <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> from a call to <strong><see cref="SharpDX.Direct3D9.DeviceEx.CheckDeviceState_"/></strong>). Refer to <strong><see cref="SharpDX.Direct3D9.DeviceEx.CheckDeviceState_"/></strong> and Lost Device Behavior Changes for further information concerning the use of <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong> in the context of lost devices.</p><p>Unlike previous versions of DirectX, calling <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong> does not cause surfaces, textures or state information to be lost.</p><p>Pixel shaders and vertex shaders survive <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong> calls for Direct3D 9. They do not need to be re-created explicitly by the application.</p><p>There are two different types of swap chains: full-screen or windowed. If the new swap chain is full-screen, the adapter will be placed in the display mode that matches the new size.</p><p>Applications can expect messages to be sent to them during this call (for example, before this call is returned); applications should take precautions not to call into Direct3D at this time.</p><p>A call to <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong> will fail if called on a different thread than that used to create the device being reset.</p><p><see cref="SharpDX.Direct3D9.Format.Unknown"/> can be specified for the windowed mode back buffer format when calling <strong><see cref="SharpDX.Direct3D9.Direct3DEx.CreateDeviceEx"/></strong>, <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong>, and <strong><see cref="SharpDX.Direct3D9.Device.CreateAdditionalSwapChain"/></strong>. This means the application does not have to query the current desktop format before calling <strong><see cref="SharpDX.Direct3D9.Direct3DEx.CreateDeviceEx"/></strong> for windowed mode. For full-screen mode, the back buffer format must be specified. Setting BackBufferCount equal to zero (BackBufferCount = 0) results in one back buffer.</p><p>When trying to reset more than one display adapter in a group, set pPresentationParameters to point to an array of <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structures, one for each display in the adapter group.</p><p>If a multihead device was created with <see cref="SharpDX.Direct3D9.CreateFlags.AdapterGroupDevice"/>, <strong><see cref="SharpDX.Direct3D9.DeviceEx.ResetEx"/></strong> requires an array of <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structures wherein each structure must specify a full-screen display. To switch back to windowed mode, the application must destroy the device and re-create a non-multihead device in windowed mode.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::ResetEx']/*"/>	
        /// <msdn-id>bb174344</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::ResetEx([In] D3DPRESENT_PARAMETERS* pPresentationParameters,[In] void* pFullscreenDisplayMode)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::ResetEx</unmanaged-short>	
        internal void ResetEx(ref SharpDX.Direct3D9.PresentParameters presentationParametersRef, System.IntPtr fullscreenDisplayModeRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* presentationParametersRef_ = &presentationParametersRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, presentationParametersRef_, (void*)fullscreenDisplayModeRef,((void**)(*(void**)_nativePointer))[132]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the display mode's spatial resolution, color resolution, refresh frequency, and rotation settings.</p>	
        /// </summary>	
        /// <param name="iSwapChain"><dd>  <p>An unsigned integer specifying the swap chain.</p> </dd></param>	
        /// <param name="rotationRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayRotation"/></strong> indicating the type of screen rotation the application will do. The value returned through this reference is important when the <see cref="SharpDX.Direct3D9.PresentFlags.NoAutoRotate"/> flag is used; otherwise, it can be set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayModeEx"/></strong> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. Can be set to <strong><c>null</c></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DDevice9Ex::GetDisplayModeEx']/*"/>	
        /// <msdn-id>bb509714</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DDevice9Ex::GetDisplayModeEx([In] unsigned int iSwapChain,[Out] D3DDISPLAYMODEEX* pMode,[In] void* pRotation)</unmanaged>	
        /// <unmanaged-short>IDirect3DDevice9Ex::GetDisplayModeEx</unmanaged-short>	
        internal SharpDX.Direct3D9.DisplayModeEx GetDisplayModeEx(int iSwapChain, System.IntPtr rotationRef) {
            unsafe {
                SharpDX.Direct3D9.DisplayModeEx modeRef;
                var modeRef_ = SharpDX.Direct3D9.DisplayModeEx.__NewNative();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iSwapChain, &modeRef_, (void*)rotationRef,((void**)(*(void**)_nativePointer))[133]);		
                modeRef = new SharpDX.Direct3D9.DisplayModeEx();
                modeRef.__MarshalFrom(ref modeRef_);
                __result__.CheckError();
                return modeRef;
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.Direct3D"/> interface to create Microsoft Direct3D objects and set up the environment. This interface includes methods for enumerating and retrieving capabilities of the device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface is obtained by calling the <strong>Direct3DCreate9</strong> function.</p><p>The LPDIRECT3D9 and PDIRECT3D9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface. </p><pre>typedef struct <see cref="SharpDX.Direct3D9.Direct3D"/> *LPDIRECT3D9, *PDIRECT3D9;</pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9']/*"/>	
    /// <msdn-id>bb174300</msdn-id>	
    /// <unmanaged>IDirect3D9</unmanaged>	
    /// <unmanaged-short>IDirect3D9</unmanaged-short>	
    [Guid("81BDCBCA-64D4-426d-AE8D-AD0147F4275C")]
    public partial class Direct3D : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Direct3D"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Direct3D(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Direct3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Direct3D(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Direct3D(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns the number of adapters on the system.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::GetAdapterCount']/*"/>	
        /// <msdn-id>bb174315</msdn-id>	
        /// <unmanaged>GetAdapterCount</unmanaged>	
        /// <unmanaged-short>GetAdapterCount</unmanaged-short>	
        /// <unmanaged>unsigned int IDirect3D9::GetAdapterCount()</unmanaged>
        public int AdapterCount {
                get { return GetAdapterCount(); }
        }
        
        /// <summary>	
        /// <p>Registers a pluggable software device. Software devices provide software rasterization enabling applications to access a variety of software rasterizers.</p>	
        /// </summary>	
        /// <param name="initializeFunctionRef"><dd>  <p>Pointer to the initialization function for the software device to be registered. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. The method call is invalid. For example, a method's parameter may have an invalid value: <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>. </p></returns>	
        /// <remarks>	
        /// <p>If the user's computer provides no special hardware acceleration for 3D operations, your application might emulate 3D hardware in software. Software rasterization devices emulate the functions of color 3D hardware in software. A software device runs more slowly than a hal. However, software devices take advantage of any special instructions supported by the CPU to increase performance. Instruction sets include the AMD 3DNow! instruction set on some AMD processors and the MMX instruction set supported by many Intel processors. Direct3D uses the 3D-Now! instruction set to accelerate transformation and lighting operations and the MMX instruction set to accelerate rasterization.</p><p>Software devices communicate with Direct3D through an interface similar to the hardware device driver interface (DDI).</p><p>Software devices are loaded by the application and registered with the <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> object. Direct3D uses the software device for rendering. </p><p>The Direct3D Driver Development Kit (DDK) provides the documentation and headers for developing pluggable software devices.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::RegisterSoftwareDevice']/*"/>	
        /// <msdn-id>bb174321</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::RegisterSoftwareDevice([In] void* pInitializeFunction)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::RegisterSoftwareDevice</unmanaged-short>	
        public void RegisterSoftwareDevice(System.IntPtr initializeFunctionRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)initializeFunctionRef,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Returns the number of adapters on the system.</p>	
        /// </summary>	
        /// <returns><p>A UINT value that denotes the number of adapters on the system at the time this <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface was instantiated.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::GetAdapterCount']/*"/>	
        /// <msdn-id>bb174315</msdn-id>	
        /// <unmanaged>unsigned int IDirect3D9::GetAdapterCount()</unmanaged>	
        /// <unmanaged-short>IDirect3D9::GetAdapterCount</unmanaged-short>	
        internal int GetAdapterCount() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Describes the physical display adapters present in the system when the <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface was instantiated.</p>	
        /// </summary>	
        /// <param name="adapter">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::GetAdapterIdentifier']/*"/>	
        /// <msdn-id>bb174317</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::GetAdapterIdentifier([In] unsigned int Adapter,[In] unsigned int Flags,[Out] D3DADAPTER_IDENTIFIER9* pIdentifier)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::GetAdapterIdentifier</unmanaged-short>	
        internal SharpDX.Direct3D9.AdapterDetails GetAdapterIdentifier(int adapter, int flags) {
            unsafe {
                SharpDX.Direct3D9.AdapterDetails identifierRef;
                var identifierRef_ = new SharpDX.Direct3D9.AdapterDetails.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, flags, &identifierRef_,((void**)(*(void**)_nativePointer))[5]);		
                identifierRef = new SharpDX.Direct3D9.AdapterDetails();
                identifierRef.__MarshalFrom(ref identifierRef_);
                __result__.CheckError();
                return identifierRef;
            }
        }
        
        /// <summary>	
        /// <p>Returns the number of display modes available on this adapter.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Identifies the format of the surface type using <see cref="SharpDX.Direct3D9.Format"/>. Use <strong>EnumAdapterModes</strong> to see the valid formats.</p> </dd></param>	
        /// <returns><p>This method returns the number of display modes on this adapter or zero if Adapter is greater than or equal to the number of adapters on the system.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::GetAdapterModeCount']/*"/>	
        /// <msdn-id>bb174318</msdn-id>	
        /// <unmanaged>unsigned int IDirect3D9::GetAdapterModeCount([In] unsigned int Adapter,[In] D3DFORMAT Format)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::GetAdapterModeCount</unmanaged-short>	
        public int GetAdapterModeCount(int adapter, SharpDX.Direct3D9.Format format) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)format),((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Queries the device to determine whether the specified adapter supports the requested format and display mode. This method could be used in a loop to enumerate all the available adapter modes.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter to enumerate. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> when this value equals or exceeds the number of display adapters in the system. </p> </dd></param>	
        /// <param name="format"><dd>  <p>Allowable pixel formats. See Remarks.</p> </dd></param>	
        /// <param name="mode"><dd>  <p>Represents the display-mode index which is an unsigned integer between zero and the value returned by <strong>GetAdapterModeCount</strong> minus one.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to the available display mode of type <strong><see cref="SharpDX.Direct3D9.DisplayMode"/></strong>. See Remarks.</p> </dd></returns>	
        /// <remarks>	
        /// <p>An application supplies a display mode and a format to <strong>EnumAdapterModes</strong> which returns a display mode. This method could be used in a loop to enumerate all available display modes.</p><p>The application specifies a format and the enumeration is restricted to those display modes that exactly match the format (alpha is ignored). Allowed formats (which are members of <see cref="SharpDX.Direct3D9.Format"/>) are as follows:</p><ul> <li><see cref="SharpDX.Direct3D9.Format.A1R5G5B5"/></li> <li><see cref="SharpDX.Direct3D9.Format.A2R10G10B10"/></li> <li><see cref="SharpDX.Direct3D9.Format.A8R8G8B8"/></li> <li><see cref="SharpDX.Direct3D9.Format.R5G6B5"/></li> <li><see cref="SharpDX.Direct3D9.Format.X1R5G5B5"/></li> <li><see cref="SharpDX.Direct3D9.Format.X8R8G8B8"/></li> </ul><p>In addition, <strong>EnumAdapterModes</strong> treats pixel formats 565 and 555 as equivalent, and returns the correct version. The difference comes into play only when the application locks the back buffer and there is an explicit flag that the application must set in order to accomplish this.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::EnumAdapterModes']/*"/>	
        /// <msdn-id>bb174314</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::EnumAdapterModes([In] unsigned int Adapter,[In] D3DFORMAT Format,[In] unsigned int Mode,[Out] D3DDISPLAYMODE* pMode)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::EnumAdapterModes</unmanaged-short>	
        public SharpDX.Direct3D9.DisplayMode EnumAdapterModes(int adapter, SharpDX.Direct3D9.Format format, int mode) {
            unsafe {
                SharpDX.Direct3D9.DisplayMode modeRef;
                modeRef = new SharpDX.Direct3D9.DisplayMode();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)format), mode, &modeRef,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
                return modeRef;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the current display mode of the adapter.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number that denotes the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayMode"/></strong> structure, to be filled with information describing the current adapter's mode. </p> </dd></returns>	
        /// <remarks>	
        /// <p><strong>GetAdapterDisplayMode</strong> will not return the correct format when the display is in an extended format, such as 2:10:10:10. Instead, it returns the format X8R8G8B8. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::GetAdapterDisplayMode']/*"/>	
        /// <msdn-id>bb174316</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::GetAdapterDisplayMode([In] unsigned int Adapter,[Out] D3DDISPLAYMODE* pMode)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::GetAdapterDisplayMode</unmanaged-short>	
        public SharpDX.Direct3D9.DisplayMode GetAdapterDisplayMode(int adapter) {
            unsafe {
                SharpDX.Direct3D9.DisplayMode modeRef;
                modeRef = new SharpDX.Direct3D9.DisplayMode();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, &modeRef,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
                return modeRef;
            }
        }
        
        /// <summary>	
        /// <p>Verifies whether a hardware accelerated device type can be used on this adapter.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter to enumerate. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> when this value equals or exceeds the number of display adapters in the system. </p> </dd></param>	
        /// <param name="devType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong> enumerated type, indicating the device type to check. </p> </dd></param>	
        /// <param name="adapterFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, indicating the format of the adapter display mode for which the device type is to be checked. For example, some devices will operate only in 16-bits-per-pixel modes. </p> </dd></param>	
        /// <param name="backBufferFormat"><dd>  <p>Back buffer format. For more information about formats, see <see cref="SharpDX.Direct3D9.Format"/>. This value must be one of the render-target formats. You can use <strong>GetAdapterDisplayMode</strong> to obtain the current format. For windowed applications, the back buffer format does not need to match the display mode format if the hardware supports color conversion. The set of possible back buffer formats is constrained, but the runtime will allow any valid back buffer format to be presented to any desktop format. There is the additional requirement that the device be operable in the desktop because devices typically do not operate in 8 bits per pixel modes. Full-screen applications cannot do color conversion. <see cref="SharpDX.Direct3D9.Format.Unknown"/> is allowed for windowed mode. </p> </dd></param>	
        /// <param name="bWindowed"><dd>  <p>Value indicating whether the device type will be used in full-screen or windowed mode. If set to <strong>TRUE</strong>, the query is performed for windowed applications; otherwise, this value should be set <strong><see cref="SharpDX.Result.False"/></strong>. </p> </dd></param>	
        /// <returns><p>If the device can be used on this adapter, <see cref="SharpDX.Direct3D9.ResultCode.Success"/> is returned. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if Adapter equals or exceeds the number of display adapters in the system. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is also returned if <strong>CheckDeviceType</strong> specified a device that does not exist. <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/> is returned if the requested back buffer format is not supported, or if hardware acceleration is not available for the specified formats. </p></returns>	
        /// <remarks>	
        /// <p>A hal device type requires hardware acceleration. Applications can use CheckDeviceType to determine if the needed hardware and drivers are present to support a hal device. </p><p>Full-screen applications should not specify a DisplayFormat that contains an alpha channel. This will result in a failed call. Note that an alpha channel can be present in the back buffer but the two display formats must be identical in all other respects. For example, if DisplayFormat = <see cref="SharpDX.Direct3D9.Format.X1R5G5B5"/>, valid values for BackBufferFormat include <see cref="SharpDX.Direct3D9.Format.X1R5G5B5"/> and <see cref="SharpDX.Direct3D9.Format.A1R5G5B5"/> but exclude <see cref="SharpDX.Direct3D9.Format.R5G6B5"/>.</p><p>The following code fragment shows how you could use CheckDeviceType to test whether a certain device type can be used on this adapter.</p><pre> if(SUCCEEDED(pD3Device-&gt;CheckDeviceType(D3DADAPTER_DEFAULT,  <see cref="SharpDX.Direct3D9.DeviceType.Hardware"/>,  DisplayFormat,  BackBufferFormat,  bIsWindowed))) return <see cref="SharpDX.Result.Ok"/>;	
        /// // There is no HAL on this adapter using this render-target format. 	
        /// // Try again, using another format.	
        /// </pre><p>This code returns <see cref="SharpDX.Result.Ok"/> if the device can be used on the default adapter with the specified surface format.</p><p>Using <strong>CheckDeviceType</strong> to test for compatibility between a back buffer that differs from the display format will return appropriate values. This means that the call will reflect device capabilities. If the device cannot render to the requested back-buffer format, the call will still return <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>. If the device can render to the format, but cannot perform the color-converting presentation, the return value will also be <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>. Applications can discover hardware support for the presentation itself by calling <strong>CheckDeviceFormatConversion</strong>. No software emulation for the color-converting presentation itself will be offered.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::CheckDeviceType']/*"/>	
        /// <msdn-id>bb174312</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceType([In] unsigned int Adapter,[In] D3DDEVTYPE DevType,[In] D3DFORMAT AdapterFormat,[In] D3DFORMAT BackBufferFormat,[In] BOOL bWindowed)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::CheckDeviceType</unmanaged-short>	
        internal SharpDX.Result CheckDeviceType_(int adapter, SharpDX.Direct3D9.DeviceType devType, SharpDX.Direct3D9.Format adapterFormat, SharpDX.Direct3D9.Format backBufferFormat, SharpDX.Mathematics.Interop.RawBool bWindowed) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint42(_nativePointer, adapter, unchecked((int)devType), unchecked((int)adapterFormat), unchecked((int)backBufferFormat), bWindowed,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Determines whether a surface format is available as a specified resource type and can be used as a texture, depth-stencil buffer, or render target, or any combination of the three, on a device representing this adapter.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> when this value equals or exceeds the number of display adapters in the system. </p> </dd></param>	
        /// <param name="deviceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong> enumerated type, identifying the device type.</p> </dd></param>	
        /// <param name="adapterFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, identifying the format of the display mode into which the adapter will be placed.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>Requested usage options for the surface. Usage options are any combination of <see cref="SharpDX.Direct3D9.Usage"/> and D3DUSAGE_QUERY constants (only a subset of the <see cref="SharpDX.Direct3D9.Usage"/> constants are valid for <strong>CheckDeviceFormat</strong>; see the table on the <see cref="SharpDX.Direct3D9.Usage"/> page).</p> </dd></param>	
        /// <param name="rType"><dd>  <p>Resource type requested for use with the queried format. Member of <strong><see cref="SharpDX.Direct3D9.ResourceType"/></strong>. </p> </dd></param>	
        /// <param name="checkFormat"><dd>  <p>Format of the surfaces which may be used, as defined by Usage. Member of <see cref="SharpDX.Direct3D9.Format"/>.</p> </dd></param>	
        /// <returns><p>If the format is compatible with the specified device for the requested usage, this method returns <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p><p><see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if Adapter equals or exceeds the number of display adapters in the system, or if DeviceType is unsupported.</p><p><see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/> is returned if the format is not acceptable to the device for this usage.</p></returns>	
        /// <remarks>	
        /// <p>Here are some examples using <strong>CheckDeviceFormat</strong> to check for hardware support of:</p><ul> <li>An off-screen plain surface format - Specify Usage = 0 and RType = <see cref="SharpDX.Direct3D9.ResourceType.Surface"/>.</li> <li>A depth-stencil format - The following snippet tests for the passed in depth-stencil format:  <pre> <see cref="SharpDX.Mathematics.Interop.RawBool"/> IsDepthFormatExisting( <see cref="SharpDX.Direct3D9.Format"/> DepthFormat, <see cref="SharpDX.Direct3D9.Format"/> AdapterFormat ) 	
        /// { <see cref="SharpDX.Result"/> hr = pD3D-&gt;CheckDeviceFormat( D3DADAPTER_DEFAULT, <see cref="SharpDX.Direct3D9.DeviceType.Hardware"/>, AdapterFormat, <see cref="SharpDX.Direct3D9.Usage.DepthStencil"/>, <see cref="SharpDX.Direct3D9.ResourceType.Surface"/>, DepthFormat); return SUCCEEDED( hr );	
        /// }</pre>  <p>See Selecting a Device (Direct3D 9) for more detail on the enumeration process.</p> </li> <li>Can this texture be rendered in a particular format - Given the current display mode, this example shows how to verify that the texture format is compatible with the specific back-buffer format:  <pre> <see cref="SharpDX.Mathematics.Interop.RawBool"/> IsTextureFormatOk( <see cref="SharpDX.Direct3D9.Format"/> TextureFormat, <see cref="SharpDX.Direct3D9.Format"/> AdapterFormat ) 	
        /// { <see cref="SharpDX.Result"/> hr = pD3D-&gt;CheckDeviceFormat( D3DADAPTER_DEFAULT, <see cref="SharpDX.Direct3D9.DeviceType.Hardware"/>, AdapterFormat, 0, <see cref="SharpDX.Direct3D9.ResourceType.Texture"/>, TextureFormat); return SUCCEEDED( hr );	
        /// }</pre>  </li> <li>Alpha blending in a pixel shader - Set Usage to <see cref="SharpDX.Direct3D9.Usage.QueryPostPixelShaderBlending"/>. Expect this to fail for all floating-point render targets.</li> <li>Autogeneration of mipmaps - Set Usage to <see cref="SharpDX.Direct3D9.Usage.AutoGenerateMipMap"/>. If the mipmap automatic generation fails, the application will get a non-mipmapped texture. Calling this method is considered a hint, so this method can return <see cref="SharpDX.Direct3D9.ResultCode.NoAutomaticGeneration"/> (a valid success code) if the only thing that fails is the mipmap generation. For more information about mipmap generation, see Automatic Generation of Mipmaps (Direct3D 9).</li> </ul><p>When migrating code from Direct3D 9 to Direct3D 10, the Direct3D 10 equivalent to CheckDeviceFormat is <strong>CheckFormatSupport</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::CheckDeviceFormat']/*"/>	
        /// <msdn-id>bb174309</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceFormat([In] unsigned int Adapter,[In] D3DDEVTYPE DeviceType,[In] D3DFORMAT AdapterFormat,[In] unsigned int Usage,[In] D3DRESOURCETYPE RType,[In] D3DFORMAT CheckFormat)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::CheckDeviceFormat</unmanaged-short>	
        internal SharpDX.Result CheckDeviceFormat_(int adapter, SharpDX.Direct3D9.DeviceType deviceType, SharpDX.Direct3D9.Format adapterFormat, int usage, SharpDX.Direct3D9.ResourceType rType, SharpDX.Direct3D9.Format checkFormat) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)deviceType), unchecked((int)adapterFormat), usage, unchecked((int)rType), unchecked((int)checkFormat),((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Determines if a multisampling technique is available on this device.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns <strong><see cref="SharpDX.Result.False"/></strong> when this value equals or exceeds the number of display adapters in the system. See Remarks.</p> </dd></param>	
        /// <param name="deviceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong> enumerated type, identifying the device type.</p> </dd></param>	
        /// <param name="surfaceFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type that specifies the format of the surface to be multisampled. For more information, see Remarks.</p> </dd></param>	
        /// <param name="windowed"><dd>  <p>bool value. Specify <strong>TRUE</strong> to inquire about windowed multisampling, and specify <strong><see cref="SharpDX.Result.False"/></strong> to inquire about full-screen multisampling.</p> </dd></param>	
        /// <param name="multiSampleType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.MultisampleType"/></strong> enumerated type, identifying the multisampling technique to test.</p> </dd></param>	
        /// <param name="qualityLevelsRef"><dd>  <p><strong>pQualityLevels</strong> returns the number of device-specific sampling variations available with the given sample type. For example, if the returned value is 3, then quality levels 0, 1 and 2 can be used when creating resources with the given sample count. The meanings of these quality levels are defined by the device manufacturer and cannot be queried through D3D. For example, for a particular device different quality levels at a fixed sample count might refer to different spatial layouts of the sample locations or different methods of resolving.  This can be <strong><c>null</c></strong> if it is not necessary to return the quality levels.</p> </dd></param>	
        /// <returns><p>If the device can perform the specified multisampling method, this method returns <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the Adapter or MultiSampleType parameters are invalid. This method returns <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/> if the queried multisampling technique is not supported by this device. <see cref="SharpDX.Direct3D9.ResultCode.InvalidDevice"/> is returned if DeviceType does not apply to this adapter. </p></returns>	
        /// <remarks>	
        /// <p>This method is intended for use with both render-target and depth-stencil surfaces because you must create both surfaces multisampled if you want to use them together.</p><p>The following code fragment shows how you could use <strong>CheckDeviceMultiSampleType</strong> to test for devices that support a specific multisampling method.</p><pre> if( SUCCEEDED(pD3D-&gt;CheckDeviceMultiSampleType( pCaps-&gt;AdapterOrdinal,  pCaps-&gt;DeviceType, BackBufferFormat,  <see cref="SharpDX.Result.False"/>, <see cref="SharpDX.Direct3D9.MultisampleType.ThreeSamples"/>, <c>null</c> ) ) &amp;&amp; SUCCEEDED(pD3D-&gt;CheckDeviceMultiSampleType( pCaps-&gt;AdapterOrdinal,  pCaps-&gt;DeviceType, DepthBufferFormat,  <see cref="SharpDX.Result.False"/>, <see cref="SharpDX.Direct3D9.MultisampleType.ThreeSamples"/>, <c>null</c> ) ) ) return <see cref="SharpDX.Result.Ok"/>;	
        /// </pre><p>The preceding code will return <see cref="SharpDX.Result.Ok"/> if the device supports the full-screen <see cref="SharpDX.Direct3D9.MultisampleType.ThreeSamples"/> multisampling method with the surface format.</p><p>See the remarks in <strong><see cref="SharpDX.Direct3D9.MultisampleType"/></strong> for additional information on working with and setting multisample types and quality levels.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::CheckDeviceMultiSampleType']/*"/>	
        /// <msdn-id>bb174311</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceMultiSampleType([In] unsigned int Adapter,[In] D3DDEVTYPE DeviceType,[In] D3DFORMAT SurfaceFormat,[In] BOOL Windowed,[In] D3DMULTISAMPLE_TYPE MultiSampleType,[Out] unsigned int* pQualityLevels)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::CheckDeviceMultiSampleType</unmanaged-short>	
        internal SharpDX.Result CheckDeviceMultiSampleType_(int adapter, SharpDX.Direct3D9.DeviceType deviceType, SharpDX.Direct3D9.Format surfaceFormat, SharpDX.Mathematics.Interop.RawBool windowed, SharpDX.Direct3D9.MultisampleType multiSampleType, out int qualityLevelsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* qualityLevelsRef_ = &qualityLevelsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint43(_nativePointer, adapter, unchecked((int)deviceType), unchecked((int)surfaceFormat), windowed, unchecked((int)multiSampleType), qualityLevelsRef_,((void**)(*(void**)_nativePointer))[11]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Determines whether a depth-stencil format is compatible with a render-target format in a particular display mode.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter.</p> </dd></param>	
        /// <param name="deviceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong> enumerated type, identifying the device type.</p> </dd></param>	
        /// <param name="adapterFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, identifying the format of the display mode into which the adapter will be placed. </p> </dd></param>	
        /// <param name="renderTargetFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, identifying the format of the render-target surface to be tested. </p> </dd></param>	
        /// <param name="depthStencilFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, identifying the format of the depth-stencil surface to be tested. </p> </dd></param>	
        /// <returns><p>If the depth-stencil format is compatible with the render-target format in the display mode, this method returns <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> can be returned if one or more of the parameters is invalid. If a depth-stencil format is not compatible with the render target in the display mode, then this method returns <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is provided to enable applications to work with hardware requiring that certain depth formats can only work with certain render-target formats.</p><p>The behavior of this method has been changed for DirectX 8.1.  This method now pays attention to the D24x8 and D32 depth-stencil formats. The previous version assumed that these formats would always be usable with 32- or 16-bit render targets. This method will now return <see cref="SharpDX.Direct3D9.ResultCode.Success"/> for these formats only if the device is capable of mixed-depth operations.</p><p>The following code fragment shows how you could use <strong>CheckDeviceFormat</strong> to validate a depth stencil format.</p><pre> <see cref="SharpDX.Mathematics.Interop.RawBool"/> IsDepthFormatOk(<see cref="SharpDX.Direct3D9.Format"/> DepthFormat,  <see cref="SharpDX.Direct3D9.Format"/> AdapterFormat,  <see cref="SharpDX.Direct3D9.Format"/> BackBufferFormat)	
        /// { // Verify that the depth format exists <see cref="SharpDX.Result"/> hr = pD3D-&gt;CheckDeviceFormat(D3DADAPTER_DEFAULT, <see cref="SharpDX.Direct3D9.DeviceType.Hardware"/>, AdapterFormat, <see cref="SharpDX.Direct3D9.Usage.DepthStencil"/>, <see cref="SharpDX.Direct3D9.ResourceType.Surface"/>, DepthFormat); if(FAILED(hr)) return <see cref="SharpDX.Result.False"/>; // Verify that the depth format is compatible hr = pD3D-&gt;CheckDepthStencilMatch(D3DADAPTER_DEFAULT, <see cref="SharpDX.Direct3D9.DeviceType.Hardware"/>, AdapterFormat, BackBufferFormat, DepthFormat); return SUCCEEDED(hr); }	
        /// </pre><p>The preceding call will return <strong><see cref="SharpDX.Result.False"/></strong> if DepthFormat cannot be used in conjunction with AdapterFormat and BackBufferFormat.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::CheckDepthStencilMatch']/*"/>	
        /// <msdn-id>bb174308</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::CheckDepthStencilMatch([In] unsigned int Adapter,[In] D3DDEVTYPE DeviceType,[In] D3DFORMAT AdapterFormat,[In] D3DFORMAT RenderTargetFormat,[In] D3DFORMAT DepthStencilFormat)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::CheckDepthStencilMatch</unmanaged-short>	
        internal SharpDX.Result CheckDepthStencilMatch_(int adapter, SharpDX.Direct3D9.DeviceType deviceType, SharpDX.Direct3D9.Format adapterFormat, SharpDX.Direct3D9.Format renderTargetFormat, SharpDX.Direct3D9.Format depthStencilFormat) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)deviceType), unchecked((int)adapterFormat), unchecked((int)renderTargetFormat), unchecked((int)depthStencilFormat),((void**)(*(void**)_nativePointer))[12]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Tests the device to see if it supports conversion from one display format to another.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Display adapter ordinal number. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> when this value equals or exceeds the number of display adapters in the system.  </p> </dd></param>	
        /// <param name="deviceType"><dd>  <p>Device type. Member of the <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong> enumerated type. </p> </dd></param>	
        /// <param name="sourceFormat"><dd>  <p>Source adapter format. Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type.</p> </dd></param>	
        /// <param name="targetFormat"><dd>  <p>Target adapter format. Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. The method will return <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/> when the hardware does not support conversion between the two formats. </p></returns>	
        /// <remarks>	
        /// <p>Using <strong>CheckDeviceType</strong> to test for compatibility between a back buffer that differs from the display format will return appropriate values. This means that the call will reflect device capabilities. If the device cannot render to the requested back buffer format, the call will still return <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>. If the device can render to the format, but cannot perform the color-converting presentation, the return value will also be <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>. Applications can discover hardware support for the presentation itself by calling <strong>CheckDeviceFormatConversion</strong>. No software emulation for the color-converting presentation itself will be offered.</p><p><strong>CheckDeviceFormatConversion</strong> can also be used to determine which combinations of source surface formats and destination surface formats are permissible in calls to <strong>StretchRect</strong>. </p><p>Color conversion is restricted to the following source and target formats.</p><ul> <li>The source format must be a FOURCC format or a valid back buffer format. For a list of these, see FourCC Formats and BackBuffer or Display Formats.</li> <li>The target format must be one of these unsigned formats: <table> <tr><td><see cref="SharpDX.Direct3D9.Format.X1R5G5B5"/></td><td><see cref="SharpDX.Direct3D9.Format.A1R5G5B5"/></td><td><see cref="SharpDX.Direct3D9.Format.R5G6B5"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.Format.R8G8B8"/></td><td><see cref="SharpDX.Direct3D9.Format.X8R8G8B8"/></td><td><see cref="SharpDX.Direct3D9.Format.A8R8G8B8"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.Format.A2R10G10B10"/></td><td><see cref="SharpDX.Direct3D9.Format.A16B16G16R16"/></td><td><see cref="SharpDX.Direct3D9.Format.A2B10G10R10"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.Format.A8B8G8R8"/></td><td><see cref="SharpDX.Direct3D9.Format.X8B8G8R8"/></td><td><see cref="SharpDX.Direct3D9.Format.A16B16G16R16F"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.Format.A32B32G32R32F"/></td><td></td><td></td></tr> </table> <p>?</p> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::CheckDeviceFormatConversion']/*"/>	
        /// <msdn-id>bb174310</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::CheckDeviceFormatConversion([In] unsigned int Adapter,[In] D3DDEVTYPE DeviceType,[In] D3DFORMAT SourceFormat,[In] D3DFORMAT TargetFormat)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::CheckDeviceFormatConversion</unmanaged-short>	
        internal SharpDX.Result CheckDeviceFormatConversion_(int adapter, SharpDX.Direct3D9.DeviceType deviceType, SharpDX.Direct3D9.Format sourceFormat, SharpDX.Direct3D9.Format targetFormat) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)deviceType), unchecked((int)sourceFormat), unchecked((int)targetFormat),((void**)(*(void**)_nativePointer))[13]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves device-specific information about a device. </p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter. </p> </dd></param>	
        /// <param name="deviceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong> enumerated type. Denotes the device type. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong> structure to be filled with information describing the capabilities of the device. </p> </dd></returns>	
        /// <remarks>	
        /// <p>The application should not assume the persistence of vertex processing capabilities across Direct3D device objects. The particular capabilities that a physical device exposes may depend on parameters supplied to <strong>CreateDevice</strong>. For example, the capabilities may yield different vertex processing capabilities before and after creating a Direct3D Device Object with hardware vertex processing enabled. For more information see the description of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::GetDeviceCaps']/*"/>	
        /// <msdn-id>bb174320</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::GetDeviceCaps([In] unsigned int Adapter,[In] D3DDEVTYPE DeviceType,[Out] D3DCAPS9* pCaps)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::GetDeviceCaps</unmanaged-short>	
        public SharpDX.Direct3D9.Capabilities GetDeviceCaps(int adapter, SharpDX.Direct3D9.DeviceType deviceType) {
            unsafe {
                SharpDX.Direct3D9.Capabilities capsRef;
                capsRef = new SharpDX.Direct3D9.Capabilities();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)deviceType), &capsRef,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
                return capsRef;
            }
        }
        
        /// <summary>	
        /// <p>Returns the handle of the monitor associated with the Direct3D object.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter. </p> </dd></param>	
        /// <returns><p>Handle of the monitor associated with the Direct3D object.</p></returns>	
        /// <remarks>	
        /// <p>As shown in the following code fragment, which illustrates how to obtain a handle to the monitor associated with a given device, use <strong>GetDirect3D</strong> to return the Direct3D enumerator from the device and use <strong>GetCreationParameters</strong> to retrieve the value for Adapter.</p><pre> if( FAILED( pDevice-&gt;GetCreationParameters(  &amp;Parameters ) ) ) return <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>; if( FAILED( pDevice-&gt;GetDirect3D(&amp;pD3D) ) ) return <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>; hMonitor = pD3D-&gt;GetAdapterMonitor(Parameters.AdapterOrdinal); pD3D-&gt;Release();	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::GetAdapterMonitor']/*"/>	
        /// <msdn-id>bb174319</msdn-id>	
        /// <unmanaged>HMONITOR IDirect3D9::GetAdapterMonitor([In] unsigned int Adapter)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::GetAdapterMonitor</unmanaged-short>	
        public System.IntPtr GetAdapterMonitor(int adapter) {
            unsafe {
                System.IntPtr __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSystemIntPtr(_nativePointer, adapter,((void**)(*(void**)_nativePointer))[15]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Creates a device to represent the display adapter.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter. </p> </dd></param>	
        /// <param name="deviceType"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong> enumerated type that denotes the desired device type. If the desired device type is not available, the method will fail. </p> </dd></param>	
        /// <param name="hFocusWindow"><dd>  <p>The focus window alerts Direct3D when an application switches from foreground mode to background mode. See Remarks. 	 </p> <ul> <li>For full-screen mode, the window specified must be a top-level window.</li> <li>For windowed mode, this parameter may be <strong><c>null</c></strong> only if the hDeviceWindow member of <em>pPresentationParameters</em> is set to a valid, non-<strong><c>null</c></strong> value.</li> </ul> </dd></param>	
        /// <param name="behaviorFlags"><dd>  <p>Combination of one or more options that control device creation. For more information, see <see cref="SharpDX.Direct3D9.CreateFlags"/>.</p> </dd></param>	
        /// <param name="presentationParametersRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structure, describing the presentation parameters for the device to be created. If BehaviorFlags specifies <see cref="SharpDX.Direct3D9.CreateFlags.AdapterGroupDevice"/>, pPresentationParameters is an array. Regardless of the number of heads that exist, only one depth/stencil surface is automatically created.</p> <p>For Windows 2000 and Windows XP, the full-screen device display refresh rate is set in the following order: </p> <ol> <li>User-specified nonzero ForcedRefreshRate registry key, if supported by the device.</li> <li>Application-specified nonzero refresh rate value in the presentation parameter.</li> <li>Refresh rate of the latest desktop, if supported by the device.</li> <li>75 hertz if supported by the device.</li> <li>60 hertz if supported by the device.</li> <li>Device default.</li> </ol> <p>An unsupported refresh rate will default to the closest supported refresh rate below it.  For example, if the application specifies 63 hertz, 60 hertz will be used. There are no supported refresh rates below 57 hertz.</p> <p>pPresentationParameters is both an input and an output parameter. Calling this method may change several members including:</p> <ul> <li>If BackBufferCount, BackBufferWidth, and BackBufferHeight  are 0 before the method is called, they will be changed when the method returns.</li> <li>If BackBufferFormat equals <see cref="SharpDX.Direct3D9.Format.Unknown"/> before the method is called, it will be changed when the method returns.</li> </ul> </dd></param>	
        /// <param name="returnedDeviceInterfaceOut"><dd>  <p>Address of a reference to the returned <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, which represents the created device. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method returns a fully working device interface, set to the required display mode (or windowed), and allocated with the appropriate back buffers. To begin rendering, the application needs only to create and set a depth buffer (assuming EnableAutoDepthStencil is <strong><see cref="SharpDX.Result.False"/></strong> in <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong>).</p><p>When you create a Direct3D device, you supply two different window parameters: a focus window (hFocusWindow) and a device window (the hDeviceWindow in <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong>). The purpose of each window is:</p><ul> <li>The focus window alerts Direct3D when an application switches from foreground mode to background mode (via Alt-Tab, a mouse click, or some other method). A single focus window is shared by each device created by an application.</li> <li>The device window determines the location and size of the back buffer on screen. This is used by Direct3D when the back buffer contents are copied to the front buffer during <strong>Present</strong>.</li> </ul><p>This method should not be run during the handling of WM_CREATE. An application should never pass a window handle to Direct3D while handling WM_CREATE.  Any call to create, release, or reset the device must be done using the same thread as the window procedure of the focus window.</p><p>Note that <see cref="SharpDX.Direct3D9.CreateFlags.HardwareVertexProcessing"/>, <see cref="SharpDX.Direct3D9.CreateFlags.MixedVertexProcessing"/>, and <see cref="SharpDX.Direct3D9.CreateFlags.SoftwareVertexProcessing"/> are mutually exclusive flags, and at least one of these vertex processing flags must be specified when calling this method.</p><p>Back buffers created as part of the device are only lockable if <see cref="SharpDX.Direct3D9.PresentFlags.LockableBackBuffer"/> is specified in the presentation parameters. (Multisampled back buffers and depth surfaces are never lockable.)</p><p>The methods <strong>Reset</strong>, <strong><see cref="SharpDX.ComObject"/></strong>, and <strong>TestCooperativeLevel</strong> must be called from the same thread that used this method to create a device.</p><p><see cref="SharpDX.Direct3D9.Format.Unknown"/> can be specified for the windowed mode back buffer format when calling <strong>CreateDevice</strong>, <strong>Reset</strong>, and <strong>CreateAdditionalSwapChain</strong>. This means the application does not have to query the current desktop format before calling <strong>CreateDevice</strong> for windowed mode. For full-screen mode, the back buffer format must be specified.</p><p>If you attempt to create a device on a 0x0 sized window, <strong>CreateDevice</strong> will fail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9::CreateDevice']/*"/>	
        /// <msdn-id>bb174313</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9::CreateDevice([In] unsigned int Adapter,[In] D3DDEVTYPE DeviceType,[In] HWND hFocusWindow,[In] D3DCREATE BehaviorFlags,[In, Buffer] D3DPRESENT_PARAMETERS* pPresentationParameters,[Out, Fast] IDirect3DDevice9** ppReturnedDeviceInterface)</unmanaged>	
        /// <unmanaged-short>IDirect3D9::CreateDevice</unmanaged-short>	
        internal void CreateDevice(int adapter, SharpDX.Direct3D9.DeviceType deviceType, System.IntPtr hFocusWindow, SharpDX.Direct3D9.CreateFlags behaviorFlags, SharpDX.Direct3D9.PresentParameters[] presentationParametersRef, SharpDX.Direct3D9.Device returnedDeviceInterfaceOut) {
            unsafe {
                IntPtr returnedDeviceInterfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* presentationParametersRef_ = presentationParametersRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)deviceType), (void*)hFocusWindow, unchecked((int)behaviorFlags), presentationParametersRef_, &returnedDeviceInterfaceOut_,((void**)(*(void**)_nativePointer))[16]);		
                ((SharpDX.Direct3D9.Device)returnedDeviceInterfaceOut).NativePointer = returnedDeviceInterfaceOut_;
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> interface (which inherits from <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong>) to create Microsoft Direct3D 9Ex objects and set up the environment. This interface includes methods for enumerating and retrieving capabilities of the device and is available when the underlying device implementation is compliant with Windows Vista.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> interface is obtained by calling the <strong>Direct3DCreate9Ex</strong> function.</p><p>The <strong>LPDIRECT3D9EX</strong> and <strong>PDIRECT3D9EX</strong> types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> interface:</p><p> </p><pre> typedef struct <see cref="SharpDX.Direct3D9.Direct3DEx"/> *LPDIRECT3D9EX, *PDIRECT3D9EX;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9Ex']/*"/>	
    /// <msdn-id>bb174301</msdn-id>	
    /// <unmanaged>IDirect3D9Ex</unmanaged>	
    /// <unmanaged-short>IDirect3D9Ex</unmanaged-short>	
    [Guid("02177241-69FC-400C-8FF1-93A44DF6861D")]
    public partial class Direct3DEx : SharpDX.Direct3D9.Direct3D {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Direct3DEx"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Direct3DEx(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Direct3DEx"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Direct3DEx(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Direct3DEx(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns the number of display modes available.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter from which to retrieve the display mode count.</p> </dd></param>	
        /// <param name="filterRef"><dd>  <p>Specifies the characteristics of the desired display mode. See <strong><see cref="SharpDX.Direct3D9.DisplayModeFilter"/></strong>.</p> </dd></param>	
        /// <returns><p>The number of display modes available. A return of value zero from this method is an indication that no such display mode is supported or simply this monitor is no longer available.</p></returns>	
        /// <remarks>	
        /// <p>Events such as display mode changes on other heads of the same hardware, monitor change or its connection status change, and desktop extension/unextension could all affect the number of display mode available.</p><p>To fullscreen applications, <see cref="SharpDX.Direct3D9.ResultCode.PresentModeChanged"/> returned from <strong>PresentEx</strong> or <strong>CheckDeviceState</strong> is the indication of display mode setting failure due to those events.</p><p>To increase the chance of setting a currently available display mode successfully, fullscreen applications should try to requery the available display mode list upon receiving <see cref="SharpDX.Direct3D9.ResultCode.PresentModeChanged"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9Ex::GetAdapterModeCountEx']/*"/>	
        /// <msdn-id>bb174306</msdn-id>	
        /// <unmanaged>unsigned int IDirect3D9Ex::GetAdapterModeCountEx([In] unsigned int Adapter,[In] const D3DDISPLAYMODEFILTER* pFilter)</unmanaged>	
        /// <unmanaged-short>IDirect3D9Ex::GetAdapterModeCountEx</unmanaged-short>	
        public int GetAdapterModeCountEx(int adapter, SharpDX.Direct3D9.DisplayModeFilter filterRef) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, &filterRef,((void**)(*(void**)_nativePointer))[17]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>This method returns the actual display mode info based on the given mode index.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter to enumerate. D3DADAPTER_DEFAULT is always the primary display adapter. This method returns <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> when this value equals or exceeds the number of display adapters in the system.</p> </dd></param>	
        /// <param name="filterRef"><dd>  <p>See <strong><see cref="SharpDX.Direct3D9.DisplayModeFilter"/></strong>.</p> </dd></param>	
        /// <param name="mode"><dd>  <p>Represents the display-mode index which is an unsigned integer between zero and the value returned by GetAdapterModeCount minus one.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to the available display mode of type <strong><see cref="SharpDX.Direct3D9.DisplayModeEx"/></strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9Ex::EnumAdapterModesEx']/*"/>	
        /// <msdn-id>bb174303</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9Ex::EnumAdapterModesEx([In] unsigned int Adapter,[In] const D3DDISPLAYMODEFILTER* pFilter,[In] unsigned int Mode,[Out] D3DDISPLAYMODEEX* pMode)</unmanaged>	
        /// <unmanaged-short>IDirect3D9Ex::EnumAdapterModesEx</unmanaged-short>	
        public SharpDX.Direct3D9.DisplayModeEx EnumerateAdapterModesEx(int adapter, SharpDX.Direct3D9.DisplayModeFilter filterRef, int mode) {
            unsafe {
                SharpDX.Direct3D9.DisplayModeEx modeRef;
                var modeRef_ = SharpDX.Direct3D9.DisplayModeEx.__NewNative();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, &filterRef, mode, &modeRef_,((void**)(*(void**)_nativePointer))[18]);		
                modeRef = new SharpDX.Direct3D9.DisplayModeEx();
                modeRef.__MarshalFrom(ref modeRef_);
                __result__.CheckError();
                return modeRef;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the current display mode and rotation settings of the adapter.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number that denotes the display adapter to query. D3DADAPTER_DEFAULT is always the primary display adapter. </p> </dd></param>	
        /// <param name="rotationRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayRotation"/></strong> structure indicating the type of screen rotation the application will do. The value returned through this reference is important when the <see cref="SharpDX.Direct3D9.PresentFlags.NoAutoRotate"/> flag is used; otherwise, it can be set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayModeEx"/></strong> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. Can be set to <strong><c>null</c></strong>.</p> </dd></returns>	
        /// <remarks>	
        /// <p><strong>GetAdapterDisplayModeEx</strong> does not return the correct format when the display is in an extended format, such as 2:10:10:10. Instead, it returns the format X8R8G8B8.</p><p>To windowed applications, a value of <see cref="SharpDX.Direct3D9.ResultCode.PresentModeChanged"/> returned from <strong>PresentEx</strong> or <strong>CheckDeviceState</strong> indicates that the display mode changed and that the current display mode might have a different format. To avoid a color-converting Present blt, windowed applications can optionally get new display mode information by using this method and adjusting its swap chain format accordingly. This method returns <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/> if this head is no longer part of the desktop or if the monitor is disconnected.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9Ex::GetAdapterDisplayModeEx']/*"/>	
        /// <msdn-id>bb174304</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9Ex::GetAdapterDisplayModeEx([In] unsigned int Adapter,[Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>	
        /// <unmanaged-short>IDirect3D9Ex::GetAdapterDisplayModeEx</unmanaged-short>	
        public SharpDX.Direct3D9.DisplayModeEx GetAdapterDisplayModeEx(int adapter, out SharpDX.Direct3D9.DisplayRotation rotationRef) {
            unsafe {
                SharpDX.Direct3D9.DisplayModeEx modeRef;
                var modeRef_ = SharpDX.Direct3D9.DisplayModeEx.__NewNative();
                SharpDX.Result __result__;
                fixed (void* rotationRef_ = &rotationRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, &modeRef_, rotationRef_,((void**)(*(void**)_nativePointer))[19]);		
                modeRef = new SharpDX.Direct3D9.DisplayModeEx();
                modeRef.__MarshalFrom(ref modeRef_);
                __result__.CheckError();
                return modeRef;
            }
        }
        
        /// <summary>	
        /// <p>Creates a device to represent the display adapter.</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number that denotes the display adapter. D3DADAPTER_DEFAULT is always the primary display adapter.</p> </dd></param>	
        /// <param name="deviceType"><dd>  <p>Specifies the type of device. See <strong><see cref="SharpDX.Direct3D9.DeviceType"/></strong>. If the desired device type is not available, the method will fail.</p> </dd></param>	
        /// <param name="hFocusWindow"><dd>  <p>The focus window alerts Direct3D when an application switches from foreground mode to background mode. For full-screen mode, the window specified must be a top-level window. For windowed mode, this parameter may be <strong><c>null</c></strong> only if the hDeviceWindow member of pPresentationParameters is set to a valid, non-<strong><c>null</c></strong> value.</p> </dd></param>	
        /// <param name="behaviorFlags"><dd>  <p>Combination of one or more options (see <see cref="SharpDX.Direct3D9.CreateFlags"/>) that control device creation.</p> </dd></param>	
        /// <param name="presentationParametersRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> structure, describing the presentation parameters for the device to be created. If <em>BehaviorFlags</em> specifies <see cref="SharpDX.Direct3D9.CreateFlags.AdapterGroupDevice"/>, this parameter is an array. Regardless of the number of heads that exist, only one depth/stencil surface is automatically created.</p> <p>This parameter is both an input and an output parameter. Calling this method may change several members including:</p> <ul> <li>If BackBufferCount, BackBufferWidth, and BackBufferHeight are 0 before the method is called, they will be changed when the method returns.</li> <li>If BackBufferFormat equals <see cref="SharpDX.Direct3D9.Format.Unknown"/> before the method is called, it will be changed when the method returns.</li> </ul> </dd></param>	
        /// <param name="fullscreenDisplayModeRef"><dd>  <p>The display mode for when the device is set to fullscreen. See <strong><see cref="SharpDX.Direct3D9.DisplayModeEx"/></strong>. If <em>BehaviorFlags</em> specifies <see cref="SharpDX.Direct3D9.CreateFlags.AdapterGroupDevice"/>, this parameter is an array. This parameter must be <strong><c>null</c></strong> for windowed mode.</p> </dd></param>	
        /// <param name="returnedDeviceInterfaceOut"><dd>  <p>Address of a reference to the returned <strong><see cref="SharpDX.Direct3D9.DeviceEx"/></strong>, which represents the created device.</p> </dd></param>	
        /// <returns><p>This method returns <see cref="SharpDX.Result.Ok"/> when rendering device along with swapchain buffers are created successfully. <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> is returned when any error other than invalid caller input is encountered.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9Ex::CreateDeviceEx']/*"/>	
        /// <msdn-id>bb174302</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9Ex::CreateDeviceEx([In] unsigned int Adapter,[In] D3DDEVTYPE DeviceType,[In] HWND hFocusWindow,[In] unsigned int BehaviorFlags,[In, Buffer] D3DPRESENT_PARAMETERS* pPresentationParameters,[In, Buffer, Optional] D3DDISPLAYMODEEX* pFullscreenDisplayMode,[Out, Fast] IDirect3DDevice9Ex** ppReturnedDeviceInterface)</unmanaged>	
        /// <unmanaged-short>IDirect3D9Ex::CreateDeviceEx</unmanaged-short>	
        internal void CreateDeviceEx(int adapter, SharpDX.Direct3D9.DeviceType deviceType, System.IntPtr hFocusWindow, int behaviorFlags, SharpDX.Direct3D9.PresentParameters[] presentationParametersRef, SharpDX.Direct3D9.DisplayModeEx[] fullscreenDisplayModeRef, SharpDX.Direct3D9.DeviceEx returnedDeviceInterfaceOut) {
            unsafe {
                SharpDX.Direct3D9.DisplayModeEx.__Native[] fullscreenDisplayModeRef__ = (fullscreenDisplayModeRef == null)? null : new SharpDX.Direct3D9.DisplayModeEx.__Native[fullscreenDisplayModeRef.Length];
				if (fullscreenDisplayModeRef != null)
                for (int i = 0; i < fullscreenDisplayModeRef.Length; i++)
                    fullscreenDisplayModeRef[i].__MarshalTo(ref fullscreenDisplayModeRef__[i]);				
                IntPtr returnedDeviceInterfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* presentationParametersRef_ = presentationParametersRef)
                    fixed (void* fullscreenDisplayModeRef_ = fullscreenDisplayModeRef__)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, unchecked((int)deviceType), (void*)hFocusWindow, behaviorFlags, presentationParametersRef_, fullscreenDisplayModeRef_, &returnedDeviceInterfaceOut_,((void**)(*(void**)_nativePointer))[20]);		
                if (fullscreenDisplayModeRef != null )															
                for (int i = 0; i < fullscreenDisplayModeRef.Length; i++)
                    fullscreenDisplayModeRef[i].__MarshalFree(ref fullscreenDisplayModeRef__[i]);
                ((SharpDX.Direct3D9.DeviceEx)returnedDeviceInterfaceOut).NativePointer = returnedDeviceInterfaceOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>This method returns a unique identifier for the adapter that is specific to the adapter hardware. Applications can use this identifier to define robust mappings across various APIs (Direct3D 9, DXGI).</p>	
        /// </summary>	
        /// <param name="adapter"><dd>  <p>Ordinal number denoting the display adapter from which to retrieve the <see cref="long"/>.</p> </dd></param>	
        /// <returns><dd>  <p>A unique identifier for the given adapter.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3D9Ex::GetAdapterLUID']/*"/>	
        /// <msdn-id>bb174305</msdn-id>	
        /// <unmanaged>HRESULT IDirect3D9Ex::GetAdapterLUID([In] unsigned int Adapter,[Out] LUID* pLUID)</unmanaged>	
        /// <unmanaged-short>IDirect3D9Ex::GetAdapterLUID</unmanaged-short>	
        public long GetAdapterLuid(int adapter) {
            unsafe {
                long lUIDRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adapter, &lUIDRef,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
                return lUIDRef;
            }
        }
    }
    /// <summary>	
    /// <p>Used to set and query effects, and to choose techniques. An effect object can contain multiple techniques to render the same effect.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <see cref="SharpDX.Direct3D9.Effect"/> interface is obtained by calling <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffect"/></strong>, <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromFileW"/></strong>, or <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromResourceW"/></strong>.</p><p>The LPD3DXEFFECT type is defined as a reference to this interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.Effect"/> <see cref="SharpDX.Direct3D9.Effect"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.Effect"/> *LPD3DXEFFECT;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect']/*"/>	
    /// <msdn-id>bb205788</msdn-id>	
    /// <unmanaged>ID3DXEffect</unmanaged>	
    /// <unmanaged-short>ID3DXEffect</unmanaged-short>	
    [Guid("f6ceb4b3-4e4c-40dd-b883-8d8de5ea0cd5")]
    public partial class Effect : SharpDX.Direct3D9.BaseEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Effect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Effect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Effect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Effect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Effect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets a reference to the pool of shared parameters.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Pools contain shared parameters between effects. See Cloning and Sharing (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::GetPool']/*"/>	
        /// <msdn-id>bb205827</msdn-id>	
        /// <unmanaged>GetPool</unmanaged>	
        /// <unmanaged-short>GetPool</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffect::GetPool([Out] ID3DXEffectPool** ppPool)</unmanaged>
        public SharpDX.Direct3D9.EffectPool Pool {
                get { SharpDX.Direct3D9.EffectPool __output__; GetPool(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with the effect.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count for the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call IUnknown::Release when you are done using the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::GetDevice']/*"/>	
        /// <msdn-id>bb205826</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffect::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get or sets the effect state manager.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct3D9.EffectStateManager"/></strong> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::GetStateManager']/*"/>	
        /// <msdn-id>bb205828</msdn-id>	
        /// <unmanaged>GetStateManager / SetStateManager</unmanaged>	
        /// <unmanaged-short>GetStateManager</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffect::GetStateManager([Out] ID3DXEffectStateManager** ppManager)</unmanaged>
        public SharpDX.Direct3D9.EffectStateManager StateManager {
                get { SharpDX.Direct3D9.EffectStateManager __output__; GetStateManager(out __output__); return __output__; }
                set { SetStateManager(value); }
        }
        
        /// <summary>	
        /// <p>Gets a reference to the pool of shared parameters.</p>	
        /// </summary>	
        /// <param name="poolOut"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.EffectPool"/></strong> object. </p> </dd></param>	
        /// <returns><p>This method always returns the value <see cref="SharpDX.Result.Ok"/>.</p></returns>	
        /// <remarks>	
        /// <p>Pools contain shared parameters between effects. See Cloning and Sharing (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::GetPool']/*"/>	
        /// <msdn-id>bb205827</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::GetPool([Out] ID3DXEffectPool** ppPool)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::GetPool</unmanaged-short>	
        internal void GetPool(out SharpDX.Direct3D9.EffectPool poolOut) {
            unsafe {
                IntPtr poolOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &poolOut_,((void**)(*(void**)_nativePointer))[57]);		
                poolOut= (poolOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.EffectPool(poolOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the active technique.</p>	
        /// </summary>	
        /// <param name="hTechnique"><dd>  <p>Unique handle to the technique.  See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::SetTechnique']/*"/>	
        /// <msdn-id>bb205834</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::SetTechnique([In] D3DXHANDLE hTechnique)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::SetTechnique</unmanaged-short>	
        internal void SetTechnique(SharpDX.Direct3D9.EffectHandle hTechnique) {
            unsafe {
                var hTechnique_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hTechnique, ref hTechnique_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hTechnique_,((void**)(*(void**)_nativePointer))[58]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hTechnique, ref hTechnique_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the current technique.</p>	
        /// </summary>	
        /// <returns><p>A unique identifier to the current technique.  See Handles (Direct3D 9).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::GetCurrentTechnique']/*"/>	
        /// <msdn-id>bb205825</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXEffect::GetCurrentTechnique()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::GetCurrentTechnique</unmanaged-short>	
        internal SharpDX.Direct3D9.EffectHandle GetCurrentTechnique() {
            unsafe {
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer,((void**)(*(void**)_nativePointer))[59]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Validate a technique.</p>	
        /// </summary>	
        /// <param name="hTechnique"><dd>  <p>Unique identifier. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.ConflictingRenderState"/>, <see cref="SharpDX.Direct3D9.ResultCode.ConflictingTextureFilter"/>, <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>, <see cref="SharpDX.Direct3D9.ResultCode.TooManyOperations"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedAlphaArgument"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedAlphaOperation"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedColorArgument"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedColorOperation"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedFactorValue"/>, <see cref="SharpDX.Direct3D9.ResultCode.UnsupportedTextureFilter"/>, and <see cref="SharpDX.Direct3D9.ResultCode.WrongTextureFormat"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::ValidateTechnique']/*"/>	
        /// <msdn-id>bb205835</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::ValidateTechnique([In] D3DXHANDLE hTechnique)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::ValidateTechnique</unmanaged-short>	
        public void ValidateTechnique(SharpDX.Direct3D9.EffectHandle hTechnique) {
            unsafe {
                var hTechnique_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hTechnique, ref hTechnique_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hTechnique_,((void**)(*(void**)_nativePointer))[60]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hTechnique, ref hTechnique_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Searches for the next valid technique, starting at the technique after the specified technique.</p>	
        /// </summary>	
        /// <param name="hTechnique"><dd>  <p>Unique identifier to a technique. See Handles (Direct3D 9). Specify <strong><c>null</c></strong> for this parameter to find the first valid technique.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to an identifier for the next technique. <strong><c>null</c></strong> is returned if this is the last technique.  See Handles (Direct3D 9).</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::FindNextValidTechnique']/*"/>	
        /// <msdn-id>bb205824</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::FindNextValidTechnique([In] D3DXHANDLE hTechnique,[Out] D3DXHANDLE* pTechnique)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::FindNextValidTechnique</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle FindNextValidTechnique(SharpDX.Direct3D9.EffectHandle hTechnique) {
            unsafe {
                var hTechnique_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hTechnique, ref hTechnique_);
                SharpDX.Direct3D9.EffectHandle techniqueRef;
                var techniqueRef_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hTechnique_, &techniqueRef_,((void**)(*(void**)_nativePointer))[61]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hTechnique, ref hTechnique_);
                techniqueRef = new SharpDX.Direct3D9.EffectHandle();
                SharpDX.Direct3D9.EffectHandle.__MarshalFrom(ref techniqueRef, ref techniqueRef_);
                __result__.CheckError();
                return techniqueRef;
            }
        }
        
        /// <summary>	
        /// <p>Determines if a parameter is used by the technique.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier for the parameter.  See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="hTechnique"><dd>  <p>Unique identifier for the technique.  See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><p>Returns <strong>TRUE</strong> if the parameter is being used and returns <strong><see cref="SharpDX.Result.False"/></strong> if the parameter is not being used.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::IsParameterUsed']/*"/>	
        /// <msdn-id>bb205829</msdn-id>	
        /// <unmanaged>BOOL ID3DXEffect::IsParameterUsed([In] D3DXHANDLE hParameter,[In] D3DXHANDLE hTechnique)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::IsParameterUsed</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool IsParameterUsed(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Direct3D9.EffectHandle hTechnique) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                var hTechnique_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hTechnique, ref hTechnique_);
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, hParameter_, hTechnique_,((void**)(*(void**)_nativePointer))[62]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hTechnique, ref hTechnique_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Starts an active technique.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>DWORD that determines if state modified by an effect is saved and restored. The default value 0 specifies that <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> will save and restore all state modified by the effect (including pixel and vertex shader constants). Valid flags can be seen at Effect State Save and Restore Flags.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a value returned that indicates the number of passes needed to render the current technique. </p> </dd></returns>	
        /// <remarks>	
        /// <p>An application sets one active technique in the effect system by calling <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong>. The effect system responds by capturing all the pipeline state that can be changed by the technique in a state block. An application signals the end of a technique by calling <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong>, which uses the state block to restore the original state. The effect system, therefore, takes care of saving state when a technique becomes active and restoring state when a technique ends. If you choose to disable this save and restore functionality, see <see cref="SharpDX.Direct3D9.FX.DoNotSaveSamplerState"/>.</p><p>Within the <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> pair, an application uses <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong> to set the active pass, <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong> if any state changes occurred after the pass was activated, and <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> to end the active pass.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::Begin']/*"/>	
        /// <msdn-id>bb205815</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::Begin([Out] unsigned int* pPasses,[In] D3DXFX Flags)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::Begin</unmanaged-short>	
        public int Begin(SharpDX.Direct3D9.FX flags) {
            unsafe {
                int passesRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &passesRef, unchecked((int)flags),((void**)(*(void**)_nativePointer))[63]);		
                __result__.CheckError();
                return passesRef;
            }
        }
        
        /// <summary>	
        /// <p>Begins a pass, within the active technique.</p>	
        /// </summary>	
        /// <param name="pass"><dd>  <p>A zero-based integer index into the technique.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>An application sets one active pass (within one active technique) in the effect system by calling <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>. An application signals the end of the active pass by calling <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong>. <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> must occur in a matching pair, within a matching pair of <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> calls.</p><p>If the application changes any effect state using any of the <strong>Effect::Setx</strong> methods inside of a <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>/<strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> matching pair, the application must call <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong> to set the update the device with the state changes. If no state changes occur within a <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> matching pair, it is not necessary to call <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::BeginPass']/*"/>	
        /// <msdn-id>bb205817</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::BeginPass([In] unsigned int Pass)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::BeginPass</unmanaged-short>	
        public void BeginPass(int pass) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, pass,((void**)(*(void**)_nativePointer))[64]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Propagate state changes that occur inside of an active pass to the device before rendering.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>If the application changes any effect state using any of the <strong>ID3DXEffect::Setx</strong> methods inside of an <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>/<strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> matching pair, the application must call <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong> before any DrawxPrimitive call to propagate state changes to the device before rendering. If no state changes occur within a <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> matching pair, it is not necessary to call <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong>.</p><p>This is slightly different for any shared parameters in a cloned effect. When a technique is active on a cloned effect (that is, when <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> has been called but and <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> has not been called), <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong> updates parameters that are not shared as expected. To update a shared parameter (only for a cloned effect whose technique is active), call <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> to deactivate the technique and <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> to reactivate the technique before calling <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::CommitChanges']/*"/>	
        /// <msdn-id>bb205819</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::CommitChanges()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::CommitChanges</unmanaged-short>	
        public void CommitChanges() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[65]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>End an active pass.</p>	
        /// </summary>	
        /// <returns><p>This method always returns the value <see cref="SharpDX.Result.Ok"/>.</p></returns>	
        /// <remarks>	
        /// <p>An application signals the end of rendering an active pass by calling <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong>. Each <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> must be part of a matching pair of <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> calls.</p><p>Each matching pair of <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> calls must be located within a matching pair of <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> calls.</p><p>If the application changes any effect state using any of the <strong>Effect::Setx</strong> methods inside of a <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>/<strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong> matching pair, the application must call <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong> before any DrawxPrimitive call to propagate state changes to the device before rendering.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::EndPass']/*"/>	
        /// <msdn-id>bb205823</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::EndPass()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::EndPass</unmanaged-short>	
        public void EndPass() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[66]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Ends an active technique.</p>	
        /// </summary>	
        /// <returns><p>This method always returns the value <see cref="SharpDX.Result.Ok"/>.</p></returns>	
        /// <remarks>	
        /// <p>All rendering in an effect is done within a matching pair of <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> calls. After all passes are rendered, <strong><see cref="SharpDX.Direct3D9.Effect.End"/></strong> must be called to end the active technique. The effect system responds by using the state block created when <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong> was called, to automatically restore the pipeline state before <strong><see cref="SharpDX.Direct3D9.Effect.Begin"/></strong>.</p><p>By default, the effect system takes care of saving state prior to a technique, and restoring state after a technique. If you choose to disable this save and restore functionality, see <see cref="SharpDX.Direct3D9.FX.DoNotSaveSamplerState"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::End']/*"/>	
        /// <msdn-id>bb205821</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::End()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::End</unmanaged-short>	
        public void End() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[67]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with the effect.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the effect. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count for the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call IUnknown::Release when you are done using the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::GetDevice']/*"/>	
        /// <msdn-id>bb205826</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[68]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method should be called whenever the device is lost or before the user calls <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>. Even if the device was not actually lost, <strong><see cref="SharpDX.Direct3D9.Effect.OnLostDevice"/></strong> is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> and then <strong><see cref="SharpDX.Direct3D9.Effect.OnResetDevice"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::OnLostDevice']/*"/>	
        /// <msdn-id>bb205830</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::OnLostDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::OnLostDevice</unmanaged-short>	
        public void OnLostDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[69]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to re-acquire resources and save initial state.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Effect.OnResetDevice"/></strong> should be called each time the device is reset (using <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::OnResetDevice']/*"/>	
        /// <msdn-id>bb205831</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::OnResetDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::OnResetDevice</unmanaged-short>	
        public void OnResetDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[70]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set the effect state manager.</p>	
        /// </summary>	
        /// <param name="managerRef"><dd>  <p>A reference to the state manager. See <strong><see cref="SharpDX.Direct3D9.EffectStateManager"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct3D9.EffectStateManager"/></strong> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::SetStateManager']/*"/>	
        /// <msdn-id>bb205833</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::SetStateManager([In] ID3DXEffectStateManager* pManager)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::SetStateManager</unmanaged-short>	
        internal void SetStateManager(SharpDX.Direct3D9.EffectStateManager managerRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((managerRef == null)?IntPtr.Zero:managerRef.NativePointer),((void**)(*(void**)_nativePointer))[71]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the effect state manager.</p>	
        /// </summary>	
        /// <param name="managerOut"><dd>  <p>Returns a reference to the state manager. See <strong><see cref="SharpDX.Direct3D9.EffectStateManager"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct3D9.EffectStateManager"/></strong> is a user-implemented interface that furnishes callbacks into an application for setting device state from an effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::GetStateManager']/*"/>	
        /// <msdn-id>bb205828</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::GetStateManager([Out] ID3DXEffectStateManager** ppManager)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::GetStateManager</unmanaged-short>	
        internal void GetStateManager(out SharpDX.Direct3D9.EffectStateManager managerOut) {
            unsafe {
                IntPtr managerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &managerOut_,((void**)(*(void**)_nativePointer))[72]);		
                managerOut= (managerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.EffectStateManager(managerOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Start capturing state changes in a parameter block.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>Capture effect parameter state changes until EndParameterBlock is called. Effect parameters include any state changes outside of a pass. Delete parameter blocks if they are no longer needed by calling DeleteParameterBlock.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::BeginParameterBlock']/*"/>	
        /// <msdn-id>bb205816</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::BeginParameterBlock()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::BeginParameterBlock</unmanaged-short>	
        public void BeginParameterBlock() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[73]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Stop capturing effect parameter state changes.</p>	
        /// </summary>	
        /// <returns><p>Returns a handle to the parameter state block.</p></returns>	
        /// <remarks>	
        /// <p>All effect parameters that change state (after calling BeginParameterBlock and before calling EndParameterBlock) will be saved in an effect parameter state block. Use ApplyParameterBlock to apply this block of state changes to the effect system. Once you are finished with a state block use DeleteParameterBlock to free the memory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::EndParameterBlock']/*"/>	
        /// <msdn-id>bb205822</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXEffect::EndParameterBlock()</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::EndParameterBlock</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle EndParameterBlock() {
            unsafe {
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer,((void**)(*(void**)_nativePointer))[74]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Apply the values in a state block to the current effect system state.</p>	
        /// </summary>	
        /// <param name="hParameterBlock"><dd>  <p>A handle to the parameter block. This is the handle returned by <strong><see cref="SharpDX.Direct3D9.Effect.EndParameterBlock"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>Capture effect parameter state changes in a parameter block by calling BeginParameterBlock; stop capturing state changes by calling EndParameterBlock. These state changes include any effect parameter changes that occur inside of a technique (including those outside of a pass). Once you are done with the parameter block, call DeleteParameterBlock to recover memory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::ApplyParameterBlock']/*"/>	
        /// <msdn-id>bb205814</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::ApplyParameterBlock([In] D3DXHANDLE hParameterBlock)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::ApplyParameterBlock</unmanaged-short>	
        public void ApplyParameterBlock(SharpDX.Direct3D9.EffectHandle hParameterBlock) {
            unsafe {
                var hParameterBlock_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameterBlock, ref hParameterBlock_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameterBlock_,((void**)(*(void**)_nativePointer))[75]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameterBlock, ref hParameterBlock_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Delete a parameter block.</p>	
        /// </summary>	
        /// <param name="hParameterBlock"><dd>  <p>A handle to the parameter block. This is the handle returned by <strong><see cref="SharpDX.Direct3D9.Effect.EndParameterBlock"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>Parameter blocks are blocks of effect states. Use a parameter block to record state changes so that they can be applied later on with a single API call. When no longer needed, delete the parameter block to reduce memory usage.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::DeleteParameterBlock']/*"/>	
        /// <msdn-id>bb205820</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::DeleteParameterBlock([In] D3DXHANDLE hParameterBlock)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::DeleteParameterBlock</unmanaged-short>	
        public void DeleteParameterBlock(SharpDX.Direct3D9.EffectHandle hParameterBlock) {
            unsafe {
                var hParameterBlock_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameterBlock, ref hParameterBlock_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameterBlock_,((void**)(*(void**)_nativePointer))[76]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameterBlock, ref hParameterBlock_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a copy of an effect.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the effect. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Effect"/></strong> interface, containing the cloned effect. </p> </dd></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??This function will not clone an effect if the user specifies <see cref="SharpDX.Direct3D9.FX.NotCloneable"/> during effect creation.</p><p>To update shared and non-shared parameters in an active technique of a cloned effect, see <strong><see cref="SharpDX.Direct3D9.Effect.CommitChanges"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::CloneEffect']/*"/>	
        /// <msdn-id>bb205818</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::CloneEffect([In] IDirect3DDevice9* pDevice,[Out] ID3DXEffect** ppEffect)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::CloneEffect</unmanaged-short>	
        public SharpDX.Direct3D9.Effect Clone(SharpDX.Direct3D9.Device deviceRef) {
            unsafe {
                SharpDX.Direct3D9.Effect effectOut;
                IntPtr effectOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), &effectOut_,((void**)(*(void**)_nativePointer))[77]);		
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Effect(effectOut_);	
                __result__.CheckError();
                return effectOut;
            }
        }
        
        /// <summary>	
        /// <p>Set a contiguous range of shader constants with a memory copy.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Handle to the value to set, or the name of the value passed in as a string. Passing in a handle is more efficient. See Handles (Direct3D 9). </p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to a buffer containing the data to be set. SetRawValue checks for valid memory, but does not do any checking for valid data.</p> </dd></param>	
        /// <param name="byteOffset"><dd>  <p>Number of bytes between the beginning of the effect data and the beginning of the effect constants you are going to set.</p> </dd></param>	
        /// <param name="bytes"><dd>  <p>The size of the buffer to be set, in bytes.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following:E_INVALIDCALL.</p></returns>	
        /// <remarks>	
        /// <p>SetRawValue is a very fast way to set effect constants since it performs a memory copy without performing validation or any data conversion (like converting a row-major matrix to a column-major matrix). Use SetRawValue to set a series of contiguous effect constants. For instance, you could set an array of twenty matrices with 20 calls to <strong><see cref="SharpDX.Direct3D9.BaseEffect.SetMatrix"/></strong> or by using a single SetRawValue.</p><p>All values are expected to be either matrix4x4s or float4s and all matrices are expected to be in column-major order. Int or float values are cast into a float4; therefore, it is highly recommended that you use SetRawValue with only float4 or matrix4x4 data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffect::SetRawValue']/*"/>	
        /// <msdn-id>bb205832</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffect::SetRawValue([In] D3DXHANDLE hParameter,[In] const void* pData,[In] unsigned int ByteOffset,[In] unsigned int Bytes)</unmanaged>	
        /// <unmanaged-short>ID3DXEffect::SetRawValue</unmanaged-short>	
        internal void SetRawValue(SharpDX.Direct3D9.EffectHandle hParameter, System.IntPtr dataRef, int byteOffset, int bytes) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, (void*)dataRef, byteOffset, bytes,((void**)(*(void**)_nativePointer))[78]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.EffectCompiler"/></strong> interface compiles an effect from a function or from a vertex shader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <see cref="SharpDX.Direct3D9.EffectCompiler"/> interface is obtained by calling <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompiler"/></strong>, <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompilerFromFileW"/></strong>, or <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompilerFromResourceW"/></strong>.</p><p>The LPD3DXEFFECTCOMPILER type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.EffectCompiler"/> <see cref="SharpDX.Direct3D9.EffectCompiler"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.EffectCompiler"/> *LPD3DXEFFECTCOMPILER;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectCompiler']/*"/>	
    /// <msdn-id>bb205789</msdn-id>	
    /// <unmanaged>ID3DXEffectCompiler</unmanaged>	
    /// <unmanaged-short>ID3DXEffectCompiler</unmanaged-short>	
    [Guid("51b8a949-1a31-47e6-bea0-4b30db53f1e0")]
    public partial class EffectCompiler : SharpDX.Direct3D9.BaseEffect {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.EffectCompiler"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectCompiler(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.EffectCompiler"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.EffectCompiler(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.EffectCompiler(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Toggles the literal status of a parameter. A literal parameter has a value that doesn't change during the lifetime of an effect.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier to a parameter. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="literal"><dd>  <p>Set to <strong>TRUE</strong> to make the parameter a literal, and <strong><see cref="SharpDX.Result.False"/></strong> if the parameter can change value during the shader lifetime.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This methods only changes whether the parameter is a literal or not. To change the value of a parameter, use a method like <strong><see cref="SharpDX.Direct3D9.BaseEffect.SetBool"/></strong> or <strong><see cref="SharpDX.Direct3D9.BaseEffect.SetValue"/></strong>.</p><p>This function must be called before the effect is compiled.  Here is an example of how one might use this function:</p><pre> LPD3DXEFFECTCOMPILER pEffectCompiler; char errors[1000]; <see cref="SharpDX.Result"/> hr; hr = <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompilerFromFileW"/>("shader.fx", <c>null</c>, <c>null</c>, 0, &amp;pEffectCompiler,  &amp;errors); //In the fx file, literalInt is declared as an int. //By calling this function, the compiler will treat //it as a literal (i.e. #define) hr = pEffectCompiler-&gt;SetLiteral("literalInt", TRUE); //create ten different variations of the same effect LPD3DXBUFFER pEffects[10]; LPD3DXBUFFER pErrors; for(int i = 0; i &lt; 10; ++i) { hr = pEffectCompiler-&gt;SetInt("literalInt", i); hr = pEffectCompiler-&gt;CompileEffect(0, &amp;pEffects[i], &amp;pErrors); }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectCompiler::SetLiteral']/*"/>	
        /// <msdn-id>bb205793</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectCompiler::SetLiteral([In] D3DXHANDLE hParameter,[In] BOOL Literal)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectCompiler::SetLiteral</unmanaged-short>	
        public void SetLiteral(SharpDX.Direct3D9.EffectHandle hParameter, SharpDX.Mathematics.Interop.RawBool literal) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint85(_nativePointer, hParameter_, literal,((void**)(*(void**)_nativePointer))[57]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a literal status of a parameter. A literal parameter has a value that doesn't change during the lifetime of an effect.</p>	
        /// </summary>	
        /// <param name="hParameter"><dd>  <p>Unique identifier to a parameter. See Handles (Direct3D 9).</p> </dd></param>	
        /// <returns><dd>  <p>Returns True if the parameter is a literal, and False otherwise.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This methods only changes whether the parameter is a literal or not. To change the value of a parameter, use a method like <strong><see cref="SharpDX.Direct3D9.BaseEffect.SetBool"/></strong> or <strong><see cref="SharpDX.Direct3D9.BaseEffect.SetValue"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectCompiler::GetLiteral']/*"/>	
        /// <msdn-id>bb205792</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectCompiler::GetLiteral([In] D3DXHANDLE hParameter,[Out] BOOL* pLiteral)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectCompiler::GetLiteral</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawBool GetLiteral(SharpDX.Direct3D9.EffectHandle hParameter) {
            unsafe {
                var hParameter_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hParameter, ref hParameter_);
                SharpDX.Mathematics.Interop.RawBool literalRef;
                literalRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hParameter_, &literalRef,((void**)(*(void**)_nativePointer))[58]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hParameter, ref hParameter_);
                __result__.CheckError();
                return literalRef;
            }
        }
        
        /// <summary>	
        /// <p>Compile an effect.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags for details.</p> </dd></param>	
        /// <param name="effectOut"><dd>  <p>Buffer containing the compiled effect. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>Buffer containing at least the first compile error message that occurred. This includes effect compiler errors and high-level language compile errors. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>.</p><p>If the arguments are invalid, the method will return <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p><p>If the method fails, the return value will be E_FAIL.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectCompiler::CompileEffect']/*"/>	
        /// <msdn-id>bb205790</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectCompiler::CompileEffect([In] unsigned int Flags,[In] ID3DXBuffer** ppEffect,[In] ID3DXBuffer** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectCompiler::CompileEffect</unmanaged-short>	
        internal void CompileEffect(int flags, out SharpDX.Direct3D.Blob effectOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr effectOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, &effectOut_, &errorMsgsOut_,((void**)(*(void**)_nativePointer))[59]);		
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Compiles a shader from an effect that contains one or more functions.</p>	
        /// </summary>	
        /// <param name="hFunction"><dd>  <p>Unique identifier to the function to be compiled. This value must not be <strong><c>null</c></strong>. See Handles (Direct3D 9).</p> </dd></param>	
        /// <param name="targetRef"><dd>  <p>Pointer to a shader profile which determines the shader instruction set. See <strong><see cref="SharpDX.Direct3D9.D3DX9.GetVertexShaderProfile"/></strong> or <strong><see cref="SharpDX.Direct3D9.D3DX9.GetPixelShaderProfile"/></strong> for a list of the profiles available.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags for details.</p> </dd></param>	
        /// <param name="shaderOut"><dd>  <p>Buffer containing the compiled shader. The compiler shader is an array of DWORDs. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>Buffer containing at least the first compile error message that occurred. This includes effect compiler errors and high-level language compile errors. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="constantTableOut"><dd>  <p>Returns an <strong><see cref="SharpDX.Direct3D9.ConstantTable"/></strong> interface, which can be used to access shader constants. This value can be <strong><c>null</c></strong>. If you compile your application as large address aware (that is, you use the /LARGEADDRESSAWARE linker option to handle addresses larger than 2 GB), you cannot use this parameter and must set it to <strong><c>null</c></strong>. Instead, you must use the <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderConstantTableEx"/></strong> function to retrieve the shader-constant table that is embedded inside the shader. In this <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderConstantTableEx"/></strong> call, you must pass the <strong>D3DXCONSTTABLE_LARGEADDRESSAWARE</strong> flag to the <em>Flags</em> parameter to specify to access up to 4 GB of virtual address space.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>.</p><p>If the arguments are invalid, the method will return <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p><p>If the method fails, the return value will be E_FAIL.</p></returns>	
        /// <remarks>	
        /// <p>Targets can be specified for vertex shaders, pixel shaders, and texture fill functions.</p><table> <tr><td>Vertex shader targets</td><td>vs_1_1, vs_2_0, vs_2_sw, vs_3_0</td></tr> <tr><td>Pixel shader targets</td><td>ps_1_1, ps_1_2, ps_1_3, ps_1_4, ps_2_0, ps_2_sw, ps_3_0</td></tr> <tr><td>Texture fill targets</td><td>tx_0, tx_1</td></tr> </table><p>?</p><p>This method compiles a shader from a function that is written in a C-like language. For more information, see HLSL.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectCompiler::CompileShader']/*"/>	
        /// <msdn-id>bb205791</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectCompiler::CompileShader([In] D3DXHANDLE hFunction,[In] const char* pTarget,[In] unsigned int Flags,[In] ID3DXBuffer** ppShader,[In] ID3DXBuffer** ppErrorMsgs,[In] ID3DXConstantTable** ppConstantTable)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectCompiler::CompileShader</unmanaged-short>	
        internal void CompileShader(SharpDX.Direct3D9.EffectHandle hFunction, string targetRef, int flags, out SharpDX.Direct3D.Blob shaderOut, out SharpDX.Direct3D.Blob errorMsgsOut, out SharpDX.Direct3D9.ConstantTable constantTableOut) {
            unsafe {
                var hFunction_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref hFunction, ref hFunction_);
                IntPtr targetRef_ = Utilities.StringToHGlobalAnsi(targetRef);
                IntPtr shaderOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                IntPtr constantTableOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, hFunction_, (void*)targetRef_, flags, &shaderOut_, &errorMsgsOut_, &constantTableOut_,((void**)(*(void**)_nativePointer))[60]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref hFunction, ref hFunction_);
                Marshal.FreeHGlobal(targetRef_ );
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                constantTableOut= (constantTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ConstantTable(constantTableOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the <strong><see cref="SharpDX.Direct3D9.EffectPool"/></strong> interface to identify parameters that are going to be shared across effects. See parameter sharing in Cloning and Sharing (Direct3D 9). This interface has no methods.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <see cref="SharpDX.Direct3D9.EffectPool"/> interface is obtained by calling <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectPool"/></strong>.</p><p>The LPD3DXEFFECTPOOL type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.EffectPool"/> <see cref="SharpDX.Direct3D9.EffectPool"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.EffectPool"/> *LPD3DXEFFECTPOOL;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectPool']/*"/>	
    /// <msdn-id>bb205794</msdn-id>	
    /// <unmanaged>ID3DXEffectPool</unmanaged>	
    /// <unmanaged-short>ID3DXEffectPool</unmanaged-short>	
    [Guid("9537ab04-3250-412e-8213-fcd2f8677933")]
    public partial class EffectPool : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.EffectPool"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectPool(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.EffectPool"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.EffectPool(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.EffectPool(nativePointer);
		}
        
    }
    /// <summary>	
    /// <p> This is a user-implemented interface that allows a user to set the device state from an effect. Each of the methods in this interface must be implemented by the user and will then be used as callbacks to the application when either of the following occur: </p><ul> <li>An effect calls <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>Effect state is dynamically updated by calling the appropriate state change API. See individual method pages for details.</li> </ul><p>When an application uses the state manager to implement custom callbacks, an effect no longer automatically saves and restores state when calling <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.EndPass"/></strong>. Because the application has implemented a custom save and restore behavior in the callbacks, this automatic behavior is bypassed.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A user creates an <see cref="SharpDX.Direct3D9.EffectStateManager"/> interface by implementing a class that derives from this interface, and implementing all the interface methods. Once the interface is created, you can get or set the state manager within an effect using <strong><see cref="SharpDX.Direct3D9.Effect.GetStateManager"/></strong> and <strong><see cref="SharpDX.Direct3D9.Effect.SetStateManager"/></strong>.</p><p>The LPD3DXEFFECTSTATEMANAGER type is defined as a reference to this interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.EffectStateManager"/> <see cref="SharpDX.Direct3D9.EffectStateManager"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.EffectStateManager"/> *LPD3DXEFFECTSTATEMANAGER;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager']/*"/>	
    /// <msdn-id>bb205795</msdn-id>	
    /// <unmanaged>ID3DXEffectStateManager</unmanaged>	
    /// <unmanaged-short>ID3DXEffectStateManager</unmanaged-short>	
    [Guid("79aab587-6dbc-4fa7-82de-37fa1781c5ce")]
    public partial class EffectStateManager : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.EffectStateManager"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectStateManager(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.EffectStateManager"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.EffectStateManager(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.EffectStateManager(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set material state.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetMaterial']/*"/>	
        /// <msdn-id>bb205799</msdn-id>	
        /// <unmanaged>SetMaterial</unmanaged>	
        /// <unmanaged-short>SetMaterial</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetMaterial([In] const D3DMATERIAL9* pMaterial)</unmanaged>
        public SharpDX.Direct3D9.Material Material {
                set { SetMaterial(ref value); }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set the number of subdivision segments for N-patches.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetNPatchMode']/*"/>	
        /// <msdn-id>bb205800</msdn-id>	
        /// <unmanaged>SetNPatchMode</unmanaged>	
        /// <unmanaged-short>SetNPatchMode</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetNPatchMode([In] float NumSegments)</unmanaged>
        public float NPatchMode {
                set { SetNPatchMode(value); }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a FVF code.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetFVF']/*"/>	
        /// <msdn-id>bb205797</msdn-id>	
        /// <unmanaged>SetFVF</unmanaged>	
        /// <unmanaged-short>SetFVF</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetFVF([In] D3DFVF FVF)</unmanaged>
        public SharpDX.Direct3D9.VertexFormat VertexFormat {
                set { SetVertexFormat(value); }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a vertex shader.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetVertexShader']/*"/>	
        /// <msdn-id>bb205810</msdn-id>	
        /// <unmanaged>SetVertexShader</unmanaged>	
        /// <unmanaged-short>SetVertexShader</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShader([In] IDirect3DVertexShader9* pShader)</unmanaged>
        public SharpDX.Direct3D9.VertexShader VertexShader {
                set { SetVertexShader(value); }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a pixel shader.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetPixelShader']/*"/>	
        /// <msdn-id>bb205801</msdn-id>	
        /// <unmanaged>SetPixelShader</unmanaged>	
        /// <unmanaged-short>SetPixelShader</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShader([In] IDirect3DPixelShader9* pShader)</unmanaged>
        public SharpDX.Direct3D9.PixelShader PixelShader {
                set { SetPixelShader(value); }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a transform.</p>	
        /// </summary>	
        /// <param name="state"><dd>  <p>The type of transform to apply the matrix to. See <strong><see cref="SharpDX.Direct3D9.TransformState"/></strong>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>A transformation matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetTransform_"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetTransform']/*"/>	
        /// <msdn-id>bb205809</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetTransform([In] D3DTRANSFORMSTATETYPE State,[In] const D3DMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetTransform</unmanaged-short>	
        public void SetTransform(SharpDX.Direct3D9.TransformState state, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)state), matrixRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set material state.</p>	
        /// </summary>	
        /// <param name="materialRef"><dd>  <p>A reference to the material state. See <strong><see cref="SharpDX.Direct3D9.Material"/></strong>.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetMaterial"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetMaterial']/*"/>	
        /// <msdn-id>bb205799</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetMaterial([In] const D3DMATERIAL9* pMaterial)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetMaterial</unmanaged-short>	
        internal void SetMaterial(ref SharpDX.Direct3D9.Material materialRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* materialRef_ = &materialRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, materialRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a light.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The zero-based index of the light. This is the same index  in <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong>.</p> </dd></param>	
        /// <param name="lightRef"><dd>  <p>The light object. See <strong><see cref="SharpDX.Direct3D9.Light"/></strong>.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetLight']/*"/>	
        /// <msdn-id>bb205798</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetLight([In] unsigned int Index,[In] const D3DLIGHT9* pLight)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetLight</unmanaged-short>	
        public void SetLight(int index, ref SharpDX.Direct3D9.Light lightRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* lightRef_ = &lightRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index, lightRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to enable/disable a light.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The zero-based index of the light. This is the same index in <strong><see cref="SharpDX.Direct3D9.Device.SetLight"/></strong>.</p> </dd></param>	
        /// <param name="enable"><dd>  <p>True to enable the light, false otherwise.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.EnableLight"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::LightEnable']/*"/>	
        /// <msdn-id>bb205796</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::LightEnable([In] unsigned int Index,[In] BOOL Enable)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::LightEnable</unmanaged-short>	
        public void LightEnable(int index, SharpDX.Mathematics.Interop.RawBool enable) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint28(_nativePointer, index, enable,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set render state.</p>	
        /// </summary>	
        /// <param name="state"><dd>  <p>The render state to set. <strong><see cref="SharpDX.Direct3D9.RenderState"/></strong> </p> </dd></param>	
        /// <param name="value"><dd>  <p>The render state value. See Effect States (Direct3D 9).</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetRenderState"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetRenderState']/*"/>	
        /// <msdn-id>bb205805</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetRenderState([In] D3DRENDERSTATETYPE State,[In] unsigned int Value)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetRenderState</unmanaged-short>	
        public void SetRenderState(SharpDX.Direct3D9.RenderState state, int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)state), value,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a texture.</p>	
        /// </summary>	
        /// <param name="stage"><dd>  <p>The stage to which the texture is assigned. This is the index value in <strong><see cref="SharpDX.Direct3D9.Device.SetTexture"/></strong> or <strong><see cref="SharpDX.Direct3D9.Device.SetTextureStageState"/></strong>. </p> </dd></param>	
        /// <param name="textureRef"><dd>  <p>A reference to the texture object. This can be any of the Direct3D texture types (cube, volume, etc.). See <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong>.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetTexture"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetTexture']/*"/>	
        /// <msdn-id>bb205807</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetTexture([In] unsigned int Stage,[In] IDirect3DBaseTexture9* pTexture)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetTexture</unmanaged-short>	
        public void SetTexture(int stage, SharpDX.Direct3D9.BaseTexture textureRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, stage, (void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set the texture stage state.</p>	
        /// </summary>	
        /// <param name="stage"><dd>  <p>The stage that the texture is assigned to. This is the index value in <strong><see cref="SharpDX.Direct3D9.Device.SetTexture"/></strong> or <strong><see cref="SharpDX.Direct3D9.Device.SetTextureStageState"/></strong>. </p> </dd></param>	
        /// <param name="type"><dd>  <p>Defines the type of operation that a texture stage will perform. See  <strong><see cref="SharpDX.Direct3D9.TextureStage"/></strong>. </p> </dd></param>	
        /// <param name="value"><dd>  <p>Can be either an operation (<strong><see cref="SharpDX.Direct3D9.TextureOperation"/></strong>) or an argument value (<see cref="SharpDX.Direct3D9.TextureArgument"/>), depending on what is chosen for Type.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetTextureStageState"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetTextureStageState']/*"/>	
        /// <msdn-id>bb205808</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetTextureStageState([In] unsigned int Stage,[In] D3DTEXTURESTAGESTATETYPE Type,[In] unsigned int Value)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetTextureStageState</unmanaged-short>	
        public void SetTextureStageState(int stage, SharpDX.Direct3D9.TextureStage type, int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, stage, unchecked((int)type), value,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a sampler.</p>	
        /// </summary>	
        /// <param name="sampler"><dd>  <p>The zero-based sampler number. </p> </dd></param>	
        /// <param name="type"><dd>  <p>Identifies sampler state, which can specify the filtering, addressing, or the border color. See <strong><see cref="SharpDX.Direct3D9.SamplerState"/></strong>.</p> </dd></param>	
        /// <param name="value"><dd>  <p>A value from one of the sampler state types in Type. </p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetSamplerState"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetSamplerState']/*"/>	
        /// <msdn-id>bb205806</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetSamplerState([In] unsigned int Sampler,[In] D3DSAMPLERSTATETYPE Type,[In] unsigned int Value)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetSamplerState</unmanaged-short>	
        public void SetSamplerState(int sampler, SharpDX.Direct3D9.SamplerState type, int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, sampler, unchecked((int)type), value,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set the number of subdivision segments for N-patches.</p>	
        /// </summary>	
        /// <param name="numSegments"><dd>  <p>Break the surface into this number of subdivisions. This is the same as the number used by <strong><see cref="SharpDX.Direct3D9.Device.SetNPatchMode"/></strong>.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetNPatchMode"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetNPatchMode']/*"/>	
        /// <msdn-id>bb205800</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetNPatchMode([In] float NumSegments)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetNPatchMode</unmanaged-short>	
        internal void SetNPatchMode(float numSegments) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, numSegments,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a FVF code.</p>	
        /// </summary>	
        /// <param name="vertexFormat"><dd>  <p>The FVF constant, that determines how to interpret vertex data. See <see cref="SharpDX.Direct3D9.VertexFormat"/>.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetVertexFormat"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetFVF']/*"/>	
        /// <msdn-id>bb205797</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetFVF([In] D3DFVF FVF)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetFVF</unmanaged-short>	
        internal void SetVertexFormat(SharpDX.Direct3D9.VertexFormat vertexFormat) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)vertexFormat),((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a vertex shader.</p>	
        /// </summary>	
        /// <param name="shaderRef"><dd>  <p>A reference to a vertex shader object. See <strong><see cref="SharpDX.Direct3D9.VertexShader"/></strong>. </p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShader"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetVertexShader']/*"/>	
        /// <msdn-id>bb205810</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShader([In] IDirect3DVertexShader9* pShader)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetVertexShader</unmanaged-short>	
        internal void SetVertexShader(SharpDX.Direct3D9.VertexShader shaderRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set an array of vertex shader floating-point constants.</p>	
        /// </summary>	
        /// <param name="registerIndex"><dd>  <p>The zero-based index of the first constant register.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>An array of floating-point constants.</p> </dd></param>	
        /// <param name="registerCount"><dd>  <p>The number of registers in pConstantData.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShaderConstantF"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetVertexShaderConstantF']/*"/>	
        /// <msdn-id>bb205812</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShaderConstantF([In] unsigned int RegisterIndex,[In] const float* pConstantData,[In] unsigned int RegisterCount)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetVertexShaderConstantF</unmanaged-short>	
        public void SetVertexShaderConstantF(int registerIndex, float constantDataRef, int registerCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, registerIndex, &constantDataRef, registerCount,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set an array of vertex shader integer constants.</p>	
        /// </summary>	
        /// <param name="registerIndex"><dd>  <p>The zero-based index of the first constant register.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>An array of integer constants.</p> </dd></param>	
        /// <param name="registerCount"><dd>  <p>The number of registers in pConstantData.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShaderConstantI"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetVertexShaderConstantI']/*"/>	
        /// <msdn-id>bb205813</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShaderConstantI([In] unsigned int RegisterIndex,[In] const int* pConstantData,[In] unsigned int RegisterCount)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetVertexShaderConstantI</unmanaged-short>	
        public void SetVertexShaderConstantI(int registerIndex, int constantDataRef, int registerCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, registerIndex, &constantDataRef, registerCount,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set an array of vertex shader Boolean constants.</p>	
        /// </summary>	
        /// <param name="registerIndex"><dd>  <p>The zero-based index of the first constant register.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>An array of Boolean constants.</p> </dd></param>	
        /// <param name="registerCount"><dd>  <p>The number of registers in pConstantData.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetVertexShaderConstantB"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetVertexShaderConstantB']/*"/>	
        /// <msdn-id>bb205811</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetVertexShaderConstantB([In] unsigned int RegisterIndex,[In] const BOOL* pConstantData,[In] unsigned int RegisterCount)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetVertexShaderConstantB</unmanaged-short>	
        public void SetVertexShaderConstantB(int registerIndex, SharpDX.Mathematics.Interop.RawBool constantDataRef, int registerCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, registerIndex, &constantDataRef, registerCount,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set a pixel shader.</p>	
        /// </summary>	
        /// <param name="shaderRef"><dd>  <p>A reference to a pixel shader object. See <strong><see cref="SharpDX.Direct3D9.PixelShader"/></strong>. </p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShader"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetPixelShader']/*"/>	
        /// <msdn-id>bb205801</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShader([In] IDirect3DPixelShader9* pShader)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetPixelShader</unmanaged-short>	
        internal void SetPixelShader(SharpDX.Direct3D9.PixelShader shaderRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer),((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set an array of vertex shader floating-point constants.</p>	
        /// </summary>	
        /// <param name="registerIndex"><dd>  <p>The zero-based index of the first constant register.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>An array of floating-point constants.</p> </dd></param>	
        /// <param name="registerCount"><dd>  <p>The number of registers in pConstantData.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShaderConstantF"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetPixelShaderConstantF']/*"/>	
        /// <msdn-id>bb205803</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShaderConstantF([In] unsigned int RegisterIndex,[In] const float* pConstantData,[In] unsigned int RegisterCount)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetPixelShaderConstantF</unmanaged-short>	
        public void SetPixelShaderConstantF(int registerIndex, float constantDataRef, int registerCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, registerIndex, &constantDataRef, registerCount,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set an array of vertex shader integer constants.</p>	
        /// </summary>	
        /// <param name="registerIndex"><dd>  <p>The zero-based index of the first constant register.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>An array of integer constants.</p> </dd></param>	
        /// <param name="registerCount"><dd>  <p>The number of registers in pConstantData.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShaderConstantI"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetPixelShaderConstantI']/*"/>	
        /// <msdn-id>bb205804</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShaderConstantI([In] unsigned int RegisterIndex,[In] const int* pConstantData,[In] unsigned int RegisterCount)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetPixelShaderConstantI</unmanaged-short>	
        public void SetPixelShaderConstantI(int registerIndex, int constantDataRef, int registerCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, registerIndex, &constantDataRef, registerCount,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback function that must be implemented by a user to set an array of vertex shader Boolean constants.</p>	
        /// </summary>	
        /// <param name="registerIndex"><dd>  <p>The zero-based index of the first constant register.</p> </dd></param>	
        /// <param name="constantDataRef"><dd>  <p>An array of Boolean constants.</p> </dd></param>	
        /// <param name="registerCount"><dd>  <p>The number of registers in pConstantData.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when setting the device state, either of the following will occur:</p><ul> <li>The effect will fail during <strong><see cref="SharpDX.Direct3D9.Effect.BeginPass"/></strong>.</li> <li>The dynamic effect state call (such as <strong><see cref="SharpDX.Direct3D9.Device.SetPixelShaderConstantB"/></strong>) will fail.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXEffectStateManager::SetPixelShaderConstantB']/*"/>	
        /// <msdn-id>bb205802</msdn-id>	
        /// <unmanaged>HRESULT ID3DXEffectStateManager::SetPixelShaderConstantB([In] unsigned int RegisterIndex,[In] const BOOL* pConstantData,[In] unsigned int RegisterCount)</unmanaged>	
        /// <unmanaged-short>ID3DXEffectStateManager::SetPixelShaderConstantB</unmanaged-short>	
        public void SetPixelShaderConstantB(int registerIndex, SharpDX.Mathematics.Interop.RawBool constantDataRef, int registerCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, registerIndex, &constantDataRef, registerCount,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D9.Font"/> interface encapsulates the textures and resources needed to render a specific font on a specific device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.Font"/></strong> interface is obtained by calling <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateFont"/></strong> or <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateFontIndirect"/></strong>.</p><p>The LPD3DXFONT type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.Font"/></strong> interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.Font"/> <see cref="SharpDX.Direct3D9.Font"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.Font"/> *LPD3DXFONT;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont']/*"/>	
    /// <msdn-id>bb173961</msdn-id>	
    /// <unmanaged>ID3DXFont</unmanaged>	
    /// <unmanaged-short>ID3DXFont</unmanaged-short>	
    [Guid("d79dbb70-5f21-4d36-bbc2-ff525c213cdc")]
    public partial class Font : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Font"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Font(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Font"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Font(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Font(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the font object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>Note</strong>??Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call <strong><see cref="SharpDX.ComObject"/></strong> when you are done using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetDevice']/*"/>	
        /// <msdn-id>bb173965</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFont::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a reference is returned to a <strong><see cref="SharpDX.Direct3D9.FontDescription"/></strong> or <strong>D3DXFONT_DESCA</strong> structure, respectively.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a reference to the <strong>D3DXFONT_DESCA</strong> structure.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetDescW']/*"/>	
        /// <msdn-id>bb173964</msdn-id>	
        /// <unmanaged>GetDescW</unmanaged>	
        /// <unmanaged-short>GetDescW</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFont::GetDescW([Out] D3DXFONT_DESCW* pDesc)</unmanaged>
        public SharpDX.Direct3D9.FontDescription Description {
                get { SharpDX.Direct3D9.FontDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Returns a handle to a display device context (DC) that has the font set.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetDC']/*"/>	
        /// <msdn-id>bb173963</msdn-id>	
        /// <unmanaged>GetDC</unmanaged>	
        /// <unmanaged-short>GetDC</unmanaged-short>	
        /// <unmanaged>HDC ID3DXFont::GetDC()</unmanaged>
        public System.IntPtr DeviceContext {
                get { return GetDeviceContext(); }
        }
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the font object.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the Direct3D device object associated with the font object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call <strong><see cref="SharpDX.ComObject"/></strong> when you are done using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetDevice']/*"/>	
        /// <msdn-id>bb173965</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a description of the current font object. GetDescW and GetDescA are identical to this method, except that a reference is returned to a <strong><see cref="SharpDX.Direct3D9.FontDescription"/></strong> or <strong>D3DXFONT_DESCA</strong> structure, respectively.</p>	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a reference to the <strong>D3DXFONT_DESCA</strong> structure.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetDescW']/*"/>	
        /// <msdn-id>bb173964</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::GetDescW([Out] D3DXFONT_DESCW* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::GetDescW</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.FontDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D9.FontDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[5]);		
                descRef = new SharpDX.Direct3D9.FontDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves font characteristics that are identified in a <strong><see cref="SharpDX.Win32Native.TextMetric"/></strong> structure. This method supports ANSI and Unicode compiler settings.</p>	
        /// </summary>	
        /// <param name="textMetricsRef">No documentation.</param>	
        /// <returns><p>Nonzero if the function is successful; otherwise 0.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the structure type. If Unicode is defined, the function returns a <see cref="SharpDX.Win32Native.TextMetric"/> structure. Otherwise, the function call returns a <see cref="SharpDX.Win32Native.TextMetricA"/> structure.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetTextMetricsW']/*"/>	
        /// <msdn-id>bb173967</msdn-id>	
        /// <unmanaged>BOOL ID3DXFont::GetTextMetricsW([Out] TEXTMETRICW* pTextMetrics)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::GetTextMetricsW</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetTextMetrics(out SharpDX.Win32Native.TextMetric textMetricsRef) {
            unsafe {
                textMetricsRef = new SharpDX.Win32Native.TextMetric();
                SharpDX.Mathematics.Interop.RawBool __result__;
                fixed (void* textMetricsRef_ = &textMetricsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, textMetricsRef_,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns a handle to a display device context (DC) that has the font set.</p>	
        /// </summary>	
        /// <returns><p>Handle to a display DC.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetDC']/*"/>	
        /// <msdn-id>bb173963</msdn-id>	
        /// <unmanaged>HDC ID3DXFont::GetDC()</unmanaged>	
        /// <unmanaged-short>ID3DXFont::GetDC</unmanaged-short>	
        internal System.IntPtr GetDeviceContext() {
            unsafe {
                System.IntPtr __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Returns information about the placement and orientation of a glyph in a character cell.</p>	
        /// </summary>	
        /// <param name="glyph"><dd>  <p>Glyph identifier.</p> </dd></param>	
        /// <param name="textureOut"><dd>  <p>Address of a reference to a <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> object that contains the glyph.</p> </dd></param>	
        /// <param name="blackBoxRef"><dd>  <p>Pointer to the smallest rectangle object that completely encloses the glyph.</p> </dd></param>	
        /// <param name="cellIncRef"><dd>  <p>Pointer to the two-dimensional vector that connects the origin of the current character cell to the origin of the next character cell. See <strong><see cref="SharpDX.Mathematics.Interop.RawPoint"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::GetGlyphData']/*"/>	
        /// <msdn-id>bb173966</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::GetGlyphData([In] unsigned int Glyph,[Out] IDirect3DTexture9** ppTexture,[Out] RECT* pBlackBox,[Out] POINT* pCellInc)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::GetGlyphData</unmanaged-short>	
        public void GetGlyphData(int glyph, out SharpDX.Direct3D9.Texture textureOut, out SharpDX.Mathematics.Interop.RawRectangle blackBoxRef, out SharpDX.Mathematics.Interop.RawPoint cellIncRef) {
            unsafe {
                IntPtr textureOut_ = IntPtr.Zero;
                blackBoxRef = new SharpDX.Mathematics.Interop.RawRectangle();
                cellIncRef = new SharpDX.Mathematics.Interop.RawPoint();
                SharpDX.Result __result__;
                fixed (void* blackBoxRef_ = &blackBoxRef)
                    fixed (void* cellIncRef_ = &cellIncRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, glyph, &textureOut_, blackBoxRef_, cellIncRef_,((void**)(*(void**)_nativePointer))[9]);		
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Loads a series of characters into video memory to improve the efficiency of rendering to the device.</p>	
        /// </summary>	
        /// <param name="first"><dd>  <p>ID of the first character to be loaded into video memory.</p> </dd></param>	
        /// <param name="last"><dd>  <p>ID of the last character to be loaded into video memory.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>This method generates textures containing glyphs that represent the input characters. The glyphs are drawn as a series of triangles.</p><p>Characters will not be rendered to the device; <strong>DrawText</strong> must still be called to render the characters. However, by pre-loading characters into video memory, <strong>DrawText</strong> will use substantially fewer CPU resources.</p><p>This method internally converts characters to glyphs using the GDI function <strong>GetCharacterPlacement</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::PreloadCharacters']/*"/>	
        /// <msdn-id>bb173970</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::PreloadCharacters([In] unsigned int First,[In] unsigned int Last)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::PreloadCharacters</unmanaged-short>	
        public void PreloadCharacters(int first, int last) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, first, last,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Loads a series of glyphs into video memory to improve the efficiency of rendering to the device.</p>	
        /// </summary>	
        /// <param name="first"><dd>  <p>ID of the first glyph to be loaded into video memory.</p> </dd></param>	
        /// <param name="last"><dd>  <p>ID of the last glyph to be loaded into video memory.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>This method generates textures that contain the input glyphs. The glyphs are drawn as a series of triangles.</p><p>Glyphs will not be rendered to the device; <strong>DrawText</strong> must still be called to render the glyphs. However, by pre-loading glyphs into video memory, <strong>DrawText</strong> will use substantially fewer CPU resources.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::PreloadGlyphs']/*"/>	
        /// <msdn-id>bb173971</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::PreloadGlyphs([In] unsigned int First,[In] unsigned int Last)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::PreloadGlyphs</unmanaged-short>	
        public void PreloadGlyphs(int first, int last) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, first, last,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Loads formatted text into video memory to improve the efficiency of rendering to the device. This method supports ANSI and Unicode strings.</p>	
        /// </summary>	
        /// <param name="stringRef"><dd>  <p>Pointer to a string of characters to be loaded into video memory. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR; otherwise, the data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of characters in the text string.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to PreloadTextW. Otherwise, the function call resolves to PreloadTextA because ANSI strings are being used.</p><p>This method generates textures that contain glyphs that represent the input text. The glyphs are drawn as a series of triangles.</p><p>Text will not be rendered to the device; <strong>DrawText</strong> must still be called to render the text. However, by preloading text into video memory, <strong>DrawText</strong> will use substantially fewer CPU resources.</p><p>This method internally converts characters to glyphs using the GDI function <strong>GetCharacterPlacement</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::PreloadTextW']/*"/>	
        /// <msdn-id>bb173972</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::PreloadTextW([In] const wchar_t* pString,[In] int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::PreloadTextW</unmanaged-short>	
        internal void PreloadText(string stringRef, int count) {
            unsafe {
                IntPtr stringRef_ = Utilities.StringToHGlobalUni(stringRef);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)stringRef_, count,((void**)(*(void**)_nativePointer))[13]);		
                Marshal.FreeHGlobal(stringRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Draws formatted text. This method supports ANSI and Unicode strings.</p>	
        /// </summary>	
        /// <param name="spriteRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Sprite"/></strong> object that contains the string. Can be <strong><c>null</c></strong>, in which case Direct3D will render the string with its own sprite object. To improve efficiency, a sprite object should be specified if <strong>DrawText</strong> is to be called more than once in a row.</p> </dd></param>	
        /// <param name="stringRef"><dd>  <p>Pointer to a string to draw. If the Count parameter is -1, the string must be null-terminated.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Specifies the number of characters in the string. If Count is -1, then the pString parameter is assumed to be a reference to a null-terminated string and <strong>DrawText</strong> computes the character count automatically.</p> </dd></param>	
        /// <param name="rectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted. The coordinate value of the rectangle's right side must be greater than that of its left side. Likewise, the coordinate value of the bottom must be greater than that of the top.</p> </dd></param>	
        /// <param name="format"><dd>  <p> </p><p>Specifies the method of formatting the text. It can be any combination of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>DT_BOTTOM</strong></dt> </dl> </td><td> <p>Justifies the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.</p> </td></tr> <tr><td><dl> <dt><strong>DT_CALCRECT</strong></dt> </dl> </td><td> <p>Determines the width and height of the rectangle. If there are multiple lines of text, <strong>DrawText</strong> uses the width of the rectangle pointed to by the pRect parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, <strong>DrawText</strong> modifies the right side of the rectangle so that it bounds the last character in the line. In either case, <strong>DrawText</strong> returns the height of the formatted text but does not draw the text.</p> </td></tr> <tr><td><dl> <dt><strong>DT_CENTER</strong></dt> </dl> </td><td> <p>Centers text horizontally in the rectangle.</p> </td></tr> <tr><td><dl> <dt><strong>DT_EXPANDTABS</strong></dt> </dl> </td><td> <p>Expands tab characters. The default number of characters per tab is eight.</p> </td></tr> <tr><td><dl> <dt><strong>DT_LEFT</strong></dt> </dl> </td><td> <p>Aligns text to the left.</p> </td></tr> <tr><td><dl> <dt><strong>DT_NOCLIP</strong></dt> </dl> </td><td> <p>Draws without clipping. <strong>DrawText</strong> is somewhat faster when DT_NOCLIP is used.</p> </td></tr> <tr><td><dl> <dt><strong>DT_RIGHT</strong></dt> </dl> </td><td> <p>Aligns text to the right.</p> </td></tr> <tr><td><dl> <dt><strong>DT_RTLREADING</strong></dt> </dl> </td><td> <p>Displays text in right-to-left reading order for bidirectional text when a Hebrew or Arabic font is selected. The default reading order for all text is left-to-right.</p> </td></tr> <tr><td><dl> <dt><strong>DT_SINGLELINE</strong></dt> </dl> </td><td> <p>Displays text on a single line only. Carriage returns and line feeds do not break the line.</p> </td></tr> <tr><td><dl> <dt><strong>DT_TOP</strong></dt> </dl> </td><td> <p>Top-justifies text.</p> </td></tr> <tr><td><dl> <dt><strong>DT_VCENTER</strong></dt> </dl> </td><td> <p>Centers text vertically (single line only).</p> </td></tr> <tr><td><dl> <dt><strong>DT_WORDBREAK</strong></dt> </dl> </td><td> <p>Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the pRect parameter. A carriage return/line feed sequence also breaks the line.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <param name="color"><dd>  <p>Color of the text. For more information, see <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from pRect (top to the bottom) of the drawn text. If the function fails, the return value is zero.</p></returns>	
        /// <remarks>	
        /// <p>The parameters of this method are very similar to those of the GDI <strong>DrawText</strong> function.</p><p>This method supports both ANSI and Unicode strings.</p><p>This method must be called inside a  <strong>BeginScene</strong> ... <strong>EndScene</strong> block. The only exception is when an application calls <strong>DrawText</strong> with DT_CALCRECT to calculate the size of a given block of text.</p><p>Unless the DT_NOCLIP format is used, this method clips the text so that it does not appear outside the specified rectangle. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified.</p><p>If the selected font is too large for the rectangle, this method does not attempt to substitute a smaller font.</p><p>This method supports only fonts whose escapement and orientation are both zero.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::DrawTextW']/*"/>	
        /// <msdn-id>bb173962</msdn-id>	
        /// <unmanaged>int ID3DXFont::DrawTextW([In] ID3DXSprite* pSprite,[In] const wchar_t* pString,[In] int Count,[In] void* pRect,[In] unsigned int Format,[In] D3DCOLOR Color)</unmanaged>	
        /// <unmanaged-short>ID3DXFont::DrawTextW</unmanaged-short>	
        public int DrawText(SharpDX.Direct3D9.Sprite spriteRef, string stringRef, int count, System.IntPtr rectRef, int format, SharpDX.Mathematics.Interop.RawColorBGRA color) {
            unsafe {
                IntPtr stringRef_ = Utilities.StringToHGlobalUni(stringRef);
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint80(_nativePointer, (void*)((spriteRef == null)?IntPtr.Zero:spriteRef.NativePointer), (void*)stringRef_, count, (void*)rectRef, format, color,((void**)(*(void**)_nativePointer))[15]);		
                Marshal.FreeHGlobal(stringRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method should be called whenever the device is lost or before the user calls <strong>Reset</strong>. Even if the device was not actually lost, <strong>OnLostDevice</strong> is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling <strong>Reset</strong> and then <strong>OnResetDevice</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::OnLostDevice']/*"/>	
        /// <msdn-id>bb173968</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::OnLostDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXFont::OnLostDevice</unmanaged-short>	
        public void OnLostDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to re-acquire resources and save initial state.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><strong>OnResetDevice</strong> should be called each time the device is reset (using <strong>Reset</strong>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFont::OnResetDevice']/*"/>	
        /// <msdn-id>bb173969</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFont::OnResetDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXFont::OnResetDevice</unmanaged-short>	
        public void OnResetDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface is implemented by the application to allocate or free frame and mesh container objects. Methods on this are called during loading and destroying frame hierarchies.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPD3DXALLOCATEHIERARCHY type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.IAllocateHierarchy"/> <see cref="SharpDX.Direct3D9.IAllocateHierarchy"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.IAllocateHierarchy"/> *LPD3DXALLOCATEHIERARCHY;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAllocateHierarchy']/*"/>	
    /// <msdn-id>bb205619</msdn-id>	
    /// <unmanaged>ID3DXAllocateHierarchy</unmanaged>	
    /// <unmanaged-short>ID3DXAllocateHierarchy</unmanaged-short>	
    public partial class IAllocateHierarchy : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.IAllocateHierarchy"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IAllocateHierarchy(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.IAllocateHierarchy"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.IAllocateHierarchy(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.IAllocateHierarchy(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Requests allocation of a frame object.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>Name of the frame to be created.</p> </dd></param>	
        /// <param name="newFrameOut"><dd>  <p>Returns the created frame object.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR,  as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAllocateHierarchy::CreateFrame']/*"/>	
        /// <msdn-id>bb205620</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::CreateFrame([In] const char* Name,[In] D3DXFRAME** ppNewFrame)</unmanaged>	
        /// <unmanaged-short>ID3DXAllocateHierarchy::CreateFrame</unmanaged-short>	
        public void CreateFrame(string name, ref SharpDX.Direct3D9.Frame newFrameOut) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                var newFrameOut_ = new SharpDX.Direct3D9.Frame.__Native();
                newFrameOut.__MarshalTo(ref newFrameOut_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)name_, &newFrameOut_,((void**)(*(void**)_nativePointer))[0]);		
                Marshal.FreeHGlobal(name_ );
                newFrameOut.__MarshalFree(ref newFrameOut_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Requests allocation of a mesh container object.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>Name of the mesh.</p> </dd></param>	
        /// <param name="meshDataRef"><dd>  <p>Pointer to the mesh data structure. See <strong><see cref="SharpDX.Direct3D9.MeshData"/></strong>.</p> </dd></param>	
        /// <param name="materialsRef"><dd>  <p>Array of materials used in the mesh.</p> </dd></param>	
        /// <param name="effectInstancesRef"><dd>  <p>Array of effect instances used in the mesh. See <strong><see cref="SharpDX.Direct3D9.EffectInstance"/></strong>.</p> </dd></param>	
        /// <param name="numMaterials"><dd>  <p>Number of materials in the materials array.</p> </dd></param>	
        /// <param name="adjacencyRef"><dd>  <p>Adjacency array for the mesh.</p> </dd></param>	
        /// <param name="skinInfoRef"><dd>  <p>Pointer to the skin mesh object if skin data is found. See <strong><see cref="SharpDX.Direct3D9.SkinInfo"/></strong>.</p> </dd></param>	
        /// <param name="newMeshContainerOut"><dd>  <p>Returns the created mesh container. See <strong><see cref="SharpDX.Direct3D9.MeshContainer"/></strong>.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAllocateHierarchy::CreateMeshContainer']/*"/>	
        /// <msdn-id>bb205621</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::CreateMeshContainer([In] const char* Name,[In] const D3DXMESHDATA* pMeshData,[In] const D3DXMATERIAL* pMaterials,[In] const D3DXEFFECTINSTANCE* pEffectInstances,[In] unsigned int NumMaterials,[In] const unsigned int* pAdjacency,[In] ID3DXSkinInfo* pSkinInfo,[In] D3DXMESHCONTAINER** ppNewMeshContainer)</unmanaged>	
        /// <unmanaged-short>ID3DXAllocateHierarchy::CreateMeshContainer</unmanaged-short>	
        public void CreateMeshContainer(string name, SharpDX.Direct3D9.MeshData meshDataRef, ref SharpDX.Direct3D9.ExtendedMaterial materialsRef, SharpDX.Direct3D9.EffectInstance effectInstancesRef, int numMaterials, int adjacencyRef, SharpDX.Direct3D9.SkinInfo skinInfoRef, SharpDX.Direct3D9.MeshContainer newMeshContainerOut) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                var materialsRef_ = new SharpDX.Direct3D9.ExtendedMaterial.__Native();
                materialsRef.__MarshalTo(ref materialsRef_);
                var effectInstancesRef_ = new SharpDX.Direct3D9.EffectInstance.__Native();
                effectInstancesRef.__MarshalTo(ref effectInstancesRef_);
                var newMeshContainerOut_ = new SharpDX.Direct3D9.MeshContainer.__Native();
                newMeshContainerOut.__MarshalTo(ref newMeshContainerOut_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)name_, &meshDataRef, &materialsRef_, &effectInstancesRef_, numMaterials, &adjacencyRef, (void*)((skinInfoRef == null)?IntPtr.Zero:skinInfoRef.NativePointer), &newMeshContainerOut_,((void**)(*(void**)_nativePointer))[1]);		
                Marshal.FreeHGlobal(name_ );
                materialsRef.__MarshalFree(ref materialsRef_);
                effectInstancesRef.__MarshalFree(ref effectInstancesRef_);
                newMeshContainerOut.__MarshalFree(ref newMeshContainerOut_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Requests deallocation of a frame object.</p>	
        /// </summary>	
        /// <param name="frameToFreeRef"><dd>  <p>Pointer to the frame to be deallocated.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAllocateHierarchy::DestroyFrame']/*"/>	
        /// <msdn-id>bb205622</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::DestroyFrame([In] D3DXFRAME* pFrameToFree)</unmanaged>	
        /// <unmanaged-short>ID3DXAllocateHierarchy::DestroyFrame</unmanaged-short>	
        public void DestroyFrame(ref SharpDX.Direct3D9.Frame frameToFreeRef) {
            unsafe {
                var frameToFreeRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameToFreeRef.__MarshalTo(ref frameToFreeRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &frameToFreeRef_,((void**)(*(void**)_nativePointer))[2]);		
                frameToFreeRef.__MarshalFree(ref frameToFreeRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Requests deallocation of a mesh container object.</p>	
        /// </summary>	
        /// <param name="meshContainerToFreeRef"><dd>  <p>Pointer to the mesh container object to be deallocated.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message  from D3DERR or D3DXERR, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXAllocateHierarchy::DestroyMeshContainer']/*"/>	
        /// <msdn-id>bb205623</msdn-id>	
        /// <unmanaged>HRESULT ID3DXAllocateHierarchy::DestroyMeshContainer([In] D3DXMESHCONTAINER* pMeshContainerToFree)</unmanaged>	
        /// <unmanaged-short>ID3DXAllocateHierarchy::DestroyMeshContainer</unmanaged-short>	
        public void DestroyMeshContainer(SharpDX.Direct3D9.MeshContainer meshContainerToFreeRef) {
            unsafe {
                var meshContainerToFreeRef_ = new SharpDX.Direct3D9.MeshContainer.__Native();
                meshContainerToFreeRef.__MarshalTo(ref meshContainerToFreeRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &meshContainerToFreeRef_,((void**)(*(void**)_nativePointer))[3]);		
                meshContainerToFreeRef.__MarshalFree(ref meshContainerToFreeRef_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface is implemented by the application to save any additional user data embedded in .x files. An instance of this interface is passed to <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong>, and D3DX calls the appropriate method on this interface every time the appropriate data is encountered. For example, for each frame object in the .x file, <strong><see cref="SharpDX.Direct3D9.ILoadUserData.LoadFrameChildData"/></strong> is called and passed the child data. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPD3DXLOADUSERDATA type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.ILoadUserData"/> <see cref="SharpDX.Direct3D9.ILoadUserData"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.ILoadUserData"/> *LPD3DXLOADUSERDATA;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLoadUserData']/*"/>	
    /// <msdn-id>bb174034</msdn-id>	
    /// <unmanaged>ID3DXLoadUserData</unmanaged>	
    /// <unmanaged-short>ID3DXLoadUserData</unmanaged-short>	
    public partial class ILoadUserData : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.ILoadUserData"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ILoadUserData(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.ILoadUserData"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.ILoadUserData(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.ILoadUserData(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Load top level data from a .x file.</p>	
        /// </summary>	
        /// <param name="xofChildDataRef"><dd>  <p>Pointer to a .x file data structure. This is defined in Dxfile.h.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLoadUserData::LoadTopLevelData']/*"/>	
        /// <msdn-id>bb174037</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLoadUserData::LoadTopLevelData([In] ID3DXFileData* pXofChildData)</unmanaged>	
        /// <unmanaged-short>ID3DXLoadUserData::LoadTopLevelData</unmanaged-short>	
        public void LoadTopLevelData(SharpDX.Direct3D9.XFileData xofChildDataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((xofChildDataRef == null)?IntPtr.Zero:xofChildDataRef.NativePointer),((void**)(*(void**)_nativePointer))[0]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Load frame child data from a .x file.</p>	
        /// </summary>	
        /// <param name="frameRef"><dd>  <p>Pointer to a mesh container. See <strong><see cref="SharpDX.Direct3D9.Frame"/></strong>.</p> </dd></param>	
        /// <param name="xofChildDataRef"><dd>  <p>Pointer to a .x file data structure. This is defined in Dxfile.h.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLoadUserData::LoadFrameChildData']/*"/>	
        /// <msdn-id>bb174035</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLoadUserData::LoadFrameChildData([In] D3DXFRAME* pFrame,[In] ID3DXFileData* pXofChildData)</unmanaged>	
        /// <unmanaged-short>ID3DXLoadUserData::LoadFrameChildData</unmanaged-short>	
        public void LoadFrameChildData(ref SharpDX.Direct3D9.Frame frameRef, SharpDX.Direct3D9.XFileData xofChildDataRef) {
            unsafe {
                var frameRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRef.__MarshalTo(ref frameRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &frameRef_, (void*)((xofChildDataRef == null)?IntPtr.Zero:xofChildDataRef.NativePointer),((void**)(*(void**)_nativePointer))[1]);		
                frameRef.__MarshalFree(ref frameRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Load mesh child data from a .x file.</p>	
        /// </summary>	
        /// <param name="meshContainerRef"><dd>  <p>Pointer to a mesh container. See <strong><see cref="SharpDX.Direct3D9.MeshContainer"/></strong>.</p> </dd></param>	
        /// <param name="xofChildDataRef"><dd>  <p>Pointer to a .x file data structure. This is defined in Dxfile.h.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or D3DXERR, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLoadUserData::LoadMeshChildData']/*"/>	
        /// <msdn-id>bb174036</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLoadUserData::LoadMeshChildData([In] D3DXMESHCONTAINER* pMeshContainer,[In] ID3DXFileData* pXofChildData)</unmanaged>	
        /// <unmanaged-short>ID3DXLoadUserData::LoadMeshChildData</unmanaged-short>	
        public void LoadMeshChildData(SharpDX.Direct3D9.MeshContainer meshContainerRef, SharpDX.Direct3D9.XFileData xofChildDataRef) {
            unsafe {
                var meshContainerRef_ = new SharpDX.Direct3D9.MeshContainer.__Native();
                meshContainerRef.__MarshalTo(ref meshContainerRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &meshContainerRef_, (void*)((xofChildDataRef == null)?IntPtr.Zero:xofChildDataRef.NativePointer),((void**)(*(void**)_nativePointer))[2]);		
                meshContainerRef.__MarshalFree(ref meshContainerRef_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p><see cref="SharpDX.Direct3D9.Include"/> is a user-implemented interface to provide callbacks for #include directives during shader compilation. Each of the methods in this interface must be implemented by the user which will then be used as callbacks to the application when one of the following occurs: </p><ul> <li>An HLSL shader that contains a #include is compiled by calling one of the <see cref="SharpDX.Direct3D9.D3DX9.CompileShader"/>*** functions.</li> <li>An assembly shader #include is assembled by calling any of the <see cref="SharpDX.Direct3D9.D3DX9.AssembleShader"/>*** functions.</li> <li>An effect that contains a #include is compiled by by calling any of the <see cref="SharpDX.Direct3D9.D3DX9.CreateEffect"/>*** or <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompiler"/>*** functions.</li> </ul>	
    /// </summary>	
    /// <remarks>	
    /// <p>A user creates an <see cref="SharpDX.Direct3D9.Include"/> interface by implementing a class that derives from this interface, and implementing all the interface methods.</p><p>The LPD3DXINCLUDE type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.Include"/> <see cref="SharpDX.Direct3D9.Include"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.Include"/> *LPD3DXINCLUDE;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXInclude']/*"/>	
    /// <msdn-id>bb173986</msdn-id>	
    /// <unmanaged>ID3DXInclude</unmanaged>	
    /// <unmanaged-short>ID3DXInclude</unmanaged-short>	
    public partial interface Include : SharpDX.ICallbackable {
        
        
        /// <summary>	
        /// <p>A user-implemented method for opening and reading the contents of a shader #include file.</p>	
        /// </summary>	
        /// <param name="includeType"><dd>  <p>The location of the #include file. See <strong><see cref="SharpDX.Direct3D9.IncludeType"/></strong>.</p> </dd></param>	
        /// <param name="fileNameRef"><dd>  <p>Name of the #include file.</p> </dd></param>	
        /// <param name="parentDataRef"><dd>  <p>Pointer to the container that includes the #include file. The compiler might pass <c>null</c> in <em>pParentData</em>. For more information, see the "Searching for Include Files" section in Compile an Effect (Direct3D 11).</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>Pointer to the returned buffer that contains the include directives. This reference remains valid until <strong><see cref="SharpDX.Direct3D9.Include.Close"/></strong> is called.</p> </dd></param>	
        /// <param name="bytesRef"><dd>  <p>Number of bytes returned in ppData.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when reading the #include file, the API that caused the callback to be called will fail. This is one of the following:</p><ul> <li>The HLSL shader will fail one of the <see cref="SharpDX.Direct3D9.D3DX9.CompileShader"/>*** functions.</li> <li>The assembly shader will fail one of the <see cref="SharpDX.Direct3D9.D3DX9.AssembleShader"/>*** functions.</li> <li>The effect will fail one of the <see cref="SharpDX.Direct3D9.D3DX9.CreateEffect"/>*** or <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompiler"/>*** functions.</li> </ul></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXInclude::Open']/*"/>	
        /// <msdn-id>bb173988</msdn-id>	
        /// <unmanaged>HRESULT ID3DXInclude::Open([In] D3DXINCLUDE_TYPE IncludeType,[In] const char* pFileName,[In] const void* pParentData,[In] const void** ppData,[In] unsigned int* pBytes)</unmanaged>	
        /// <unmanaged-short>ID3DXInclude::Open</unmanaged-short>	
        /* public void Open(SharpDX.Direct3D9.IncludeType includeType, string fileNameRef, System.IntPtr parentDataRef, System.IntPtr dataOut, int bytesRef) */
        
        /// <summary>	
        /// <p>A user-implemented method for closing a shader #include file.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>Pointer to the returned buffer that contains the include directives. This is the reference that was returned by the corresponding <strong><see cref="SharpDX.Direct3D9.Include.Open"/></strong> call.</p> </dd></param>	
        /// <returns><p>The user-implemented method should return <see cref="SharpDX.Result.Ok"/>. If the callback fails when reading the #include file, the API that caused the callback to be called will fail. This is one of the following:</p><ul> <li>The HLSL shader will fail one of the <see cref="SharpDX.Direct3D9.D3DX9.CompileShader"/>*** functions.</li> <li>The assembly shader will fail one of the <see cref="SharpDX.Direct3D9.D3DX9.AssembleShader"/>*** functions.</li> <li>The effect will fail one of the <see cref="SharpDX.Direct3D9.D3DX9.CreateEffect"/>*** or <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompiler"/>*** functions.</li> </ul></returns>	
        /// <remarks>	
        /// <p> If <strong><see cref="SharpDX.Direct3D9.Include.Open"/></strong> was successful, <strong><see cref="SharpDX.Direct3D9.Include.Close"/></strong> is guaranteed to be called before the API using this interface returns.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXInclude::Close']/*"/>	
        /// <msdn-id>bb173987</msdn-id>	
        /// <unmanaged>HRESULT ID3DXInclude::Close([In] const void* pData)</unmanaged>	
        /// <unmanaged-short>ID3DXInclude::Close</unmanaged-short>	
        /* public void Close(System.IntPtr dataRef) */
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.IndexBuffer"/> interface to manipulate an index buffer resource.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.Device.CreateIndexBuffer"/></strong> method.</p><p>This interface inherits additional functionality from the <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> interface.</p><p>This interface, like all COM interfaces, inherits from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPDIRECT3DINDEXBUFFER9 and PDIRECT3DINDEXBUFFER9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.IndexBuffer"/> *LPDIRECT3DINDEXBUFFER9, *PDIRECT3DINDEXBUFFER9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DIndexBuffer9']/*"/>	
    /// <msdn-id>bb205865</msdn-id>	
    /// <unmanaged>IDirect3DIndexBuffer9</unmanaged>	
    /// <unmanaged-short>IDirect3DIndexBuffer9</unmanaged-short>	
    [Guid("7C9DD65E-D3F7-4529-ACEE-785830ACDE35")]
    public partial class IndexBuffer : SharpDX.Direct3D9.Resource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.IndexBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public IndexBuffer(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.IndexBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.IndexBuffer(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.IndexBuffer(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a description of the index buffer resource.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DIndexBuffer9::GetDesc']/*"/>	
        /// <msdn-id>bb205866</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::GetDesc([Out] D3DINDEXBUFFER_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.IndexBufferDescription Description {
                get { SharpDX.Direct3D9.IndexBufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Locks a range of index data and obtains a reference to the index buffer memory.</p>	
        /// </summary>	
        /// <param name="offsetToLock"><dd>  <p>Offset into the index data to lock, in bytes. Lock the entire index buffer by specifying 0 for both parameters, SizeToLock and OffsetToLock. </p> </dd></param>	
        /// <param name="sizeToLock"><dd>  <p>Size of the index data to lock, in bytes. Lock the entire index buffer by specifying 0 for both parameters, SizeToLock and OffsetToLock.</p> </dd></param>	
        /// <param name="bDataOut"><dd>  <p>VOID* reference to a memory buffer containing the returned index data. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/></li> </ul> <p> For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>As a general rule, do not hold a lock across more than one frame. When working with index buffers, you are allowed to make multiple lock calls. However, you must ensure that the number of lock calls match the number of unlock calls. <strong><see cref="SharpDX.Direct3D9.Device.DrawIndexedPrimitive"/></strong> calls will not succeed with any outstanding lock count on any currently set index buffer. </p><p>The <see cref="SharpDX.Direct3D9.LockFlags.Discard"/> and <see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/> flags are valid only on buffers created with <see cref="SharpDX.Direct3D9.Usage.Dynamic"/>.</p><p>See Programming Tips (Direct3D 9) for information about using <see cref="SharpDX.Direct3D9.LockFlags.Discard"/> or <see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DIndexBuffer9::Lock']/*"/>	
        /// <msdn-id>bb205867</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::Lock([In] unsigned int OffsetToLock,[In] unsigned int SizeToLock,[Out] void** ppbData,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DIndexBuffer9::Lock</unmanaged-short>	
        internal void Lock(int offsetToLock, int sizeToLock, out System.IntPtr bDataOut, SharpDX.Direct3D9.LockFlags flags) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* bDataOut_ = &bDataOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, offsetToLock, sizeToLock, bDataOut_, unchecked((int)flags),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks index data.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DIndexBuffer9::Unlock']/*"/>	
        /// <msdn-id>bb205868</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::Unlock()</unmanaged>	
        /// <unmanaged-short>IDirect3DIndexBuffer9::Unlock</unmanaged-short>	
        public void Unlock() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a description of the index buffer resource.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.IndexBufferDescription"/></strong> structure, describing the returned index buffer. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the argument is invalid.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DIndexBuffer9::GetDesc']/*"/>	
        /// <msdn-id>bb205866</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DIndexBuffer9::GetDesc([Out] D3DINDEXBUFFER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>IDirect3DIndexBuffer9::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.IndexBufferDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D9.IndexBufferDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface is implemented by the application to save any additional user data embedded in .x files. An instance of this interface is passed to <strong><see cref="SharpDX.Direct3D9.D3DX9.SaveMeshHierarchyToFileW"/></strong>, and D3DX calls the appropriate method on this interface every time the appropriate data is encountered. For example, for each frame object in the .x file, <strong><see cref="SharpDX.Direct3D9.ISaveUserData.AddFrameChildData"/></strong> is called and passed the child data.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPD3DXSAVEUSERDATA type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.ISaveUserData"/> <see cref="SharpDX.Direct3D9.ISaveUserData"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.ISaveUserData"/> *LPD3DXSAVEUSERDATA;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSaveUserData']/*"/>	
    /// <msdn-id>bb174199</msdn-id>	
    /// <unmanaged>ID3DXSaveUserData</unmanaged>	
    /// <unmanaged-short>ID3DXSaveUserData</unmanaged-short>	
    public partial class ISaveUserData : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.ISaveUserData"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ISaveUserData(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.ISaveUserData"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.ISaveUserData(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.ISaveUserData(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Add child data to the frame.</p>	
        /// </summary>	
        /// <param name="frameRef"><dd>  <p>Pointer to a mesh container. See <strong><see cref="SharpDX.Direct3D9.Frame"/></strong>.</p> </dd></param>	
        /// <param name="xofSaveRef"><dd>  <p>Pointer to a .x file save object. Use the reference to call <strong><see cref="SharpDX.Direct3D9.XFileSaveObject.AddDataObject"/></strong> to add a child data object. Do not save the data with <strong><see cref="SharpDX.Direct3D9.XFileSaveObject.Save"/></strong>.</p> </dd></param>	
        /// <param name="xofFrameDataRef"><dd>  <p>Pointer to a .x file data node. Use the reference to call <strong><see cref="SharpDX.Direct3D9.XFileSaveData.AddDataObject"/></strong> to add a child data object.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.Direct3D9.ISaveUserData.RegisterTemplates"/></strong> and <strong><see cref="SharpDX.Direct3D9.ISaveUserData.SaveTemplates"/></strong> provide a mechanism for adding a template to a .x file for saving user data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSaveUserData::AddFrameChildData']/*"/>	
        /// <msdn-id>bb174200</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddFrameChildData([In] const D3DXFRAME* pFrame,[In] ID3DXFileSaveObject* pXofSave,[In] ID3DXFileSaveData* pXofFrameData)</unmanaged>	
        /// <unmanaged-short>ID3DXSaveUserData::AddFrameChildData</unmanaged-short>	
        public void AddFrameChildData(ref SharpDX.Direct3D9.Frame frameRef, SharpDX.Direct3D9.XFileSaveObject xofSaveRef, SharpDX.Direct3D9.XFileSaveData xofFrameDataRef) {
            unsafe {
                var frameRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRef.__MarshalTo(ref frameRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &frameRef_, (void*)((xofSaveRef == null)?IntPtr.Zero:xofSaveRef.NativePointer), (void*)((xofFrameDataRef == null)?IntPtr.Zero:xofFrameDataRef.NativePointer),((void**)(*(void**)_nativePointer))[0]);		
                frameRef.__MarshalFree(ref frameRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Add child data to the mesh.</p>	
        /// </summary>	
        /// <param name="meshContainerRef"><dd>  <p>Pointer to a mesh container. See <strong><see cref="SharpDX.Direct3D9.MeshContainer"/></strong>.</p> </dd></param>	
        /// <param name="xofSaveRef"><dd>  <p>Pointer to a .x file save object. Use the reference to call <strong><see cref="SharpDX.Direct3D9.XFileSaveObject.AddDataObject"/></strong> to add a child data object. Do not save the data with <strong><see cref="SharpDX.Direct3D9.XFileSaveObject.Save"/></strong>.</p> </dd></param>	
        /// <param name="xofMeshDataRef"><dd>  <p>Pointer to a .x file data node. Use the reference to call <strong><see cref="SharpDX.Direct3D9.XFileSaveData.AddDataObject"/></strong> to add a child data object.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSaveUserData::AddMeshChildData']/*"/>	
        /// <msdn-id>bb174201</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddMeshChildData([In] const D3DXMESHCONTAINER* pMeshContainer,[In] ID3DXFileSaveObject* pXofSave,[In] ID3DXFileSaveData* pXofMeshData)</unmanaged>	
        /// <unmanaged-short>ID3DXSaveUserData::AddMeshChildData</unmanaged-short>	
        public void AddMeshChildData(SharpDX.Direct3D9.MeshContainer meshContainerRef, SharpDX.Direct3D9.XFileSaveObject xofSaveRef, SharpDX.Direct3D9.XFileSaveData xofMeshDataRef) {
            unsafe {
                var meshContainerRef_ = new SharpDX.Direct3D9.MeshContainer.__Native();
                meshContainerRef.__MarshalTo(ref meshContainerRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &meshContainerRef_, (void*)((xofSaveRef == null)?IntPtr.Zero:xofSaveRef.NativePointer), (void*)((xofMeshDataRef == null)?IntPtr.Zero:xofMeshDataRef.NativePointer),((void**)(*(void**)_nativePointer))[1]);		
                meshContainerRef.__MarshalFree(ref meshContainerRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Add a top level object before the frame hierarchy.</p>	
        /// </summary>	
        /// <param name="xofSaveRef"><dd>  <p>Pointer to a .x file save object. Use this reference to call <strong>IDirectXFileSaveObject::CreateDataObject</strong> to create the data object to be saved. Then call <strong>IDirectXFileSaveObject::SaveData</strong> to save the data.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer. In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSaveUserData::AddTopLevelDataObjectsPre']/*"/>	
        /// <msdn-id>bb174203</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddTopLevelDataObjectsPre([In] ID3DXFileSaveObject* pXofSave)</unmanaged>	
        /// <unmanaged-short>ID3DXSaveUserData::AddTopLevelDataObjectsPre</unmanaged-short>	
        public void AddTopLevelDataObjectsPre(SharpDX.Direct3D9.XFileSaveObject xofSaveRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((xofSaveRef == null)?IntPtr.Zero:xofSaveRef.NativePointer),((void**)(*(void**)_nativePointer))[2]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Add a top level object after the frame hierarchy.</p>	
        /// </summary>	
        /// <param name="xofSaveRef"><dd>  <p>Pointer to a .x file save object. Use this reference to call <strong>IDirectXFileSaveObject::CreateDataObject</strong> to create the data object to be saved. Then call <strong>IDirectXFileSaveObject::SaveData</strong> to save the data.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSaveUserData::AddTopLevelDataObjectsPost']/*"/>	
        /// <msdn-id>bb174202</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSaveUserData::AddTopLevelDataObjectsPost([In] ID3DXFileSaveObject* pXofSave)</unmanaged>	
        /// <unmanaged-short>ID3DXSaveUserData::AddTopLevelDataObjectsPost</unmanaged-short>	
        public void AddTopLevelDataObjectsPost(SharpDX.Direct3D9.XFileSaveObject xofSaveRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((xofSaveRef == null)?IntPtr.Zero:xofSaveRef.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback for the user to register a .x file template.</p>	
        /// </summary>	
        /// <param name="xFileApiRef"><dd>  <p>Use this reference to register user-defined .x file templates. See <strong><see cref="SharpDX.Direct3D9.XFile"/></strong>. Do not use this parameter to add data objects.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.ISaveUserData.RegisterTemplates"/></strong> and <strong><see cref="SharpDX.Direct3D9.ISaveUserData.SaveTemplates"/></strong> provide a mechanism for adding a template to a .x file for saving user data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSaveUserData::RegisterTemplates']/*"/>	
        /// <msdn-id>bb174204</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSaveUserData::RegisterTemplates([In] ID3DXFile* pXFileApi)</unmanaged>	
        /// <unmanaged-short>ID3DXSaveUserData::RegisterTemplates</unmanaged-short>	
        public void RegisterTemplates(SharpDX.Direct3D9.XFile xFileApiRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((xFileApiRef == null)?IntPtr.Zero:xFileApiRef.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>A callback for the user to save a .x file template.</p>	
        /// </summary>	
        /// <param name="xofSaveRef"><dd>  <p>Pointer to a .x file save object. Do not use this parameter to add data objects. See <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong>.</p> </dd></param>	
        /// <returns><p>The return values of this method are implemented by an application programmer.In general, if no error occurs, program the method to return <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. Otherwise, program the method to return an appropriate error message from D3DERR or <strong>D3DXERR</strong>, as this will cause <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> to fail also, and return the error.</p></returns>	
        /// <remarks>	
        /// <p> <strong><see cref="SharpDX.Direct3D9.ISaveUserData.RegisterTemplates"/></strong> and <strong><see cref="SharpDX.Direct3D9.ISaveUserData.SaveTemplates"/></strong> provide a mechanism for adding a template to a .x file for saving user data.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSaveUserData::SaveTemplates']/*"/>	
        /// <msdn-id>bb174205</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSaveUserData::SaveTemplates([In] ID3DXFileSaveObject* pXofSave)</unmanaged>	
        /// <unmanaged-short>ID3DXSaveUserData::SaveTemplates</unmanaged-short>	
        public void SaveTemplates(SharpDX.Direct3D9.XFileSaveObject xofSaveRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((xofSaveRef == null)?IntPtr.Zero:xofSaveRef.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>An application uses the methods of this interface to implement a key frame animation set.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Create a keyframed animation set with <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateKeyframedAnimationSet"/></strong>.</p><p>The LPD3DXKEYFRAMEDANIMATIONSET type is defined as a reference to this interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.KeyframedAnimationSet"/> <see cref="SharpDX.Direct3D9.KeyframedAnimationSet"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.KeyframedAnimationSet"/> *LPD3DXKEYFRAMEDANIMATIONSET;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet']/*"/>	
    /// <msdn-id>bb173989</msdn-id>	
    /// <unmanaged>ID3DXKeyframedAnimationSet</unmanaged>	
    /// <unmanaged-short>ID3DXKeyframedAnimationSet</unmanaged-short>	
    [Guid("fa4e8e3a-9786-407d-8b4c-5995893764af")]
    public partial class KeyframedAnimationSet : SharpDX.Direct3D9.AnimationSet {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.KeyframedAnimationSet"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public KeyframedAnimationSet(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.KeyframedAnimationSet"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.KeyframedAnimationSet(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.KeyframedAnimationSet(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the type of the animation set playback loop.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetPlaybackType']/*"/>	
        /// <msdn-id>bb173997</msdn-id>	
        /// <unmanaged>GetPlaybackType</unmanaged>	
        /// <unmanaged-short>GetPlaybackType</unmanaged-short>	
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXKeyframedAnimationSet::GetPlaybackType()</unmanaged>
        public SharpDX.Direct3D9.PlaybackType PlaybackType {
                get { return GetPlaybackType(); }
        }
        
        /// <summary>	
        /// <p>Gets the number of animation key frame ticks that occur per second.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetSourceTicksPerSecond']/*"/>	
        /// <msdn-id>bb174004</msdn-id>	
        /// <unmanaged>GetSourceTicksPerSecond</unmanaged>	
        /// <unmanaged-short>GetSourceTicksPerSecond</unmanaged-short>	
        /// <unmanaged>double ID3DXKeyframedAnimationSet::GetSourceTicksPerSecond()</unmanaged>
        public double SourceTicksPerSecond {
                get { return GetSourceTicksPerSecond(); }
        }
        
        /// <summary>	
        /// <p>Gets the number of callback keys in the animation set.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetNumCallbackKeys']/*"/>	
        /// <msdn-id>bb173993</msdn-id>	
        /// <unmanaged>GetNumCallbackKeys</unmanaged>	
        /// <unmanaged-short>GetNumCallbackKeys</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXKeyframedAnimationSet::GetNumCallbackKeys()</unmanaged>
        public int NumCallbackKeys {
                get { return GetNumCallbackKeys(); }
        }
        
        /// <summary>	
        /// <p>Gets the type of the animation set playback loop.</p>	
        /// </summary>	
        /// <returns><p>Type of the animation set playback loop. See <strong><see cref="SharpDX.Direct3D9.PlaybackType"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetPlaybackType']/*"/>	
        /// <msdn-id>bb173997</msdn-id>	
        /// <unmanaged>D3DXPLAYBACK_TYPE ID3DXKeyframedAnimationSet::GetPlaybackType()</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetPlaybackType</unmanaged-short>	
        internal SharpDX.Direct3D9.PlaybackType GetPlaybackType() {
            unsafe {
                SharpDX.Direct3D9.PlaybackType __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXDirect3D9PlaybackType(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of animation key frame ticks that occur per second.</p>	
        /// </summary>	
        /// <returns><p>Number of animation key frame ticks that occur per second.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetSourceTicksPerSecond']/*"/>	
        /// <msdn-id>bb174004</msdn-id>	
        /// <unmanaged>double ID3DXKeyframedAnimationSet::GetSourceTicksPerSecond()</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetSourceTicksPerSecond</unmanaged-short>	
        internal double GetSourceTicksPerSecond() {
            unsafe {
                double __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callidouble(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of scale keys in the specified key frame animation.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <returns><p>Number of scale keys in the specified key frame animation.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetNumScaleKeys']/*"/>	
        /// <msdn-id>bb173995</msdn-id>	
        /// <unmanaged>unsigned int ID3DXKeyframedAnimationSet::GetNumScaleKeys([In] unsigned int Animation)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetNumScaleKeys</unmanaged-short>	
        public int GetNumScaleKeys(int animation) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation,((void**)(*(void**)_nativePointer))[13]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Fills an array with scale key data used for key frame animation.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="scaleKeysRef"><dd>  <p>Pointer to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong> vectors that the method is to fill with animation scale data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetScaleKeys']/*"/>	
        /// <msdn-id>bb174003</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetScaleKeys([In] unsigned int Animation,[In] D3DXKEY_VECTOR3* pScaleKeys)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetScaleKeys</unmanaged-short>	
        public void GetScaleKeys(int animation, SharpDX.Direct3D9.ScaleKey scaleKeysRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, &scaleKeysRef,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get scale information for a specific key frame in the animation set.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key frame.</p> </dd></param>	
        /// <param name="scaleKeyRef"><dd>  <p>Pointer to the scale data. See  <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetScaleKey']/*"/>	
        /// <msdn-id>bb174002</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetScaleKey([In] unsigned int Animation,[In] unsigned int Key,[In] D3DXKEY_VECTOR3* pScaleKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetScaleKey</unmanaged-short>	
        public void GetScaleKey(int animation, int key, SharpDX.Direct3D9.ScaleKey scaleKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key, &scaleKeyRef,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set scale information for a specific key frame in the animation set.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key frame.</p> </dd></param>	
        /// <param name="scaleKeyRef"><dd>  <p>Pointer to the scale data. See <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::SetScaleKey']/*"/>	
        /// <msdn-id>bb174010</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetScaleKey([In] unsigned int Animation,[In] unsigned int Key,[In] D3DXKEY_VECTOR3* pScaleKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::SetScaleKey</unmanaged-short>	
        public void SetScaleKey(int animation, int key, SharpDX.Direct3D9.ScaleKey scaleKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key, &scaleKeyRef,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of rotation keys in the specified key frame animation.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <returns><p>Number of rotation keys in the specified key frame animation.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetNumRotationKeys']/*"/>	
        /// <msdn-id>bb173994</msdn-id>	
        /// <unmanaged>unsigned int ID3DXKeyframedAnimationSet::GetNumRotationKeys([In] unsigned int Animation)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetNumRotationKeys</unmanaged-short>	
        public int GetNumRotationKeys(int animation) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation,((void**)(*(void**)_nativePointer))[17]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Fills an array with rotational key data used for key frame animation.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="rotationKeysRef"><dd>  <p>Pointer to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.RotationKey"/></strong> quaternions that the method is to fill with animation rotation data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetRotationKeys']/*"/>	
        /// <msdn-id>bb174001</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetRotationKeys([In] unsigned int Animation,[In] D3DXKEY_QUATERNION* pRotationKeys)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetRotationKeys</unmanaged-short>	
        public void GetRotationKeys(int animation, ref SharpDX.Direct3D9.RotationKey rotationKeysRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* rotationKeysRef_ = &rotationKeysRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, rotationKeysRef_,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get rotation information for a specific key frame in the animation set.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key frame.</p> </dd></param>	
        /// <param name="rotationKeyRef"><dd>  <p>Pointer to the rotation data. See  <strong><see cref="SharpDX.Direct3D9.RotationKey"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetRotationKey']/*"/>	
        /// <msdn-id>bb173998</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetRotationKey([In] unsigned int Animation,[In] unsigned int Key,[In] D3DXKEY_QUATERNION* pRotationKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetRotationKey</unmanaged-short>	
        public void GetRotationKey(int animation, int key, ref SharpDX.Direct3D9.RotationKey rotationKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* rotationKeyRef_ = &rotationKeyRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key, rotationKeyRef_,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set rotation information for a specific key frame in the animation set.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key frame.</p> </dd></param>	
        /// <param name="rotationKeyRef"><dd>  <p>Pointer to the rotation data. See <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::SetRotationKey']/*"/>	
        /// <msdn-id>bb174009</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetRotationKey([In] unsigned int Animation,[In] unsigned int Key,[In] D3DXKEY_QUATERNION* pRotationKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::SetRotationKey</unmanaged-short>	
        public void SetRotationKey(int animation, int key, ref SharpDX.Direct3D9.RotationKey rotationKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* rotationKeyRef_ = &rotationKeyRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key, rotationKeyRef_,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of translation keys in the specified key frame animation.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <returns><p>Number of translation keys in the specified key frame animation.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetNumTranslationKeys']/*"/>	
        /// <msdn-id>bb173996</msdn-id>	
        /// <unmanaged>unsigned int ID3DXKeyframedAnimationSet::GetNumTranslationKeys([In] unsigned int Animation)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetNumTranslationKeys</unmanaged-short>	
        public int GetNumTranslationKeys(int animation) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation,((void**)(*(void**)_nativePointer))[21]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Fills an array with translational key data used for key frame animation.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="translationKeysRef"><dd>  <p>Pointer to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong> vectors that the method is to fill with animation translation data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetTranslationKeys']/*"/>	
        /// <msdn-id>bb174006</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetTranslationKeys([In] unsigned int Animation,[In] D3DXKEY_VECTOR3* pTranslationKeys)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetTranslationKeys</unmanaged-short>	
        public void GetTranslationKeys(int animation, SharpDX.Direct3D9.ScaleKey translationKeysRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, &translationKeysRef,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get translation information for a specific key frame in the animation set.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key Frame.</p> </dd></param>	
        /// <param name="translationKeyRef"><dd>  <p>Pointer to the rotation information. See <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetTranslationKey']/*"/>	
        /// <msdn-id>bb174005</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetTranslationKey([In] unsigned int Animation,[In] unsigned int Key,[In] D3DXKEY_VECTOR3* pTranslationKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetTranslationKey</unmanaged-short>	
        public void GetTranslationKey(int animation, int key, SharpDX.Direct3D9.ScaleKey translationKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key, &translationKeyRef,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set translation information for a specific key frame in the animation set.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key Frame.</p> </dd></param>	
        /// <param name="translationKeyRef"><dd>  <p>Pointer to the translation data. See <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::SetTranslationKey']/*"/>	
        /// <msdn-id>bb174011</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetTranslationKey([In] unsigned int Animation,[In] unsigned int Key,[In] D3DXKEY_VECTOR3* pTranslationKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::SetTranslationKey</unmanaged-short>	
        public void SetTranslationKey(int animation, int key, SharpDX.Direct3D9.ScaleKey translationKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key, &translationKeyRef,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of callback keys in the animation set.</p>	
        /// </summary>	
        /// <returns><p>Number of callback keys in the animation set.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetNumCallbackKeys']/*"/>	
        /// <msdn-id>bb173993</msdn-id>	
        /// <unmanaged>unsigned int ID3DXKeyframedAnimationSet::GetNumCallbackKeys()</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetNumCallbackKeys</unmanaged-short>	
        internal int GetNumCallbackKeys() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[25]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Fills an array with callback key data used for key frame animation.</p>	
        /// </summary>	
        /// <param name="callbackKeysRef"><dd>  <p>Pointer to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.CallbackKey"/></strong> structures that the method is to fill with callback data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetCallbackKeys']/*"/>	
        /// <msdn-id>bb173992</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetCallbackKeys([In] D3DXKEY_CALLBACK* pCallbackKeys)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetCallbackKeys</unmanaged-short>	
        public void GetCallbackKeys(SharpDX.Direct3D9.CallbackKey callbackKeysRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &callbackKeysRef,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets information about a specific callback in the animation set.</p>	
        /// </summary>	
        /// <param name="key"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="callbackKeyRef"><dd>  <p>Pointer to the <strong>callback function</strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::GetCallbackKey']/*"/>	
        /// <msdn-id>bb173991</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::GetCallbackKey([In] unsigned int Key,[In] D3DXKEY_CALLBACK* pCallbackKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::GetCallbackKey</unmanaged-short>	
        public void GetCallbackKey(int key, SharpDX.Direct3D9.CallbackKey callbackKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, key, &callbackKeyRef,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets information about a specific callback in the animation set.</p>	
        /// </summary>	
        /// <param name="key"><dd>  <p>Animation index.</p> </dd></param>	
        /// <param name="callbackKeyRef"><dd>  <p>Pointer to the <strong>callback function</strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::SetCallbackKey']/*"/>	
        /// <msdn-id>bb174008</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::SetCallbackKey([In] unsigned int Key,[In] D3DXKEY_CALLBACK* pCallbackKey)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::SetCallbackKey</unmanaged-short>	
        public void SetCallbackKey(int key, SharpDX.Direct3D9.CallbackKey callbackKeyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, key, &callbackKeyRef,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes the scale data at the specified key frame.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation identifier.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key frame.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is slow and should not be used after an animation has begun to play.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::UnregisterScaleKey']/*"/>	
        /// <msdn-id>bb174014</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterScaleKey([In] unsigned int Animation,[In] unsigned int Key)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::UnregisterScaleKey</unmanaged-short>	
        public void UnregisterScaleKey(int animation, int key) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key,((void**)(*(void**)_nativePointer))[29]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes the rotation data at the specified key frame.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation identifier.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key frame.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is slow and should not be used after an animation has begun to play.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::UnregisterRotationKey']/*"/>	
        /// <msdn-id>bb174013</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterRotationKey([In] unsigned int Animation,[In] unsigned int Key)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::UnregisterRotationKey</unmanaged-short>	
        public void UnregisterRotationKey(int animation, int key) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Removes the translation data at the specified key frame.</p>	
        /// </summary>	
        /// <param name="animation"><dd>  <p>Animation identifier.</p> </dd></param>	
        /// <param name="key"><dd>  <p>Key frame.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is slow and should not be used after an animation has begun to play.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::UnregisterTranslationKey']/*"/>	
        /// <msdn-id>bb174015</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterTranslationKey([In] unsigned int Animation,[In] unsigned int Key)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::UnregisterTranslationKey</unmanaged-short>	
        public void UnregisterTranslationKey(int animation, int key) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, animation, key,((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Register the scale, rotate, and translate (SRT) key frame data for an animation.</p>	
        /// </summary>	
        /// <param name="nameRef"><dd>  <p>Pointer to the animation name.</p> </dd></param>	
        /// <param name="numScaleKeys"><dd>  <p>Number of scale keys.</p> </dd></param>	
        /// <param name="numRotationKeys"><dd>  <p>Number of rotation keys.</p> </dd></param>	
        /// <param name="numTranslationKeys"><dd>  <p>Number of translation keys.</p> </dd></param>	
        /// <param name="scaleKeysRef"><dd>  <p>Address of a reference to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong> vectors that the method fills with scale data.</p> </dd></param>	
        /// <param name="rotationKeysRef"><dd>  <p>Address of a reference to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.RotationKey"/></strong> quaternions that the method fills with rotation data.</p> </dd></param>	
        /// <param name="translationKeysRef"><dd>  <p>Address of a reference to a user-allocated array of <strong><see cref="SharpDX.Direct3D9.ScaleKey"/></strong> vectors that the method fills with translation data.</p> </dd></param>	
        /// <param name="animationIndexRef"><dd>  <p>Returns the animation index.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::RegisterAnimationSRTKeys']/*"/>	
        /// <msdn-id>bb174007</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::RegisterAnimationSRTKeys([In] const char* pName,[In] unsigned int NumScaleKeys,[In] unsigned int NumRotationKeys,[In] unsigned int NumTranslationKeys,[In] const D3DXKEY_VECTOR3* pScaleKeys,[In] const D3DXKEY_QUATERNION* pRotationKeys,[In] const D3DXKEY_VECTOR3* pTranslationKeys,[In] unsigned int* pAnimationIndex)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::RegisterAnimationSRTKeys</unmanaged-short>	
        public void RegisterAnimationSRTKeys(string nameRef, int numScaleKeys, int numRotationKeys, int numTranslationKeys, SharpDX.Direct3D9.ScaleKey scaleKeysRef, ref SharpDX.Direct3D9.RotationKey rotationKeysRef, SharpDX.Direct3D9.ScaleKey translationKeysRef, int animationIndexRef) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Result __result__;
                fixed (void* rotationKeysRef_ = &rotationKeysRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)nameRef_, numScaleKeys, numRotationKeys, numTranslationKeys, &scaleKeysRef, rotationKeysRef_, &translationKeysRef, &animationIndexRef,((void**)(*(void**)_nativePointer))[32]);		
                Marshal.FreeHGlobal(nameRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Transforms animations in an animation set into a compressed format and returns a reference to the buffer that stores the compressed data.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>One of the <strong><see cref="SharpDX.Direct3D9.CompressionFlags"/></strong> values that define the compression mode used for storing compressed animation set data. <see cref="SharpDX.Direct3D9.CompressionFlags.Default"/> is the only value currently supported.</p> </dd></param>	
        /// <param name="lossiness"><dd>  <p>Desired compression loss ratio, in the range from 0 to 1.</p> </dd></param>	
        /// <param name="hierarchyRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Frame"/></strong> transformation frame hierarchy. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="compressedDataOut"><dd>  <p>Address of a reference to the <strong><see cref="SharpDX.Direct3D.Blob"/></strong> compressed animation set.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::Compress']/*"/>	
        /// <msdn-id>bb173990</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::Compress([In] unsigned int Flags,[In] float Lossiness,[In] D3DXFRAME* pHierarchy,[In] ID3DXBuffer** ppCompressedData)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::Compress</unmanaged-short>	
        public void Compress(int flags, float lossiness, ref SharpDX.Direct3D9.Frame hierarchyRef, out SharpDX.Direct3D.Blob compressedDataOut) {
            unsafe {
                var hierarchyRef_ = new SharpDX.Direct3D9.Frame.__Native();
                hierarchyRef.__MarshalTo(ref hierarchyRef_);
                IntPtr compressedDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, lossiness, &hierarchyRef_, &compressedDataOut_,((void**)(*(void**)_nativePointer))[33]);		
                hierarchyRef.__MarshalFree(ref hierarchyRef_);
                compressedDataOut= (compressedDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compressedDataOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Remove the animation data from the animation set.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The animation index.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXKeyframedAnimationSet::UnregisterAnimation']/*"/>	
        /// <msdn-id>bb174012</msdn-id>	
        /// <unmanaged>HRESULT ID3DXKeyframedAnimationSet::UnregisterAnimation([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXKeyframedAnimationSet::UnregisterAnimation</unmanaged-short>	
        public void UnregisterAnimation(int index) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, index,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D9.Line"/> interface implements line drawing using textured triangles.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Create a line drawing object with <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateLine"/></strong>.</p><p>The LPD3DXLINE type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.Line"/></strong> interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.Line"/> <see cref="SharpDX.Direct3D9.Line"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.Line"/> *LPD3DXLINE;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine']/*"/>	
    /// <msdn-id>bb174016</msdn-id>	
    /// <unmanaged>ID3DXLine</unmanaged>	
    /// <unmanaged-short>ID3DXLine</unmanaged-short>	
    [Guid("d379ba7f-9042-4ac4-9f5e-58192a4c6bd8")]
    public partial class Line : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Line"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Line(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Line"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Line(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Line(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the line object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetDevice']/*"/>	
        /// <msdn-id>bb174022</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXLine::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets or sets the line stipple pattern.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetPattern']/*"/>	
        /// <msdn-id>bb174024</msdn-id>	
        /// <unmanaged>GetPattern / SetPattern</unmanaged>	
        /// <unmanaged-short>GetPattern</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXLine::GetPattern()</unmanaged>
        public int Pattern {
                get { return GetPattern(); }
                set { SetPattern(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the stipple-pattern scale value.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetPatternScale']/*"/>	
        /// <msdn-id>bb174025</msdn-id>	
        /// <unmanaged>GetPatternScale / SetPatternScale</unmanaged>	
        /// <unmanaged-short>GetPatternScale</unmanaged-short>	
        /// <unmanaged>float ID3DXLine::GetPatternScale()</unmanaged>
        public float PatternScale {
                get { return GetPatternScale(); }
                set { SetPatternScale(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the thickness of the line.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetWidth']/*"/>	
        /// <msdn-id>bb174026</msdn-id>	
        /// <unmanaged>GetWidth / SetWidth</unmanaged>	
        /// <unmanaged-short>GetWidth</unmanaged-short>	
        /// <unmanaged>float ID3DXLine::GetWidth()</unmanaged>
        public float Width {
                get { return GetWidth(); }
                set { SetWidth(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the line antialiasing state.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetAntialias']/*"/>	
        /// <msdn-id>bb174021</msdn-id>	
        /// <unmanaged>GetAntialias / SetAntialias</unmanaged>	
        /// <unmanaged-short>GetAntialias</unmanaged-short>	
        /// <unmanaged>BOOL ID3DXLine::GetAntialias()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool Antialias {
                get { return GetAntialias(); }
                set { SetAntialias(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the OpenGL-style line-drawing mode.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetGLLines']/*"/>	
        /// <msdn-id>bb174023</msdn-id>	
        /// <unmanaged>GetGLLines / SetGLLines</unmanaged>	
        /// <unmanaged-short>GetGLLines</unmanaged-short>	
        /// <unmanaged>BOOL ID3DXLine::GetGLLines()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool GLLines {
                get { return GetGLLines(); }
                set { SetGLLines(value); }
        }
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the line object.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the Direct3D device object associated with the line object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetDevice']/*"/>	
        /// <msdn-id>bb174022</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Prepares a device for drawing lines.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>Calling <strong><see cref="SharpDX.Direct3D9.Line.Begin"/></strong> is optional. If called outside of a <see cref="SharpDX.Direct3D9.Line.Begin"/>/<see cref="SharpDX.Direct3D9.Line.End"/> sequence, the draw functions will internally call <see cref="SharpDX.Direct3D9.Line.Begin"/> and <see cref="SharpDX.Direct3D9.Line.End"/>. To avoid extra overhead, this method should be used if more than one draw function will be called successively.</p><p>This method must be called from inside an <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> and <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> sequence.</p><p><see cref="SharpDX.Direct3D9.Line.Begin"/> cannot be used as a substitute for either <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> or <strong><see cref="SharpDX.Direct3D9.RenderToSurface.BeginScene"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::Begin']/*"/>	
        /// <msdn-id>bb174017</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::Begin()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::Begin</unmanaged-short>	
        public void Begin() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Draws a line strip in screen space. Input is in the form of an array that defines points (of <strong><see cref="SharpDX.Mathematics.Interop.RawVector2"/></strong>) on the line strip.</p>	
        /// </summary>	
        /// <param name="vertexListRef">No documentation.</param>	
        /// <param name="dwVertexListCount">No documentation.</param>	
        /// <param name="color">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::Draw']/*"/>	
        /// <msdn-id>bb174018</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::Draw([In] const void* pVertexList,[In] unsigned int dwVertexListCount,[In] D3DCOLOR Color)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::Draw</unmanaged-short>	
        internal void Draw(System.IntPtr vertexListRef, int dwVertexListCount, SharpDX.Mathematics.Interop.RawColorBGRA color) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint77(_nativePointer, (void*)vertexListRef, dwVertexListCount, color,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Draws a line strip in screen space with a specified input transformation matrix.</p>	
        /// </summary>	
        /// <param name="vertexListRef"><dd>  <p>Array of vertices that make up the line. See <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong>.</p> </dd></param>	
        /// <param name="dwVertexListCount"><dd>  <p>Number of vertices in the vertex list.</p> </dd></param>	
        /// <param name="transformRef"><dd>  <p>A scale, rotate, and translate (SRT) matrix for transforming the points. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>. If this matrix is a projection matrix, any stippled lines will be drawn with a perspective-correct stippling pattern. Or, you can transform the vertices and use <strong><see cref="SharpDX.Direct3D9.Line.Draw"/></strong> to draw the line with a nonperspective-correct stipple pattern.</p> </dd></param>	
        /// <param name="color"><dd>  <p>Color of the line. See <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::DrawTransform']/*"/>	
        /// <msdn-id>bb174019</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::DrawTransform([In] const void* pVertexList,[In] unsigned int dwVertexListCount,[In] const D3DXMATRIX* pTransform,[In] D3DCOLOR Color)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::DrawTransform</unmanaged-short>	
        internal void DrawTransform(System.IntPtr vertexListRef, int dwVertexListCount, ref SharpDX.Mathematics.Interop.RawMatrix transformRef, SharpDX.Mathematics.Interop.RawColorBGRA color) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* transformRef_ = &transformRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint78(_nativePointer, (void*)vertexListRef, dwVertexListCount, transformRef_, color,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Applies a stipple pattern to the line.</p>	
        /// </summary>	
        /// <param name="dwPattern"><dd>  <p>Describes the stipple pattern: 1 is opaque, 0 is transparent.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::SetPattern']/*"/>	
        /// <msdn-id>bb174031</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::SetPattern([In] unsigned int dwPattern)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::SetPattern</unmanaged-short>	
        internal void SetPattern(int dwPattern) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, dwPattern,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the line stipple pattern.</p>	
        /// </summary>	
        /// <returns><p>Returns the line stipple pattern: 1 is opaque, 0 is transparent.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetPattern']/*"/>	
        /// <msdn-id>bb174024</msdn-id>	
        /// <unmanaged>unsigned int ID3DXLine::GetPattern()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::GetPattern</unmanaged-short>	
        internal int GetPattern() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Stretches the stipple pattern along the line direction.</p>	
        /// </summary>	
        /// <param name="fPatternScale"><dd>  <p>Stipple pattern scaling value. 1.0f is the default value and represents no scaling. A value less than 1.0f shrinks the pattern, and a value greater than 1.0 stretches the pattern.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::SetPatternScale']/*"/>	
        /// <msdn-id>bb174032</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::SetPatternScale([In] float fPatternScale)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::SetPatternScale</unmanaged-short>	
        internal void SetPatternScale(float fPatternScale) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, fPatternScale,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the stipple-pattern scale value.</p>	
        /// </summary>	
        /// <returns><p>Returns the value used to scale the stipple-pattern. 1.0f is the default value and represents no scaling. A value less than 1.0f shrinks the pattern, and a value greater than 1.0 stretches the pattern.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetPatternScale']/*"/>	
        /// <msdn-id>bb174025</msdn-id>	
        /// <unmanaged>float ID3DXLine::GetPatternScale()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::GetPatternScale</unmanaged-short>	
        internal float GetPatternScale() {
            unsafe {
                float __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callifloat(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Specifies the thickness of the line.</p>	
        /// </summary>	
        /// <param name="fWidth"><dd>  <p>Describes the line width.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::SetWidth']/*"/>	
        /// <msdn-id>bb174033</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::SetWidth([In] float fWidth)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::SetWidth</unmanaged-short>	
        internal void SetWidth(float fWidth) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, fWidth,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the thickness of the line.</p>	
        /// </summary>	
        /// <returns><p>The line thickness.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetWidth']/*"/>	
        /// <msdn-id>bb174026</msdn-id>	
        /// <unmanaged>float ID3DXLine::GetWidth()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::GetWidth</unmanaged-short>	
        internal float GetWidth() {
            unsafe {
                float __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callifloat(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Toggles line antialiasing.</p>	
        /// </summary>	
        /// <param name="bAntialias"><dd>  <p>Toggles antialiasing on and off. <strong>TRUE</strong> turns antialiasing on, and <strong><see cref="SharpDX.Result.False"/></strong> turns antialiasing off.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::SetAntialias']/*"/>	
        /// <msdn-id>bb174029</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::SetAntialias([In] BOOL bAntialias)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::SetAntialias</unmanaged-short>	
        internal void SetAntialias(SharpDX.Mathematics.Interop.RawBool bAntialias) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint17(_nativePointer, bAntialias,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the line antialiasing state.</p>	
        /// </summary>	
        /// <returns><p>Returns the antialiasing switch value. <strong>TRUE</strong> means antialiasing is on, and <strong><see cref="SharpDX.Result.False"/></strong> means antialiasing is off.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetAntialias']/*"/>	
        /// <msdn-id>bb174021</msdn-id>	
        /// <unmanaged>BOOL ID3DXLine::GetAntialias()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::GetAntialias</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetAntialias() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Toggles the mode to draw OpenGL-style lines.</p>	
        /// </summary>	
        /// <param name="bGLLines"><dd>  <p>Toggles OpenGL-style line drawing. <strong>TRUE</strong> enables OpenGL-style lines, and <strong><see cref="SharpDX.Result.False"/></strong> enables Direct3D-style lines.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::SetGLLines']/*"/>	
        /// <msdn-id>bb174030</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::SetGLLines([In] BOOL bGLLines)</unmanaged>	
        /// <unmanaged-short>ID3DXLine::SetGLLines</unmanaged-short>	
        internal void SetGLLines(SharpDX.Mathematics.Interop.RawBool bGLLines) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint17(_nativePointer, bGLLines,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the OpenGL-style line-drawing mode.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if OpenGL-style lines are enabled, and <strong><see cref="SharpDX.Result.False"/></strong> if Direct3D-style lines are enabled.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::GetGLLines']/*"/>	
        /// <msdn-id>bb174023</msdn-id>	
        /// <unmanaged>BOOL ID3DXLine::GetGLLines()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::GetGLLines</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetGLLines() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Restores the device state to how it was when <strong><see cref="SharpDX.Direct3D9.Line.Begin"/></strong> was called.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Line.End"/></strong> cannot be used as a substitute for either <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> or <strong><see cref="SharpDX.Direct3D9.RenderToSurface.EndScene"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::End']/*"/>	
        /// <msdn-id>bb174020</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::End()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::End</unmanaged-short>	
        public void End() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method should be called whenever the device is lost or before the user calls <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>. Even if the device was not actually lost, <strong><see cref="SharpDX.Direct3D9.Line.OnLostDevice"/></strong> is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> and then <strong><see cref="SharpDX.Direct3D9.Line.OnResetDevice"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::OnLostDevice']/*"/>	
        /// <msdn-id>bb174027</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::OnLostDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::OnLostDevice</unmanaged-short>	
        public void OnLostDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to re-acquire resources and save initial state.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Line.OnResetDevice"/></strong> should be called each time the device is reset (using <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXLine::OnResetDevice']/*"/>	
        /// <msdn-id>bb174028</msdn-id>	
        /// <unmanaged>HRESULT ID3DXLine::OnResetDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXLine::OnResetDevice</unmanaged-short>	
        public void OnResetDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.Mesh"/> interface to manipulate mesh objects.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To obtain the <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, call either the <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateMesh"/></strong> or <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateMeshFVF"/></strong> function.</p><p>This interface inherits additional functionality from the <strong><see cref="SharpDX.Direct3D9.BaseMesh"/></strong> interface.</p><p>The LPD3DXMESH type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.Mesh"/> *LPD3DXMESH;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXMesh']/*"/>	
    /// <msdn-id>bb174069</msdn-id>	
    /// <unmanaged>ID3DXMesh</unmanaged>	
    /// <unmanaged-short>ID3DXMesh</unmanaged-short>	
    [Guid("4020e5c2-1403-4929-883f-e2e849fac195")]
    public partial class Mesh : SharpDX.Direct3D9.BaseMesh {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Mesh"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Mesh(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Mesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Mesh(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Mesh(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Locks the mesh buffer that contains the mesh attribute data, and returns a reference to it.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p>For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>Address of a reference to a buffer containing a DWORD for each face in the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If <strong><see cref="SharpDX.Direct3D9.Mesh.Optimize"/></strong> has been called, the mesh will also have an attribute table that can be accessed using the <strong><see cref="SharpDX.Direct3D9.BaseMesh.GetAttributeTable"/></strong> method. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXMesh::LockAttributeBuffer']/*"/>	
        /// <msdn-id>bb174070</msdn-id>	
        /// <unmanaged>HRESULT ID3DXMesh::LockAttributeBuffer([In] unsigned int Flags,[In] unsigned int** ppData)</unmanaged>	
        /// <unmanaged-short>ID3DXMesh::LockAttributeBuffer</unmanaged-short>	
        public void LockAttributeBuffer(int flags, int dataOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, &dataOut,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks an attribute buffer.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXMesh::UnlockAttributeBuffer']/*"/>	
        /// <msdn-id>bb174074</msdn-id>	
        /// <unmanaged>HRESULT ID3DXMesh::UnlockAttributeBuffer()</unmanaged>	
        /// <unmanaged-short>ID3DXMesh::UnlockAttributeBuffer</unmanaged-short>	
        public void UnlockAttributeBuffer() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generates a new mesh with reordered faces and vertices to optimize drawing performance.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Specifies the type of optimization to perform. This parameter can be set to a combination of one or more flags from <strong>D3DXMESHOPT</strong> and <strong>D3DXMESH</strong> (except <see cref="SharpDX.Direct3D9.MeshFlags.Use32Bit"/>, <see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferWriteOnly"/>, and <see cref="SharpDX.Direct3D9.MeshFlags.WriteOnly"/>).</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. See Remarks.</p> </dd></param>	
        /// <param name="adjacencyOutRef"><dd>  <p>Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff.</p> </dd></param>	
        /// <param name="faceRemapRef"><dd>  <p>An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is <strong><c>null</c></strong>, face remap data is not returned.</p> </dd></param>	
        /// <param name="vertexRemapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping.</p> </dd></param>	
        /// <param name="optMeshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the optimized mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method generates a new mesh. Before running Optimize, an application must generate an adjacency buffer by calling <strong><see cref="SharpDX.Direct3D9.BaseMesh.GenerateAdjacency"/></strong>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other.</p><p>This method is very similar to the <strong><see cref="SharpDX.Direct3D9.BaseMesh.CloneMesh"/></strong> method, except that it can perform optimization while generating the new clone of the mesh. The output mesh inherits all of the creation parameters of the input mesh.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXMesh::Optimize']/*"/>	
        /// <msdn-id>bb174071</msdn-id>	
        /// <unmanaged>HRESULT ID3DXMesh::Optimize([In] unsigned int Flags,[In] const unsigned int* pAdjacencyIn,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pFaceRemap,[In] ID3DXBuffer** ppVertexRemap,[In] ID3DXMesh** ppOptMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXMesh::Optimize</unmanaged-short>	
        public void Optimize(int flags, int adjacencyInRef, int adjacencyOutRef, int faceRemapRef, out SharpDX.Direct3D.Blob vertexRemapOut, out SharpDX.Direct3D9.Mesh optMeshOut) {
            unsafe {
                IntPtr vertexRemapOut_ = IntPtr.Zero;
                IntPtr optMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, &adjacencyInRef, &adjacencyOutRef, &faceRemapRef, &vertexRemapOut_, &optMeshOut_,((void**)(*(void**)_nativePointer))[26]);		
                vertexRemapOut= (vertexRemapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapOut_);	
                optMeshOut= (optMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(optMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generates a mesh with reordered faces and vertices to optimize drawing performance. This method reorders the existing mesh.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of one or more <strong>D3DXMESHOPT</strong> flags, specifying the type of optimization to perform.</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff.</p> </dd></param>	
        /// <param name="adjacencyOutRef"><dd>  <p>Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff. If the value supplied for this argument is <strong><c>null</c></strong>, adjacency data is not returned.</p> </dd></param>	
        /// <param name="faceRemapRef"><dd>  <p>An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is <strong><c>null</c></strong>, face remap data is not returned.</p> </dd></param>	
        /// <param name="vertexRemapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. If the value supplied for this argument is <strong><c>null</c></strong>, vertex remap data is not returned.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_CANNOTATTRSORT, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Before running <strong><see cref="SharpDX.Direct3D9.Mesh.OptimizeInplace"/></strong>, an application must generate an adjacency buffer by calling <strong><see cref="SharpDX.Direct3D9.BaseMesh.GenerateAdjacency"/></strong>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other.</p><p><strong>Note</strong>??This method will fail if the mesh is sharing its vertex buffer with another mesh, unless the <see cref="SharpDX.Direct3D9.MeshOptimizeFlags.IgnoreVertices"/> is set in Flags.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXMesh::OptimizeInplace']/*"/>	
        /// <msdn-id>bb174072</msdn-id>	
        /// <unmanaged>HRESULT ID3DXMesh::OptimizeInplace([In] unsigned int Flags,[In] const unsigned int* pAdjacencyIn,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pFaceRemap,[In] ID3DXBuffer** ppVertexRemap)</unmanaged>	
        /// <unmanaged-short>ID3DXMesh::OptimizeInplace</unmanaged-short>	
        public void OptimizeInplace(int flags, int adjacencyInRef, int adjacencyOutRef, int faceRemapRef, out SharpDX.Direct3D.Blob vertexRemapOut) {
            unsafe {
                IntPtr vertexRemapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, &adjacencyInRef, &adjacencyOutRef, &faceRemapRef, &vertexRemapOut_,((void**)(*(void**)_nativePointer))[27]);		
                vertexRemapOut= (vertexRemapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the attribute table for a mesh and the number of entries stored in the table.</p>	
        /// </summary>	
        /// <param name="attribTableRef"><dd>  <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.AttributeRange"/></strong> structures, representing the entries in the mesh attribute table.</p> </dd></param>	
        /// <param name="cAttribTableSize"><dd>  <p>Number of attributes in the mesh attribute table.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If an application keeps track of the information in an attribute table, and rearranges the table as a result of changes to attributes or faces, this method allows the application to update the attribute tables instead of calling <strong><see cref="SharpDX.Direct3D9.Mesh.Optimize"/></strong> again.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXMesh::SetAttributeTable']/*"/>	
        /// <msdn-id>bb174073</msdn-id>	
        /// <unmanaged>HRESULT ID3DXMesh::SetAttributeTable([In] const D3DXATTRIBUTERANGE* pAttribTable,[In] unsigned int cAttribTableSize)</unmanaged>	
        /// <unmanaged-short>ID3DXMesh::SetAttributeTable</unmanaged-short>	
        public void SetAttributeTable(ref SharpDX.Direct3D9.AttributeRange attribTableRef, int cAttribTableSize) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* attribTableRef_ = &attribTableRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, attribTableRef_, cAttribTableSize,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>This interface encapsulates patch mesh functionality.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A patch mesh is a mesh that consists of a series of patches. </p><p>To obtain the <strong><see cref="SharpDX.Direct3D9.PatchMesh"/></strong> interface, call the <strong><see cref="SharpDX.Direct3D9.D3DX9.CreatePatchMesh"/></strong> function.</p><p>The LPD3DXPATCHMESH type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.PatchMesh"/></strong> interface, as follows: </p><pre> typedef struct <see cref="SharpDX.Direct3D9.PatchMesh"/> *LPD3DXPATCHMESH;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh']/*"/>	
    /// <msdn-id>bb174075</msdn-id>	
    /// <unmanaged>ID3DXPatchMesh</unmanaged>	
    /// <unmanaged-short>ID3DXPatchMesh</unmanaged-short>	
    [Guid("3ce6cc22-dbf2-44f4-894d-f9c34a337139")]
    public partial class PatchMesh : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.PatchMesh"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PatchMesh(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.PatchMesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.PatchMesh(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.PatchMesh(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the number of patches in the mesh.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetNumPatches']/*"/>	
        /// <msdn-id>bb174083</msdn-id>	
        /// <unmanaged>GetNumPatches</unmanaged>	
        /// <unmanaged-short>GetNumPatches</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetNumPatches()</unmanaged>
        public int NumPatches {
                get { return GetNumPatches(); }
        }
        
        /// <summary>	
        /// <p>Gets the number of vertices in the mesh.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetNumVertices']/*"/>	
        /// <msdn-id>bb174084</msdn-id>	
        /// <unmanaged>GetNumVertices</unmanaged>	
        /// <unmanaged-short>GetNumVertices</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// <p>Gets the number of control vertices per patch.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetControlVerticesPerPatch']/*"/>	
        /// <msdn-id>bb174078</msdn-id>	
        /// <unmanaged>GetControlVerticesPerPatch</unmanaged>	
        /// <unmanaged-short>GetControlVerticesPerPatch</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetControlVerticesPerPatch()</unmanaged>
        public int ControlVerticesPerPatch {
                get { return GetControlVerticesPerPatch(); }
        }
        
        /// <summary>	
        /// <p>Gets the type of patch.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>For more information about patch types, see <strong><see cref="SharpDX.Direct3D9.PatchMeshType"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetOptions']/*"/>	
        /// <msdn-id>bb174085</msdn-id>	
        /// <unmanaged>GetOptions</unmanaged>	
        /// <unmanaged-short>GetOptions</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// <p>Gets the device that created the mesh.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetDevice']/*"/>	
        /// <msdn-id>bb174080</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the mesh vertex buffer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method assumes uniform tessellation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetVertexBuffer']/*"/>	
        /// <msdn-id>bb174088</msdn-id>	
        /// <unmanaged>GetVertexBuffer</unmanaged>	
        /// <unmanaged-short>GetVertexBuffer</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetVertexBuffer([Out] IDirect3DVertexBuffer9** ppVB)</unmanaged>
        public SharpDX.Direct3D9.VertexBuffer VertexBuffer {
                get { SharpDX.Direct3D9.VertexBuffer __output__; GetVertexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the mesh index buffer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p> The index buffer contains the vertex ordering in the vertex buffer. The index buffer is used to access the vertex buffer when the mesh is rendered.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetIndexBuffer']/*"/>	
        /// <msdn-id>bb174082</msdn-id>	
        /// <unmanaged>GetIndexBuffer</unmanaged>	
        /// <unmanaged-short>GetIndexBuffer</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetIndexBuffer([Out] IDirect3DIndexBuffer9** ppIB)</unmanaged>
        public SharpDX.Direct3D9.IndexBuffer IndexBuffer {
                get { SharpDX.Direct3D9.IndexBuffer __output__; GetIndexBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the number of patches in the mesh.</p>	
        /// </summary>	
        /// <returns><p>The number of patches.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetNumPatches']/*"/>	
        /// <msdn-id>bb174083</msdn-id>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetNumPatches()</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetNumPatches</unmanaged-short>	
        internal int GetNumPatches() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of vertices in the mesh.</p>	
        /// </summary>	
        /// <returns><p>The number of vertices.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetNumVertices']/*"/>	
        /// <msdn-id>bb174084</msdn-id>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetNumVertices()</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetNumVertices</unmanaged-short>	
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the vertex declaration.</p>	
        /// </summary>	
        /// <param name="declaration"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements describing the vertex format of the mesh vertices. The dimension of this declarator array is <strong><see cref="SharpDX.Direct3D9.VertexFormatDeclaratorCount.Max"/></strong>. The vertex element array ends with the <strong>D3DDECL_END</strong> macro.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The array of elements includes the <strong>D3DDECL_END</strong> macro, which ends the declaration.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetDeclaration']/*"/>	
        /// <msdn-id>bb174079</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDeclaration([In] D3DVERTEXELEMENT9* Declaration)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetDeclaration</unmanaged-short>	
        public void GetDeclaration(SharpDX.Direct3D9.VertexElement declaration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &declaration,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of control vertices per patch.</p>	
        /// </summary>	
        /// <returns><p>The number of control vertices per patch.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetControlVerticesPerPatch']/*"/>	
        /// <msdn-id>bb174078</msdn-id>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetControlVerticesPerPatch()</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetControlVerticesPerPatch</unmanaged-short>	
        internal int GetControlVerticesPerPatch() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the type of patch.</p>	
        /// </summary>	
        /// <returns><p>The patch type.</p></returns>	
        /// <remarks>	
        /// <p>For more information about patch types, see <strong><see cref="SharpDX.Direct3D9.PatchMeshType"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetOptions']/*"/>	
        /// <msdn-id>bb174085</msdn-id>	
        /// <unmanaged>unsigned int ID3DXPatchMesh::GetOptions()</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetOptions</unmanaged-short>	
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the device that created the mesh.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Pointer to the device.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetDevice']/*"/>	
        /// <msdn-id>bb174080</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[8]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the attributes of the patch.</p>	
        /// </summary>	
        /// <param name="patchInfo"><dd>  <p>Pointer to the structures containing the patch attributes. For more information about patch attributes, see <strong><see cref="SharpDX.Direct3D9.PatchInfo"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetPatchInfo']/*"/>	
        /// <msdn-id>bb174086</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetPatchInfo([In] D3DXPATCHINFO* PatchInfo)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetPatchInfo</unmanaged-short>	
        public void GetPatchInfo(SharpDX.Direct3D9.PatchInfo patchInfo) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &patchInfo,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the mesh vertex buffer.</p>	
        /// </summary>	
        /// <param name="vBOut"><dd>  <p>Pointer to the vertex buffer.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method assumes uniform tessellation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetVertexBuffer']/*"/>	
        /// <msdn-id>bb174088</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetVertexBuffer([Out] IDirect3DVertexBuffer9** ppVB)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetVertexBuffer</unmanaged-short>	
        internal void GetVertexBuffer(out SharpDX.Direct3D9.VertexBuffer vBOut) {
            unsafe {
                IntPtr vBOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &vBOut_,((void**)(*(void**)_nativePointer))[10]);		
                vBOut= (vBOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VertexBuffer(vBOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the mesh index buffer.</p>	
        /// </summary>	
        /// <param name="iBOut"><dd>  <p>Pointer to the index buffer.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p> The index buffer contains the vertex ordering in the vertex buffer. The index buffer is used to access the vertex buffer when the mesh is rendered.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetIndexBuffer']/*"/>	
        /// <msdn-id>bb174082</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetIndexBuffer([Out] IDirect3DIndexBuffer9** ppIB)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetIndexBuffer</unmanaged-short>	
        internal void GetIndexBuffer(out SharpDX.Direct3D9.IndexBuffer iBOut) {
            unsafe {
                IntPtr iBOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &iBOut_,((void**)(*(void**)_nativePointer))[11]);		
                iBOut= (iBOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.IndexBuffer(iBOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Lock the vertex buffer.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are: </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/></li> </ul> <p> For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>VOID* reference to a memory buffer containing the returned vertex data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The vertex buffer is usually locked, written to, and then unlocked for reading.</p><p>Patch meshes use 16-bit index buffers.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::LockVertexBuffer']/*"/>	
        /// <msdn-id>bb174091</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::LockVertexBuffer([In] unsigned int flags,[In] void** ppData)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::LockVertexBuffer</unmanaged-short>	
        public void LockVertexBuffer(int flags, System.IntPtr dataOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, (void*)dataOut,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlock the vertex buffer.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The vertex buffer is usually locked, written to, and then unlocked for reading.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::UnlockVertexBuffer']/*"/>	
        /// <msdn-id>bb174098</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::UnlockVertexBuffer()</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::UnlockVertexBuffer</unmanaged-short>	
        public void UnlockVertexBuffer() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Lock the index buffer.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p> For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>VOID* reference to a memory buffer containing the returned index data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The index buffer is usually locked, written to, and then unlocked for reading. Patch mesh index buffers are 16-bit buffers.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::LockIndexBuffer']/*"/>	
        /// <msdn-id>bb174090</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::LockIndexBuffer([In] unsigned int flags,[In] void** ppData)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::LockIndexBuffer</unmanaged-short>	
        public void LockIndexBuffer(int flags, System.IntPtr dataOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, (void*)dataOut,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlock the index buffer.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The index buffer is usually locked, written to, and then unlocked for reading.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::UnlockIndexBuffer']/*"/>	
        /// <msdn-id>bb174097</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::UnlockIndexBuffer()</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::UnlockIndexBuffer</unmanaged-short>	
        public void UnlockIndexBuffer() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Locks the attribute buffer.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p> For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>Address of a reference to a buffer containing a DWORD for each face in the mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The attribute buffer is usually locked, written to, and then unlocked for reading.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::LockAttributeBuffer']/*"/>	
        /// <msdn-id>bb174089</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::LockAttributeBuffer([In] unsigned int flags,[In] unsigned int** ppData)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::LockAttributeBuffer</unmanaged-short>	
        public void LockAttributeBuffer(int flags, int dataOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, &dataOut,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlock the attribute buffer.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The attribute buffer is usually locked, written to, and then unlocked for reading.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::UnlockAttributeBuffer']/*"/>	
        /// <msdn-id>bb174096</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::UnlockAttributeBuffer()</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::UnlockAttributeBuffer</unmanaged-short>	
        public void UnlockAttributeBuffer() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the size of the tessellated mesh, given a tessellation level.</p>	
        /// </summary>	
        /// <param name="fTessLevel"><dd>  <p>Tessellation level.</p> </dd></param>	
        /// <param name="adaptive"><dd>  <p>Adaptive tessellation. For adaptive tessellation, set this value to <strong>TRUE</strong> and set fTessLevel to the maximum tessellation value. This will result in the maximum mesh size necessary for adaptive tessellation.</p> </dd></param>	
        /// <param name="numTriangles"><dd>  <p>Pointer to the number of triangles generated by the tessellated mesh.</p> </dd></param>	
        /// <param name="numVertices"><dd>  <p>Pointer to the number of vertices generated by the tessellated mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method assumes uniform tessellation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetTessSize']/*"/>	
        /// <msdn-id>bb174087</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetTessSize([In] float fTessLevel,[In] unsigned int Adaptive,[Out] unsigned int* NumTriangles,[Out] unsigned int* NumVertices)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetTessSize</unmanaged-short>	
        public void GetTessSize(float fTessLevel, int adaptive, out int numTriangles, out int numVertices) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* numTriangles_ = &numTriangles)
                    fixed (void* numVertices_ = &numVertices)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, fTessLevel, adaptive, numTriangles_, numVertices_,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generate a list of mesh edges and the patches that share each edge.</p>	
        /// </summary>	
        /// <param name="tolerance"><dd>  <p>Specifies that vertices that differ in position by less than the tolerance should be treated as coincident.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>After an application generates adjacency information for a mesh, the mesh data can be optimized for better drawing performance. This method determines which patches are adjacent (within the provided tolerance). This information is used internally to optimize tessellation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GenerateAdjacency']/*"/>	
        /// <msdn-id>bb174077</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GenerateAdjacency([In] float Tolerance)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GenerateAdjacency</unmanaged-short>	
        public void GenerateAdjacency(float tolerance) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, tolerance,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a new patch mesh with the specified vertex declaration.</p>	
        /// </summary>	
        /// <param name="options"><dd>  <p>Combination of one or more <strong>D3DXMESH</strong> flags that specify creation options for the mesh.</p> </dd></param>	
        /// <param name="declRef"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements that specify the vertex format for the vertices in the output mesh.</p> </dd></param>	
        /// <param name="meshRef"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.PatchMesh"/></strong> interface that represents the cloned mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p><strong>CloneMesh</strong> converts the vertex buffer to the new vertex declaration. Entries in the vertex declaration that are new to the original mesh are set to 0. If the current mesh has adjacency, the new mesh will also have adjacency.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::CloneMesh']/*"/>	
        /// <msdn-id>bb174076</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::CloneMesh([In] unsigned int Options,[In] const D3DVERTEXELEMENT9* pDecl,[In] ID3DXPatchMesh** pMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::CloneMesh</unmanaged-short>	
        public void CloneMesh(int options, SharpDX.Direct3D9.VertexElement declRef, out SharpDX.Direct3D9.PatchMesh meshRef) {
            unsafe {
                IntPtr meshRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, &declRef, &meshRef_,((void**)(*(void**)_nativePointer))[20]);		
                meshRef= (meshRef_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.PatchMesh(meshRef_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Optimizes the patch mesh for efficient tessellation.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Currently unused.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_CANNOTATTRSORT.</p></returns>	
        /// <remarks>	
        /// <p>After an application generates adjacency information for a mesh, the mesh data can be optimized (reordered) for better drawing performance. This method determines which patches are adjacent (within the provided tolerance).</p><p>Adjacency information is also used to optimize tessellation. Generate adjacency information once and tessellate repeatedly by calling <strong><see cref="SharpDX.Direct3D9.PatchMesh.Tessellate"/></strong>. The optimization performed is independent of the actual tessellation level used. However, if the mesh vertices are changed, you must regenerate the adjacency information.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::Optimize']/*"/>	
        /// <msdn-id>bb174092</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::Optimize([In] unsigned int flags)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::Optimize</unmanaged-short>	
        public void Optimize(int flags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets mesh geometry displacement parameters.</p>	
        /// </summary>	
        /// <param name="texture"><dd>  <p>Texture containing the displacement data.</p> </dd></param>	
        /// <param name="minFilter"><dd>  <p>Minification level. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p> </dd></param>	
        /// <param name="magFilter"><dd>  <p>Magnification level. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p> </dd></param>	
        /// <param name="mipFilter"><dd>  <p>Mip filter level. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p> </dd></param>	
        /// <param name="wrap"><dd>  <p>Texture address wrap mode. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureAddress"/></strong> </p> </dd></param>	
        /// <param name="dwLODBias"><dd>  <p>Level of detail bias value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Displacement maps can only be 2D textures. Mipmapping is ignored for nonadaptive tessellation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::SetDisplaceParam']/*"/>	
        /// <msdn-id>bb174093</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::SetDisplaceParam([In] IDirect3DBaseTexture9* Texture,[In] D3DTEXTUREFILTERTYPE MinFilter,[In] D3DTEXTUREFILTERTYPE MagFilter,[In] D3DTEXTUREFILTERTYPE MipFilter,[In] D3DTEXTUREADDRESS Wrap,[In] unsigned int dwLODBias)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::SetDisplaceParam</unmanaged-short>	
        public void SetDisplaceParam(SharpDX.Direct3D9.BaseTexture texture, SharpDX.Direct3D9.TextureFilter minFilter, SharpDX.Direct3D9.TextureFilter magFilter, SharpDX.Direct3D9.TextureFilter mipFilter, SharpDX.Direct3D9.TextureAddress wrap, int dwLODBias) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((texture == null)?IntPtr.Zero:texture.NativePointer), unchecked((int)minFilter), unchecked((int)magFilter), unchecked((int)mipFilter), unchecked((int)wrap), dwLODBias,((void**)(*(void**)_nativePointer))[22]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets mesh geometry displacement parameters.</p>	
        /// </summary>	
        /// <param name="texture"><dd>  <p>Texture containing the displacement data.</p> </dd></param>	
        /// <param name="minFilter"><dd>  <p>Minification level. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p> </dd></param>	
        /// <param name="magFilter"><dd>  <p>Magnification level. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p> </dd></param>	
        /// <param name="mipFilter"><dd>  <p>Mip filter level. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureFilter"/></strong>.</p> </dd></param>	
        /// <param name="wrap"><dd>  <p>Texture address wrap mode. For more information, see <strong><see cref="SharpDX.Direct3D9.TextureAddress"/></strong>.</p> </dd></param>	
        /// <param name="dwLODBias"><dd>  <p>Level of detail bias value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Displacement maps can only be 2D textures. Mipmapping is ignored for nonadaptive tessellation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::GetDisplaceParam']/*"/>	
        /// <msdn-id>bb174081</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::GetDisplaceParam([Out] IDirect3DBaseTexture9** Texture,[Out] D3DTEXTUREFILTERTYPE* MinFilter,[Out] D3DTEXTUREFILTERTYPE* MagFilter,[Out] D3DTEXTUREFILTERTYPE* MipFilter,[Out] D3DTEXTUREADDRESS* Wrap,[Out] unsigned int* dwLODBias)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::GetDisplaceParam</unmanaged-short>	
        public void GetDisplaceParam(out SharpDX.Direct3D9.BaseTexture texture, out SharpDX.Direct3D9.TextureFilter minFilter, out SharpDX.Direct3D9.TextureFilter magFilter, out SharpDX.Direct3D9.TextureFilter mipFilter, out SharpDX.Direct3D9.TextureAddress wrap, out int dwLODBias) {
            unsafe {
                IntPtr texture_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* minFilter_ = &minFilter)
                    fixed (void* magFilter_ = &magFilter)
                        fixed (void* mipFilter_ = &mipFilter)
                            fixed (void* wrap_ = &wrap)
                                fixed (void* dwLODBias_ = &dwLODBias)
                                    __result__= 
                    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &texture_, minFilter_, magFilter_, mipFilter_, wrap_, dwLODBias_,((void**)(*(void**)_nativePointer))[23]);		
                texture= (texture_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.BaseTexture(texture_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Performs uniform tessellation based on the tessellation level.</p>	
        /// </summary>	
        /// <param name="fTessLevel"><dd>  <p>Tessellation level. This is the number of vertices introduced between existing vertices. The range of this float parameter is 0 &lt; fTessLevel &lt;= 32.</p> </dd></param>	
        /// <param name="meshRef"><dd>  <p>Resulting tessellated mesh. See <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function will perform more efficiently if the patch mesh has been optimized using <strong><see cref="SharpDX.Direct3D9.PatchMesh.Optimize"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::Tessellate']/*"/>	
        /// <msdn-id>bb174094</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::Tessellate([In] float fTessLevel,[In] ID3DXMesh* pMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::Tessellate</unmanaged-short>	
        public void Tessellate(float fTessLevel, SharpDX.Direct3D9.Mesh meshRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, fTessLevel, (void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer),((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Performs adaptive tessellation based on the z-based adaptive tessellation criterion.</p>	
        /// </summary>	
        /// <param name="transRef"><dd>  <p>Specifies a 4D vector that is dotted with the vertices to get the per-vertex adaptive tessellation amount. Each edge is tessellated to the average value of the tessellation levels for the two vertices it connects.</p> </dd></param>	
        /// <param name="dwMaxTessLevel"><dd>  <p>Maximum limit for adaptive tessellation. This is the number of vertices introduced between existing vertices. This integer value can range from 1 to 32, inclusive.</p> </dd></param>	
        /// <param name="dwMinTessLevel"><dd>  <p>Minimum limit for adaptive tessellation. This is the number of vertices introduced between existing vertices. This integer value can range from 1 to 32, inclusive.</p> </dd></param>	
        /// <param name="meshRef"><dd>  <p>Resulting tessellated mesh. See <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function will perform more efficiently if the patch mesh has been optimized using <strong><see cref="SharpDX.Direct3D9.PatchMesh.Optimize"/></strong>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPatchMesh::TessellateAdaptive']/*"/>	
        /// <msdn-id>bb174095</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPatchMesh::TessellateAdaptive([In] const D3DXVECTOR4* pTrans,[In] unsigned int dwMaxTessLevel,[In] unsigned int dwMinTessLevel,[In] ID3DXMesh* pMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXPatchMesh::TessellateAdaptive</unmanaged-short>	
        public void TessellateAdaptive(SharpDX.Mathematics.Interop.RawVector4 transRef, int dwMaxTessLevel, int dwMinTessLevel, SharpDX.Direct3D9.Mesh meshRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &transRef, dwMaxTessLevel, dwMinTessLevel, (void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer),((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.PixelShader"/> interface to encapsulate the functionality of a pixel shader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPDIRECT3DPIXELSHADER9 and PDIRECT3DPIXELSHADER9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.PixelShader"/></strong> interface. </p><pre>typedef struct <see cref="SharpDX.Direct3D9.PixelShader"/> *LPDIRECT3DPIXELSHADER9, *PDIRECT3DPIXELSHADER9;</pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DPixelShader9']/*"/>	
    /// <msdn-id>bb205869</msdn-id>	
    /// <unmanaged>IDirect3DPixelShader9</unmanaged>	
    /// <unmanaged-short>IDirect3DPixelShader9</unmanaged-short>	
    [Guid("6D3BDBDC-5B02-4415-B852-CE5E8BCCB289")]
    public partial class PixelShader : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.PixelShader"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public PixelShader(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.PixelShader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.PixelShader(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.PixelShader(nativePointer);
		}
        
        
        /// <summary>Constant MaxDynamicFlowControlDepth.</summary>
        /// <unmanaged>D3DPS20_MAX_DYNAMICFLOWCONTROLDEPTH</unmanaged>
        public const int MaxDynamicFlowControlDepth = 24;
        
        /// <summary>Constant MinDynamicFlowControlDepth.</summary>
        /// <unmanaged>D3DPS20_MIN_DYNAMICFLOWCONTROLDEPTH</unmanaged>
        public const int MinDynamicFlowControlDepth = 0;
        
        /// <summary>Constant MaxTemps.</summary>
        /// <unmanaged>D3DPS20_MAX_NUMTEMPS</unmanaged>
        public const int MaxTemps = 32;
        
        /// <summary>Constant MinTemps.</summary>
        /// <unmanaged>D3DPS20_MIN_NUMTEMPS</unmanaged>
        public const int MinTemps = 12;
        
        /// <summary>Constant MaxStaticFlowControlDepth.</summary>
        /// <unmanaged>D3DPS20_MAX_STATICFLOWCONTROLDEPTH</unmanaged>
        public const int MaxStaticFlowControlDepth = 4;
        
        /// <summary>Constant MinStaticFlowControlDepth.</summary>
        /// <unmanaged>D3DPS20_MIN_STATICFLOWCONTROLDEPTH</unmanaged>
        public const int MinStaticFlowControlDepth = 0;
        
        /// <summary>Constant MaxInstructionSlots.</summary>
        /// <unmanaged>D3DPS20_MAX_NUMINSTRUCTIONSLOTS</unmanaged>
        public const int MaxInstructionSlots = 512;
        
        /// <summary>Constant MinInstructionSlots.</summary>
        /// <unmanaged>D3DPS20_MIN_NUMINSTRUCTIONSLOTS</unmanaged>
        public const int MinInstructionSlots = 96;
        
        /// <summary>	
        /// <p>Gets the device.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DPixelShader9::GetDevice']/*"/>	
        /// <msdn-id>bb205870</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DPixelShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the device.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Pointer to the <see cref="SharpDX.Direct3D9.Device"/> interface that is returned.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DPixelShader9::GetDevice']/*"/>	
        /// <msdn-id>bb205870</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DPixelShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DPixelShader9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a reference to the shader data.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to a buffer that contains the shader data. The application needs to allocate enough room for this. </p> </dd></param>	
        /// <param name="sizeOfDataRef"><dd>  <p>Size of the data, in bytes. To get the buffer size that is needed to retrieve the data, set pData = <strong><c>null</c></strong> when calling GetFunction. Then call GetFunction with the returned size, to get the buffer data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DPixelShader9::GetFunction']/*"/>	
        /// <msdn-id>bb205871</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DPixelShader9::GetFunction([In] void* arg0,[InOut] unsigned int* pSizeOfData)</unmanaged>	
        /// <unmanaged-short>IDirect3DPixelShader9::GetFunction</unmanaged-short>	
        internal void GetFunction(System.IntPtr arg0, ref int sizeOfDataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0, sizeOfDataRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh']/*"/>	
    /// <msdn-id>bb280447</msdn-id>	
    /// <unmanaged>ID3DXPMesh</unmanaged>	
    /// <unmanaged-short>ID3DXPMesh</unmanaged-short>	
    [Guid("8875769a-d579-4088-aaeb-534d1ad84e96")]
    public partial class ProgressiveMesh : SharpDX.Direct3D9.BaseMesh {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.ProgressiveMesh"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public ProgressiveMesh(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.ProgressiveMesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.ProgressiveMesh(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.ProgressiveMesh(nativePointer);
		}
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMaxFaces']/*"/>	
        /// <unmanaged>GetMaxFaces</unmanaged>	
        /// <unmanaged-short>GetMaxFaces</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMaxFaces()</unmanaged>
        public int MaxFaces {
                get { return GetMaxFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMinFaces']/*"/>	
        /// <unmanaged>GetMinFaces</unmanaged>	
        /// <unmanaged-short>GetMinFaces</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMinFaces()</unmanaged>
        public int MinFaces {
                get { return GetMinFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMaxVertices']/*"/>	
        /// <unmanaged>GetMaxVertices</unmanaged>	
        /// <unmanaged-short>GetMaxVertices</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMaxVertices()</unmanaged>
        public int MaxVertices {
                get { return GetMaxVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMinVertices']/*"/>	
        /// <unmanaged>GetMinVertices</unmanaged>	
        /// <unmanaged-short>GetMinVertices</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMinVertices()</unmanaged>
        public int MinVertices {
                get { return GetMinVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetAdjacency']/*"/>	
        /// <unmanaged>GetAdjacency</unmanaged>	
        /// <unmanaged-short>GetAdjacency</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXPMesh::GetAdjacency([Out] unsigned int* pAdjacency)</unmanaged>
        public int Adjacency {
                get { int __output__; GetAdjacency(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="fvf">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="cloneMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::ClonePMeshFVF']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::ClonePMeshFVF([In] unsigned int Options,[In] unsigned int FVF,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXPMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::ClonePMeshFVF</unmanaged-short>	
        public void ClonePMeshFVF(int options, int fvf, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.ProgressiveMesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, fvf, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &cloneMeshOut_,((void**)(*(void**)_nativePointer))[24]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ProgressiveMesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="declarationRef">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="cloneMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::ClonePMesh']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::ClonePMesh([In] unsigned int Options,[In] const D3DVERTEXELEMENT9* pDeclaration,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXPMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::ClonePMesh</unmanaged-short>	
        public void ClonePMesh(int options, SharpDX.Direct3D9.VertexElement declarationRef, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.ProgressiveMesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, &declarationRef, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &cloneMeshOut_,((void**)(*(void**)_nativePointer))[25]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ProgressiveMesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="faces">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::SetNumFaces']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::SetNumFaces([In] unsigned int Faces)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::SetNumFaces</unmanaged-short>	
        internal void SetNumFaces(int faces) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, faces,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertices">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::SetNumVertices']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::SetNumVertices([In] unsigned int Vertices)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::SetNumVertices</unmanaged-short>	
        internal void SetNumVertices(int vertices) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, vertices,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMaxFaces']/*"/>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMaxFaces()</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::GetMaxFaces</unmanaged-short>	
        internal int GetMaxFaces() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[28]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMinFaces']/*"/>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMinFaces()</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::GetMinFaces</unmanaged-short>	
        internal int GetMinFaces() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[29]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMaxVertices']/*"/>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMaxVertices()</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::GetMaxVertices</unmanaged-short>	
        internal int GetMaxVertices() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[30]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetMinVertices']/*"/>	
        /// <unmanaged>unsigned int ID3DXPMesh::GetMinVertices()</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::GetMinVertices</unmanaged-short>	
        internal int GetMinVertices() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[31]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="streamRef">No documentation.</param>	
        /// <param name="materialsRef">No documentation.</param>	
        /// <param name="effectInstancesRef">No documentation.</param>	
        /// <param name="numMaterials">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::Save']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::Save([In] IStream* pStream,[In] const D3DXMATERIAL* pMaterials,[In] const D3DXEFFECTINSTANCE* pEffectInstances,[In] unsigned int NumMaterials)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::Save</unmanaged-short>	
        internal void Save_(System.IntPtr streamRef, ref SharpDX.Direct3D9.ExtendedMaterial materialsRef, SharpDX.Direct3D9.EffectInstance effectInstancesRef, int numMaterials) {
            unsafe {
                var materialsRef_ = new SharpDX.Direct3D9.ExtendedMaterial.__Native();
                materialsRef.__MarshalTo(ref materialsRef_);
                var effectInstancesRef_ = new SharpDX.Direct3D9.EffectInstance.__Native();
                effectInstancesRef.__MarshalTo(ref effectInstancesRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)streamRef, &materialsRef_, &effectInstancesRef_, numMaterials,((void**)(*(void**)_nativePointer))[32]);		
                materialsRef.__MarshalFree(ref materialsRef_);
                effectInstancesRef.__MarshalFree(ref effectInstancesRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generates a new mesh with reordered faces and vertices to optimize drawing performance.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Specifies the type of optimization to perform. This parameter can be set to a combination of one or more flags from <strong>D3DXMESHOPT</strong> and <strong>D3DXMESH</strong> (except <see cref="SharpDX.Direct3D9.MeshFlags.Use32Bit"/>, <see cref="SharpDX.Direct3D9.MeshFlags.IndexBufferWriteOnly"/>, and <see cref="SharpDX.Direct3D9.MeshFlags.WriteOnly"/>).</p> </dd></param>	
        /// <param name="adjacencyOutRef"><dd>  <p>Pointer to an array of three DWORDs per face that specifies the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff.</p> </dd></param>	
        /// <param name="faceRemapRef"><dd>  <p>An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is <strong><c>null</c></strong>, face remap data is not returned.</p> </dd></param>	
        /// <param name="vertexRemapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping.</p> </dd></param>	
        /// <param name="optMeshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the optimized mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method generates a new mesh. Before running Optimize, an application must generate an adjacency buffer by calling <strong><see cref="SharpDX.Direct3D9.BaseMesh.GenerateAdjacency"/></strong>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other.</p><p>This method is very similar to the <strong><see cref="SharpDX.Direct3D9.BaseMesh.CloneMesh"/></strong> method, except that it can perform optimization while generating the new clone of the mesh. The output mesh inherits all of the creation parameters of the input mesh.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::Optimize']/*"/>	
        /// <msdn-id>bb174071</msdn-id>	
        /// <unmanaged>HRESULT ID3DXPMesh::Optimize([In] unsigned int Flags,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pFaceRemap,[In] ID3DXBuffer** ppVertexRemap,[In] ID3DXMesh** ppOptMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::Optimize</unmanaged-short>	
        public void Optimize(int flags, int adjacencyOutRef, int faceRemapRef, out SharpDX.Direct3D.Blob vertexRemapOut, out SharpDX.Direct3D9.Mesh optMeshOut) {
            unsafe {
                IntPtr vertexRemapOut_ = IntPtr.Zero;
                IntPtr optMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, &adjacencyOutRef, &faceRemapRef, &vertexRemapOut_, &optMeshOut_,((void**)(*(void**)_nativePointer))[33]);		
                vertexRemapOut= (vertexRemapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapOut_);	
                optMeshOut= (optMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(optMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="faceRemapRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::OptimizeBaseLOD']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::OptimizeBaseLOD([In] unsigned int Flags,[In] unsigned int* pFaceRemap)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::OptimizeBaseLOD</unmanaged-short>	
        public void OptimizeBaseLOD(int flags, int faceRemapRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, flags, &faceRemapRef,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="newFacesMin">No documentation.</param>	
        /// <param name="newFacesMax">No documentation.</param>	
        /// <param name="rgiFaceRemap">No documentation.</param>	
        /// <param name="rgiVertRemap">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::TrimByFaces']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::TrimByFaces([In] unsigned int NewFacesMin,[In] unsigned int NewFacesMax,[In] unsigned int* rgiFaceRemap,[In] unsigned int* rgiVertRemap)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::TrimByFaces</unmanaged-short>	
        public void TrimByFaces(int newFacesMin, int newFacesMax, int rgiFaceRemap, int rgiVertRemap) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, newFacesMin, newFacesMax, &rgiFaceRemap, &rgiVertRemap,((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="newVerticesMin">No documentation.</param>	
        /// <param name="newVerticesMax">No documentation.</param>	
        /// <param name="rgiFaceRemap">No documentation.</param>	
        /// <param name="rgiVertRemap">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::TrimByVertices']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::TrimByVertices([In] unsigned int NewVerticesMin,[In] unsigned int NewVerticesMax,[In] unsigned int* rgiFaceRemap,[In] unsigned int* rgiVertRemap)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::TrimByVertices</unmanaged-short>	
        public void TrimByVertices(int newVerticesMin, int newVerticesMax, int rgiFaceRemap, int rgiVertRemap) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, newVerticesMin, newVerticesMax, &rgiFaceRemap, &rgiVertRemap,((void**)(*(void**)_nativePointer))[36]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="adjacencyRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GetAdjacency']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::GetAdjacency([Out] unsigned int* pAdjacency)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::GetAdjacency</unmanaged-short>	
        internal void GetAdjacency(out int adjacencyRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* adjacencyRef_ = &adjacencyRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, adjacencyRef_,((void**)(*(void**)_nativePointer))[37]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertexHistoryRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXPMesh::GenerateVertexHistory']/*"/>	
        /// <unmanaged>HRESULT ID3DXPMesh::GenerateVertexHistory([In] unsigned int* pVertexHistory)</unmanaged>	
        /// <unmanaged-short>ID3DXPMesh::GenerateVertexHistory</unmanaged-short>	
        public void GenerateVertexHistory(int vertexHistoryRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &vertexHistoryRef,((void**)(*(void**)_nativePointer))[38]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.Query"/> interface to perform asynchronous queries on a driver.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPDIRECT3DQUERY9 and PDIRECT3DQUERY9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Query"/></strong> interface. </p><pre>typedef struct <see cref="SharpDX.Direct3D9.Query"/> *LPDIRECT3DQUERY9, *PDIRECT3DQUERY9;</pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9']/*"/>	
    /// <msdn-id>bb205872</msdn-id>	
    /// <unmanaged>IDirect3DQuery9</unmanaged>	
    /// <unmanaged-short>IDirect3DQuery9</unmanaged-short>	
    [Guid("d9771460-a695-4f26-bbd3-27b840b541cc")]
    public partial class Query : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Query"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Query(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Query"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Query(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Query(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the device that is being queried.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9::GetDevice']/*"/>	
        /// <msdn-id>bb205875</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DQuery9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the number of bytes in the query data.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9::GetDataSize']/*"/>	
        /// <msdn-id>bb205874</msdn-id>	
        /// <unmanaged>GetDataSize</unmanaged>	
        /// <unmanaged-short>GetDataSize</unmanaged-short>	
        /// <unmanaged>unsigned int IDirect3DQuery9::GetDataSize()</unmanaged>
        public int DataSize {
                get { return GetDataSize(); }
        }
        
        /// <summary>	
        /// <p>Gets the device that is being queried.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Pointer to the device being queried. See <strong><see cref="SharpDX.Direct3D9.Device"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9::GetDevice']/*"/>	
        /// <msdn-id>bb205875</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DQuery9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DQuery9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the query type.</p>	
        /// </summary>	
        /// <returns><p>Returns the query type. See <strong><see cref="SharpDX.Direct3D9.QueryType"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9::GetType']/*"/>	
        /// <msdn-id>bb205876</msdn-id>	
        /// <unmanaged>D3DQUERYTYPE IDirect3DQuery9::GetType()</unmanaged>	
        /// <unmanaged-short>IDirect3DQuery9::GetType</unmanaged-short>	
        internal SharpDX.Direct3D9.QueryType GetTypeInfo() {
            unsafe {
                SharpDX.Direct3D9.QueryType __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXDirect3D9QueryType(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of bytes in the query data.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of bytes of query data.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9::GetDataSize']/*"/>	
        /// <msdn-id>bb205874</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DQuery9::GetDataSize()</unmanaged>	
        /// <unmanaged-short>IDirect3DQuery9::GetDataSize</unmanaged-short>	
        internal int GetDataSize() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Issue a query.</p>	
        /// </summary>	
        /// <param name="dwIssueFlags"><dd>  <p>Query flags specify the type of state change for the query. See <strong><see cref="SharpDX.Direct3D9.Issue.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D9.Issue.End"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>A signaled query means the query has completed, the data is available, and <strong><see cref="SharpDX.Direct3D9.Query.GetData"/></strong> will return <see cref="SharpDX.Result.Ok"/>. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9::Issue']/*"/>	
        /// <msdn-id>bb205877</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DQuery9::Issue([In] D3DISSUE dwIssueFlags)</unmanaged>	
        /// <unmanaged-short>IDirect3DQuery9::Issue</unmanaged-short>	
        public void Issue(SharpDX.Direct3D9.Issue dwIssueFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)dwIssueFlags),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Polls a queried resource to get the query state or a query result. For more information about queries, see Queries (Direct3D 9).</p>	
        /// </summary>	
        /// <param name="dataRef">No documentation.</param>	
        /// <param name="dwSize">No documentation.</param>	
        /// <param name="dwGetDataFlags">No documentation.</param>	
        /// <returns><p>The return type identifies the query state (see Queries (Direct3D 9)). The method returns <see cref="SharpDX.Result.Ok"/> if the query data is available and S_FALSE if it is not.  These are considered successful return values. If the method fails when <strong>D3DGETDATA_FLUSH</strong> is used, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>. </p></returns>	
        /// <remarks>	
        /// <p>It is possible to lose the device while polling for query status. When <strong>D3DGETDATA_FLUSH</strong> is specified, this method will return <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/> in response to a lost device. This allows an application to prevent threads from endlessly polling due to a lost device (which cannot respond to the query).</p><p>An application must never write code that only invokes GetData ( ... , 0 ), expecting that GetData will eventually return <see cref="SharpDX.Result.Ok"/> by itself over time. This is true, even if the application has used the FLUSH flag with GetData in the past. For example:</p><pre>// Enables an infinite loop:	
        /// while( pQuery-&gt;GetData( ... , 0 ) == S_FALSE ) ; // Still enables an infinite loop:	
        /// pQuery-&gt;GetData( ... , D3DGETDATA_FLUSH );	
        /// while( pQuery-&gt;GetData( ... , 0 ) == S_FALSE ) ; // Does not enable an infinite loop because eventually the command	
        /// // buffer will fill up and that will cause a flush to occur.	
        /// while( pQuery-&gt;GetData( ..., 0 ) == S_FALSE ) { pDevice-&gt;SetTexture(...); pDevice-&gt;Draw(...);	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DQuery9::GetData']/*"/>	
        /// <msdn-id>bb205873</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DQuery9::GetData([In] void* pData,[In] unsigned int dwSize,[In] unsigned int dwGetDataFlags)</unmanaged>	
        /// <unmanaged-short>IDirect3DQuery9::GetData</unmanaged-short>	
        internal SharpDX.Result GetData(System.IntPtr dataRef, int dwSize, int dwGetDataFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)dataRef, dwSize, dwGetDataFlags,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/> interface is used to generalize the process of rendering to environment maps.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An environment map is used to texture-map scene geometry to provide a more sophisticated scene without using complex geometry. This interface supports creating surfaces for the following kinds of geometry: cube, half sphere or hemispheric, parabolic, or sphere.</p><p>The <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateRenderToEnvMap"/></strong> function.</p><p>The LPD3DXRenderToEnvMap type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/></strong> interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/> <see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/> *LPD3DXRenderToEnvMap;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap']/*"/>	
    /// <msdn-id>bb174181</msdn-id>	
    /// <unmanaged>ID3DXRenderToEnvMap</unmanaged>	
    /// <unmanaged-short>ID3DXRenderToEnvMap</unmanaged-short>	
    [Guid("313f1b4b-c7b0-4fa2-9d9d-8d380b64385e")]
    public partial class RenderToEnvironmentMap : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RenderToEnvironmentMap(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.RenderToEnvironmentMap(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.RenderToEnvironmentMap(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the environment map.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::GetDevice']/*"/>	
        /// <msdn-id>bb174189</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the description of the render surface.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::GetDesc']/*"/>	
        /// <msdn-id>bb174188</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDesc([Out] D3DXRTE_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.RenderToEnvironmentMapDescription Description {
                get { SharpDX.Direct3D9.RenderToEnvironmentMapDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the environment map.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface that represents the Direct3D device object associated with the environment map.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. Calling this method increases the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call <strong><see cref="SharpDX.ComObject"/></strong> when you are done using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::GetDevice']/*"/>	
        /// <msdn-id>bb174189</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the description of the render surface.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMapDescription"/></strong> structure that describes the rendering surface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::GetDesc']/*"/>	
        /// <msdn-id>bb174188</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::GetDesc([Out] D3DXRTE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.RenderToEnvironmentMapDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D9.RenderToEnvironmentMapDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initiate the rendering of a cubic environment map.</p>	
        /// </summary>	
        /// <param name="cubeTexRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface that represents the cube texture to which to render.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>See <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap.Face"/></strong> to draw each of the 6 faces.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::BeginCube']/*"/>	
        /// <msdn-id>bb174182</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginCube([In] IDirect3DCubeTexture9* pCubeTex)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::BeginCube</unmanaged-short>	
        public void BeginCube(SharpDX.Direct3D9.CubeTexture cubeTexRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((cubeTexRef == null)?IntPtr.Zero:cubeTexRef.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initiate the rendering of a spherical environment map.</p>	
        /// </summary>	
        /// <param name="texRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface that represents the texture to which to render.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.E_FAIL</p></returns>	
        /// <remarks>	
        /// <p>See <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap.Face"/></strong> to draw the face.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::BeginSphere']/*"/>	
        /// <msdn-id>bb174185</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginSphere([In] IDirect3DTexture9* pTex)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::BeginSphere</unmanaged-short>	
        public void BeginSphere(SharpDX.Direct3D9.Texture texRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((texRef == null)?IntPtr.Zero:texRef.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initiate the rendering of a hemispheric environment map.</p>	
        /// </summary>	
        /// <param name="texZPosRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface that represents the positive texture render surface.</p> </dd></param>	
        /// <param name="texZNegRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface that represents the negative texture render surface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.E_FAIL</p></returns>	
        /// <remarks>	
        /// <p>See <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap.Face"/></strong> to draw the face.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::BeginHemisphere']/*"/>	
        /// <msdn-id>bb174183</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginHemisphere([In] IDirect3DTexture9* pTexZPos,[In] IDirect3DTexture9* pTexZNeg)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::BeginHemisphere</unmanaged-short>	
        public void BeginHemisphere(SharpDX.Direct3D9.Texture texZPosRef, SharpDX.Direct3D9.Texture texZNegRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((texZPosRef == null)?IntPtr.Zero:texZPosRef.NativePointer), (void*)((texZNegRef == null)?IntPtr.Zero:texZNegRef.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initiate the rendering of a parabolic environment map.</p>	
        /// </summary>	
        /// <param name="texZPosRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface that represents the positive render texture.</p> </dd></param>	
        /// <param name="texZNegRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface that represents the negative render texture.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.E_FAIL</p></returns>	
        /// <remarks>	
        /// <p>See <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap.Face"/></strong> to draw the faces.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::BeginParabolic']/*"/>	
        /// <msdn-id>bb174184</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::BeginParabolic([In] IDirect3DTexture9* pTexZPos,[In] IDirect3DTexture9* pTexZNeg)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::BeginParabolic</unmanaged-short>	
        public void BeginParabolic(SharpDX.Direct3D9.Texture texZPosRef, SharpDX.Direct3D9.Texture texZNegRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((texZPosRef == null)?IntPtr.Zero:texZPosRef.NativePointer), (void*)((texZNegRef == null)?IntPtr.Zero:texZNegRef.NativePointer),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Initiate the drawing of each face of an environment map.</p>	
        /// </summary>	
        /// <param name="face"><dd>  <p>The first face of the environmental cube map. See <strong><see cref="SharpDX.Direct3D9.CubeMapFace"/></strong>.</p> </dd></param>	
        /// <param name="mipFilter"><dd>  <p>A valid combination of one or more <see cref="SharpDX.Direct3D9.Filter"/> flags.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method must be called once for each type of environment map. The only exception is a cubic environment map which requires this method to be called six times, once for each face in <see cref="SharpDX.Direct3D9.CubeMapFace"/>. For more information, see Environment Mapping (Direct3D 9). </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::Face']/*"/>	
        /// <msdn-id>bb174187</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::Face([In] D3DCUBEMAP_FACES Face,[In] unsigned int MipFilter)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::Face</unmanaged-short>	
        public void Face(SharpDX.Direct3D9.CubeMapFace face, int mipFilter) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)face), mipFilter,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Restore all render targets and, if needed, compose all the rendered faces into the environment map surface.</p>	
        /// </summary>	
        /// <param name="mipFilter"><dd>  <p>A valid combination of one or more <see cref="SharpDX.Direct3D9.Filter"/> flags.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::End']/*"/>	
        /// <msdn-id>bb174186</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::End([In] unsigned int MipFilter)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::End</unmanaged-short>	
        public void End(int mipFilter) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, mipFilter,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost, or before resetting a device.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method should be called whenever the device is lost or before the user calls <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>. Even if the device was not actually lost, <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap.OnLostDevice"/></strong> is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> and then <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap.OnResetDevice"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::OnLostDevice']/*"/>	
        /// <msdn-id>bb174190</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::OnLostDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::OnLostDevice</unmanaged-short>	
        public void OnLostDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to re-acquire resources and save initial state.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap.OnResetDevice"/></strong> should be called each time the device is reset (using <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToEnvMap::OnResetDevice']/*"/>	
        /// <msdn-id>bb174191</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToEnvMap::OnResetDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToEnvMap::OnResetDevice</unmanaged-short>	
        public void OnResetDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D9.RenderToSurface"/> interface is used to generalize the process of rendering to surfaces.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Surfaces can be used in a variety of ways including render targets, off-screen rendering, or rendering to textures.</p><p>A surface can be configured using a separate viewport using the <strong><see cref="SharpDX.Direct3D9.RenderToSurface.BeginScene"/></strong> method, to provide a custom render view. If the surface is not a render target, a compatible render target is used, and the result is copied to the surface at the end of the scene.</p><p>The <strong><see cref="SharpDX.Direct3D9.RenderToSurface"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateRenderToSurface"/></strong> function.</p><p>The LPD3DXRENDERTOSURFACE type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.RenderToSurface"/></strong> interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.RenderToSurface"/> <see cref="SharpDX.Direct3D9.RenderToSurface"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.RenderToSurface"/> *LPD3DXRENDERTOSURFACE;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface']/*"/>	
    /// <msdn-id>bb174192</msdn-id>	
    /// <unmanaged>ID3DXRenderToSurface</unmanaged>	
    /// <unmanaged-short>ID3DXRenderToSurface</unmanaged-short>	
    [Guid("6985f346-2c3d-43b3-be8b-daae8a03d894")]
    public partial class RenderToSurface : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.RenderToSurface"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public RenderToSurface(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.RenderToSurface"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.RenderToSurface(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.RenderToSurface(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the render surface.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::GetDevice']/*"/>	
        /// <msdn-id>bb174196</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the parameters of the render surface.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::GetDesc']/*"/>	
        /// <msdn-id>bb174195</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDesc([Out] D3DXRTS_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.RenderToSurfaceDescription Description {
                get { SharpDX.Direct3D9.RenderToSurfaceDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the Direct3D device associated with the render surface.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the Direct3D device object associated with the render surface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Be sure to call <strong><see cref="SharpDX.ComObject"/></strong> when you are done using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface or you will have a memory leak.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::GetDevice']/*"/>	
        /// <msdn-id>bb174196</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToSurface::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the parameters of the render surface.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.RenderToSurfaceDescription"/></strong> structure, describing the parameters of the render surface.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::GetDesc']/*"/>	
        /// <msdn-id>bb174195</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::GetDesc([Out] D3DXRTS_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToSurface::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.RenderToSurfaceDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D9.RenderToSurfaceDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Begins a scene.</p>	
        /// </summary>	
        /// <param name="surfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the render surface.</p> </dd></param>	
        /// <param name="viewportRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawViewport"/></strong> structure, describing the viewport for the scene.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.<see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/> D3DXERR_INVALIDDATA E_OUTOFMEMORY</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::BeginScene']/*"/>	
        /// <msdn-id>bb174193</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::BeginScene([In] IDirect3DSurface9* pSurface,[In] const D3DVIEWPORT9* pViewport)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToSurface::BeginScene</unmanaged-short>	
        public void BeginScene(SharpDX.Direct3D9.Surface surfaceRef, SharpDX.Mathematics.Interop.RawViewport viewportRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((surfaceRef == null)?IntPtr.Zero:surfaceRef.NativePointer), &viewportRef,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Ends a scene.</p>	
        /// </summary>	
        /// <param name="mipFilter"><dd>  <p>Filter options, enumerated in <see cref="SharpDX.Direct3D9.Filter"/>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::EndScene']/*"/>	
        /// <msdn-id>bb174194</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::EndScene([In] D3DX_FILTER MipFilter)</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToSurface::EndScene</unmanaged-short>	
        public void EndScene(SharpDX.Direct3D9.Filter mipFilter) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)mipFilter),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost or before resetting a device.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method should be called whenever the device is lost or before the user calls <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>. Even if the device was not actually lost, <see cref="SharpDX.Direct3D9.RenderToSurface.OnLostDevice"/> is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> and then <see cref="SharpDX.Direct3D9.RenderToSurface.OnResetDevice"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::OnLostDevice']/*"/>	
        /// <msdn-id>bb174197</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::OnLostDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToSurface::OnLostDevice</unmanaged-short>	
        public void OnLostDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to re-acquire resources and save initial state.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><see cref="SharpDX.Direct3D9.RenderToSurface.OnResetDevice"/> should be called each time the device is reset (using <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXRenderToSurface::OnResetDevice']/*"/>	
        /// <msdn-id>bb174198</msdn-id>	
        /// <unmanaged>HRESULT ID3DXRenderToSurface::OnResetDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXRenderToSurface::OnResetDevice</unmanaged-short>	
        public void OnResetDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> interface to query and prepare resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create a texture resource, you can call one of the following methods.</p><ul> <li> <strong><see cref="SharpDX.Direct3D9.Device.CreateCubeTexture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.CreateTexture"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.CreateVolumeTexture"/></strong> </li> </ul><p>To create a geometry-oriented resource, you can call one of the following methods.</p><ul> <li> <strong><see cref="SharpDX.Direct3D9.Device.CreateIndexBuffer"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D9.Device.CreateVertexBuffer"/></strong> </li> </ul><p>This interface, like all COM interfaces, inherits from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPDIRECT3DRESOURCE9 and PDIRECT3DRESOURCE9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> interface.  </p><pre> typedef struct <see cref="SharpDX.Direct3D9.Resource"/> *LPDIRECT3DRESOURCE9, *PDIRECT3DRESOURCE9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9']/*"/>	
    /// <msdn-id>bb205878</msdn-id>	
    /// <unmanaged>IDirect3DResource9</unmanaged>	
    /// <unmanaged-short>IDirect3DResource9</unmanaged-short>	
    [Guid("05EEC05D-8F7D-4362-B999-D1BAF357C704")]
    public partial class Resource : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Resource"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Resource(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Resource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Resource(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Resource(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the device associated with a resource.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method allows navigation to the owning device object.</p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::GetDevice']/*"/>	
        /// <msdn-id>bb205880</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DResource9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { if (Device__ == null)  GetDevice(out Device__); return Device__; }
        }
			protected internal SharpDX.Direct3D9.Device Device__;
        
        /// <summary>	
        /// <p>Retrieves the priority for this resource.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Resource.GetPriority"/></strong> is used for priority control of managed resources. This method returns 0 on nonmanaged resources.</p><p>Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::GetPriority']/*"/>	
        /// <msdn-id>bb205881</msdn-id>	
        /// <unmanaged>GetPriority</unmanaged>	
        /// <unmanaged-short>GetPriority</unmanaged-short>	
        /// <unmanaged>unsigned int IDirect3DResource9::GetPriority()</unmanaged>
        public int Priority {
                get { return GetPriority(); }
        }
        
        /// <summary>	
        /// <p>Returns the type of the resource.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::GetType']/*"/>	
        /// <msdn-id>bb205883</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>D3DRESOURCETYPE IDirect3DResource9::GetType()</unmanaged>
        public SharpDX.Direct3D9.ResourceType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with a resource.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface to fill with the device reference, if the query succeeds. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method allows navigation to the owning device object.</p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::GetDevice']/*"/>	
        /// <msdn-id>bb205880</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DResource9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Associates data with the resource that is intended for use by the application, not by Direct3D. Data is passed by value, and multiple sets of data can be associated with a single resource.</p>	
        /// </summary>	
        /// <param name="refguid"><dd>  <p>Reference to the globally unique identifier that identifies the private data to set.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to a buffer that contains the data to be associated with the resource. </p> </dd></param>	
        /// <param name="sizeOfData"><dd>  <p>Size of the buffer at pData, in bytes. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Value that describes the type of data being passed, or indicates to the application that the data should be invalidated when the resource changes. </p> <p></p> <table> <tr><th>Item</th><th>Description</th></tr> <tr><td> <p>(none)</p> </td><td> <p>If no flags are specified, Direct3D allocates memory to hold the data within the buffer and copies the data into the new buffer. The buffer allocated by Direct3D is automatically freed, as appropriate.</p> </td></tr> <tr><td> <p>D3DSPD_IUNKNOWN</p> </td><td> <p>The data at pData is a reference to an <strong><see cref="SharpDX.ComObject"/></strong> interface. SizeOfData must be set to the size of a reference to <see cref="SharpDX.ComObject"/>, that is, sizeof(<see cref="SharpDX.ComObject"/>*). Direct3D automatically callsIUnknown through pData when the private data is destroyed. Private data will be destroyed by a subsequent call to <strong><see cref="SharpDX.Direct3D9.Resource.SetPrivateData"/></strong> with the same <see cref="System.Guid"/>, a subsequent call to <strong><see cref="SharpDX.Direct3D9.Resource.FreePrivateData"/></strong>, or when the <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> object is released. For more information, see Remarks.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Direct3D does not manage the memory at pData. If this buffer was dynamically allocated, it is the calling application's responsibility to free the memory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::SetPrivateData']/*"/>	
        /// <msdn-id>bb205886</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DResource9::SetPrivateData([In] const GUID&amp; refguid,[In] const void* pData,[In] unsigned int SizeOfData,[In] unsigned int Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::SetPrivateData</unmanaged-short>	
        public void SetPrivateData(System.Guid refguid, System.IntPtr dataRef, int sizeOfData, int flags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &refguid, (void*)dataRef, sizeOfData, flags,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Copies the private data associated with the resource to a provided buffer.</p>	
        /// </summary>	
        /// <param name="refguid"><dd>  <p>The globally unique identifier that identifies the private data to retrieve. </p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to a previously allocated buffer to fill with the requested private data if the call succeeds. The application calling this method is responsible for allocating and releasing this buffer. If this parameter is <strong><c>null</c></strong>, this method will return the buffer size in pSizeOfData.</p> </dd></param>	
        /// <param name="sizeOfDataRef"><dd>  <p>Pointer to the size of the buffer at  pData, in bytes. If this value is less than the actual size of the private data (such as 0), the method sets this parameter to the required buffer size and the method returns <see cref="SharpDX.Direct3D9.ResultCode.MoreData"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.MoreData"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotFound"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method is inherited by the following interfaces:  <strong><see cref="SharpDX.Direct3D9.Resource"/></strong>,  <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong>, <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong>,  <strong><see cref="SharpDX.Direct3D9.Texture"/></strong>,  <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong>, <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong>,  <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::GetPrivateData']/*"/>	
        /// <msdn-id>bb205882</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DResource9::GetPrivateData([In] const GUID&amp; refguid,[In] void* pData,[InOut] unsigned int* pSizeOfData)</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::GetPrivateData</unmanaged-short>	
        public SharpDX.Result GetPrivateData(System.Guid refguid, System.IntPtr dataRef, ref int sizeOfDataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &refguid, (void*)dataRef, sizeOfDataRef_,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Frees the specified private data associated with this resource.</p>	
        /// </summary>	
        /// <param name="refguid"><dd>  <p>Reference to the globally unique identifier that identifies the private data to free.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotFound"/>.</p></returns>	
        /// <remarks>	
        /// <p>Direct3D calls this method automatically when a resource is released.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::FreePrivateData']/*"/>	
        /// <msdn-id>bb205879</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DResource9::FreePrivateData([In] const GUID&amp; refguid)</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::FreePrivateData</unmanaged-short>	
        public void FreePrivateData(System.Guid refguid) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &refguid,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Assigns the priority of a resource for scheduling purposes.</p>	
        /// </summary>	
        /// <param name="priorityNew"><dd>  <p>Priority to assign to a resource. </p> <table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 9 for Windows Vista</p> <p>The priority can be any DWORD value; Direct3D 9 for Windows Vista also supports any of these pre-defined values <strong>D3D9_RESOURCE_PRIORITY</strong>.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>Returns the previous priority value for the resource.</p></returns>	
        /// <remarks>	
        /// <p>This method is used to change the priority of managed resources (resources created with the <strong><see cref="SharpDX.Direct3D9.Pool.Managed"/></strong> flag). This method returns 0 on non-managed resources.</p><p>Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0.</p><p> Windows Vista only - When this method is called using an <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> interface, only resources created with the <strong><see cref="SharpDX.Direct3D9.Pool.Default"/></strong> flag will be affected.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::SetPriority']/*"/>	
        /// <msdn-id>bb205885</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DResource9::SetPriority([In] unsigned int PriorityNew)</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::SetPriority</unmanaged-short>	
        public int SetPriority(int priorityNew) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, priorityNew,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the priority for this resource.</p>	
        /// </summary>	
        /// <returns><p>Returns a DWORD value, indicating the priority of the resource.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Resource.GetPriority"/></strong> is used for priority control of managed resources. This method returns 0 on nonmanaged resources.</p><p>Priorities are used to determine when managed resources are to be removed from memory. A resource assigned a low priority is removed before a resource with a high priority. If two resources have the same priority, the resource that was used more recently is kept in memory; the other resource is removed. Managed resources have a default priority of 0.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::GetPriority']/*"/>	
        /// <msdn-id>bb205881</msdn-id>	
        /// <unmanaged>unsigned int IDirect3DResource9::GetPriority()</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::GetPriority</unmanaged-short>	
        internal int GetPriority() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Preloads a managed resource.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method indicates that the application will need this managed resource shortly. This method has no effect on nonmanaged resources.</p><p><strong><see cref="SharpDX.Direct3D9.Resource.PreLoad"/></strong> detects "thrashing" conditions where more resources are being used in each frame than can fit in video memory simultaneously. Under such circumstances <strong><see cref="SharpDX.Direct3D9.Resource.PreLoad"/></strong> silently does nothing.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::PreLoad']/*"/>	
        /// <msdn-id>bb205884</msdn-id>	
        /// <unmanaged>void IDirect3DResource9::PreLoad()</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::PreLoad</unmanaged-short>	
        public void PreLoad() {
            unsafe {
                SharpDX.Direct3D9.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
            }
        }
        
        /// <summary>	
        /// <p>Returns the type of the resource.</p>	
        /// </summary>	
        /// <returns><p>Returns a member of the <strong><see cref="SharpDX.Direct3D9.ResourceType"/></strong> enumerated type, identifying the type of the resource.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DResource9::GetType']/*"/>	
        /// <msdn-id>bb205883</msdn-id>	
        /// <unmanaged>D3DRESOURCETYPE IDirect3DResource9::GetType()</unmanaged>	
        /// <unmanaged-short>IDirect3DResource9::GetType</unmanaged-short>	
        internal SharpDX.Direct3D9.ResourceType GetTypeInfo() {
            unsafe {
                SharpDX.Direct3D9.ResourceType __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXDirect3D9ResourceType(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh']/*"/>	
    /// <msdn-id>bb280438</msdn-id>	
    /// <unmanaged>ID3DXSPMesh</unmanaged>	
    /// <unmanaged-short>ID3DXSPMesh</unmanaged-short>	
    [Guid("667ea4c7-f1cd-4386-b523-7c0290b83cc5")]
    public partial class SimplificationMesh : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.SimplificationMesh"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SimplificationMesh(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.SimplificationMesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.SimplificationMesh(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.SimplificationMesh(nativePointer);
		}
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetNumFaces']/*"/>	
        /// <unmanaged>GetNumFaces</unmanaged>	
        /// <unmanaged-short>GetNumFaces</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetNumFaces()</unmanaged>
        public int NumFaces {
                get { return GetNumFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetNumVertices']/*"/>	
        /// <unmanaged>GetNumVertices</unmanaged>	
        /// <unmanaged-short>GetNumVertices</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetNumVertices()</unmanaged>
        public int NumVertices {
                get { return GetNumVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetFVF']/*"/>	
        /// <unmanaged>GetFVF</unmanaged>	
        /// <unmanaged-short>GetFVF</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetOptions']/*"/>	
        /// <unmanaged>GetOptions</unmanaged>	
        /// <unmanaged-short>GetOptions</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetOptions()</unmanaged>
        public int Options {
                get { return GetOptions(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetDevice']/*"/>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetMaxFaces']/*"/>	
        /// <unmanaged>GetMaxFaces</unmanaged>	
        /// <unmanaged-short>GetMaxFaces</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetMaxFaces()</unmanaged>
        public int MaxFaces {
                get { return GetMaxFaces(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetMaxVertices']/*"/>	
        /// <unmanaged>GetMaxVertices</unmanaged>	
        /// <unmanaged-short>GetMaxVertices</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetMaxVertices()</unmanaged>
        public int MaxVertices {
                get { return GetMaxVertices(); }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetVertexWeights']/*"/>	
        /// <unmanaged>GetVertexWeights</unmanaged>	
        /// <unmanaged-short>GetVertexWeights</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetVertexWeights([Out] float* pVertexWeights)</unmanaged>
        public float VertexWeights {
                get { float __output__; GetVertexWeights(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetNumFaces']/*"/>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetNumFaces()</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetNumFaces</unmanaged-short>	
        internal int GetNumFaces() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetNumVertices']/*"/>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetNumVertices()</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetNumVertices</unmanaged-short>	
        internal int GetNumVertices() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetFVF']/*"/>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetFVF()</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetFVF</unmanaged-short>	
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="declaration">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetDeclaration']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetDeclaration([In] D3DVERTEXELEMENT9* Declaration)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetDeclaration</unmanaged-short>	
        public void GetDeclaration(SharpDX.Direct3D9.VertexElement declaration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &declaration,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetOptions']/*"/>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetOptions()</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetOptions</unmanaged-short>	
        internal int GetOptions() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="deviceOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetDevice']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[8]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="fvf">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="adjacencyOutRef">No documentation.</param>	
        /// <param name="vertexRemapOutRef">No documentation.</param>	
        /// <param name="cloneMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::CloneMeshFVF']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::CloneMeshFVF([In] unsigned int Options,[In] unsigned int FVF,[In] IDirect3DDevice9* pD3DDevice,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pVertexRemapOut,[In] ID3DXMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::CloneMeshFVF</unmanaged-short>	
        public void CloneMeshFVF(int options, int fvf, SharpDX.Direct3D9.Device d3DDeviceRef, int adjacencyOutRef, int vertexRemapOutRef, out SharpDX.Direct3D9.Mesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, fvf, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &adjacencyOutRef, &vertexRemapOutRef, &cloneMeshOut_,((void**)(*(void**)_nativePointer))[9]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="declarationRef">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="adjacencyOutRef">No documentation.</param>	
        /// <param name="vertexRemapOutRef">No documentation.</param>	
        /// <param name="cloneMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::CloneMesh']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::CloneMesh([In] unsigned int Options,[In] const D3DVERTEXELEMENT9* pDeclaration,[In] IDirect3DDevice9* pD3DDevice,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pVertexRemapOut,[In] ID3DXMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::CloneMesh</unmanaged-short>	
        public void CloneMesh(int options, SharpDX.Direct3D9.VertexElement declarationRef, SharpDX.Direct3D9.Device d3DDeviceRef, int adjacencyOutRef, int vertexRemapOutRef, out SharpDX.Direct3D9.Mesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, &declarationRef, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &adjacencyOutRef, &vertexRemapOutRef, &cloneMeshOut_,((void**)(*(void**)_nativePointer))[10]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="fvf">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="vertexRemapOutRef">No documentation.</param>	
        /// <param name="errorsByFaceRef">No documentation.</param>	
        /// <param name="cloneMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::ClonePMeshFVF']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::ClonePMeshFVF([In] unsigned int Options,[In] unsigned int FVF,[In] IDirect3DDevice9* pD3DDevice,[In] unsigned int* pVertexRemapOut,[In] float* pErrorsByFace,[In] ID3DXPMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::ClonePMeshFVF</unmanaged-short>	
        public void ClonePMeshFVF(int options, int fvf, SharpDX.Direct3D9.Device d3DDeviceRef, int vertexRemapOutRef, float errorsByFaceRef, out SharpDX.Direct3D9.ProgressiveMesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, fvf, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &vertexRemapOutRef, &errorsByFaceRef, &cloneMeshOut_,((void**)(*(void**)_nativePointer))[11]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ProgressiveMesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="options">No documentation.</param>	
        /// <param name="declarationRef">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="vertexRemapOutRef">No documentation.</param>	
        /// <param name="errorsbyFaceRef">No documentation.</param>	
        /// <param name="cloneMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::ClonePMesh']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::ClonePMesh([In] unsigned int Options,[In] const D3DVERTEXELEMENT9* pDeclaration,[In] IDirect3DDevice9* pD3DDevice,[In] unsigned int* pVertexRemapOut,[In] float* pErrorsbyFace,[In] ID3DXPMesh** ppCloneMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::ClonePMesh</unmanaged-short>	
        public void ClonePMesh(int options, SharpDX.Direct3D9.VertexElement declarationRef, SharpDX.Direct3D9.Device d3DDeviceRef, int vertexRemapOutRef, float errorsbyFaceRef, out SharpDX.Direct3D9.ProgressiveMesh cloneMeshOut) {
            unsafe {
                IntPtr cloneMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, options, &declarationRef, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &vertexRemapOutRef, &errorsbyFaceRef, &cloneMeshOut_,((void**)(*(void**)_nativePointer))[12]);		
                cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ProgressiveMesh(cloneMeshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="faces">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::ReduceFaces']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::ReduceFaces([In] unsigned int Faces)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::ReduceFaces</unmanaged-short>	
        public void ReduceFaces(int faces) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, faces,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertices">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::ReduceVertices']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::ReduceVertices([In] unsigned int Vertices)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::ReduceVertices</unmanaged-short>	
        public void ReduceVertices(int vertices) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, vertices,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetMaxFaces']/*"/>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetMaxFaces()</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetMaxFaces</unmanaged-short>	
        internal int GetMaxFaces() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetMaxVertices']/*"/>	
        /// <unmanaged>unsigned int ID3DXSPMesh::GetMaxVertices()</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetMaxVertices</unmanaged-short>	
        internal int GetMaxVertices() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertexAttributeWeightsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetVertexAttributeWeights']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetVertexAttributeWeights([In] D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetVertexAttributeWeights</unmanaged-short>	
        public void GetVertexAttributeWeights(ref SharpDX.Direct3D9.AttributeWeights vertexAttributeWeightsRef) {
            unsafe {
                var vertexAttributeWeightsRef_ = new SharpDX.Direct3D9.AttributeWeights.__Native();
                vertexAttributeWeightsRef.__MarshalTo(ref vertexAttributeWeightsRef_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &vertexAttributeWeightsRef_,((void**)(*(void**)_nativePointer))[17]);		
                vertexAttributeWeightsRef.__MarshalFree(ref vertexAttributeWeightsRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="vertexWeightsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSPMesh::GetVertexWeights']/*"/>	
        /// <unmanaged>HRESULT ID3DXSPMesh::GetVertexWeights([Out] float* pVertexWeights)</unmanaged>	
        /// <unmanaged-short>ID3DXSPMesh::GetVertexWeights</unmanaged-short>	
        internal void GetVertexWeights(out float vertexWeightsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* vertexWeightsRef_ = &vertexWeightsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, vertexWeightsRef_,((void**)(*(void**)_nativePointer))[18]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// No documentation.	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo']/*"/>	
    /// <msdn-id>bb280439</msdn-id>	
    /// <unmanaged>ID3DXSkinInfo</unmanaged>	
    /// <unmanaged-short>ID3DXSkinInfo</unmanaged-short>	
    [Guid("11eaa540-f9a6-4d49-ae6a-e19221f70cc4")]
    public partial class SkinInfo : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.SkinInfo"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SkinInfo(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.SkinInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.SkinInfo(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.SkinInfo(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the maximum number of influences for any vertex in the mesh.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetMaxVertexInfluences']/*"/>	
        /// <msdn-id>bb174218</msdn-id>	
        /// <unmanaged>GetMaxVertexInfluences</unmanaged>	
        /// <unmanaged-short>GetMaxVertexInfluences</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetMaxVertexInfluences([Out] unsigned int* maxVertexInfluences)</unmanaged>
        public int MaxVertexInfluences {
                get { int __output__; GetMaxVertexInfluences(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the number of bones.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetNumBones']/*"/>	
        /// <msdn-id>bb174221</msdn-id>	
        /// <unmanaged>GetNumBones</unmanaged>	
        /// <unmanaged-short>GetNumBones</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSkinInfo::GetNumBones()</unmanaged>
        public int NumBones {
                get { return GetNumBones(); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the minimum bone influence. Influence values smaller than this are ignored.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetMinBoneInfluence']/*"/>	
        /// <msdn-id>bb174219</msdn-id>	
        /// <unmanaged>GetMinBoneInfluence / SetMinBoneInfluence</unmanaged>	
        /// <unmanaged-short>GetMinBoneInfluence</unmanaged-short>	
        /// <unmanaged>float ID3DXSkinInfo::GetMinBoneInfluence()</unmanaged>
        public float MinBoneInfluence {
                get { return GetMinBoneInfluence(); }
                set { SetMinBoneInfluence(value); }
        }
        
        /// <summary>	
        /// <p>Gets or sets the fixed function vertex value.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetFVF']/*"/>	
        /// <msdn-id>bb174216</msdn-id>	
        /// <unmanaged>GetFVF / SetFVF</unmanaged>	
        /// <unmanaged-short>GetFVF</unmanaged-short>	
        /// <unmanaged>unsigned int ID3DXSkinInfo::GetFVF()</unmanaged>
        public int FVF {
                get { return GetFVF(); }
                set { SetFVF(value); }
        }
        
        /// <summary>	
        /// <p>Sets the influence value for a bone.</p>	
        /// </summary>	
        /// <param name="bone"><dd>  <p>Bone number.</p> </dd></param>	
        /// <param name="numInfluences"><dd>  <p>Number of influences.</p> </dd></param>	
        /// <param name="vertices"><dd>  <p>The array of vertices influenced by a bone.</p> </dd></param>	
        /// <param name="weights"><dd>  <p>The array of weights influenced by a bone.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::SetBoneInfluence']/*"/>	
        /// <msdn-id>bb174224</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneInfluence([In] unsigned int bone,[In] unsigned int numInfluences,[In] const unsigned int* vertices,[In] const float* weights)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::SetBoneInfluence</unmanaged-short>	
        public void SetBoneInfluence(int bone, int numInfluences, int vertices, float weights) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, bone, numInfluences, &vertices, &weights,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an influence value of a bone on a single vertex.</p>	
        /// </summary>	
        /// <param name="boneNum"><dd>  <p>Index of the bone. Must be between 0 and the number of bones.</p> </dd></param>	
        /// <param name="influenceNum"><dd>  <p>Index of the influence array of the specified bone.</p> </dd></param>	
        /// <param name="weight"><dd>  <p>Blend factor of the specified bone influence.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::SetBoneVertexInfluence']/*"/>	
        /// <msdn-id>bb174227</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneVertexInfluence([In] unsigned int boneNum,[In] unsigned int influenceNum,[In] float weight)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::SetBoneVertexInfluence</unmanaged-short>	
        public void SetBoneVertexInfluence(int boneNum, int influenceNum, float weight) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, boneNum, influenceNum, weight,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of influences for a bone.</p>	
        /// </summary>	
        /// <param name="bone"><dd>  <p>Bone number.</p> </dd></param>	
        /// <returns><p>Returns the number of influences for a bone.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetNumBoneInfluences']/*"/>	
        /// <msdn-id>bb174220</msdn-id>	
        /// <unmanaged>unsigned int ID3DXSkinInfo::GetNumBoneInfluences([In] unsigned int bone)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetNumBoneInfluences</unmanaged-short>	
        public int GetNumBoneInfluences(int bone) {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, bone,((void**)(*(void**)_nativePointer))[5]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the vertices and weights that a bone influences.</p>	
        /// </summary>	
        /// <param name="bone"><dd>  <p>Bone number.</p> </dd></param>	
        /// <param name="vertices"><dd>  <p>Get the array of vertices influenced by a bone.</p> </dd></param>	
        /// <param name="weights"><dd>  <p>Get the array of weights influenced by a bone.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Use <strong><see cref="SharpDX.Direct3D9.SkinInfo.GetNumBoneInfluences"/></strong> to find out how many vertices the bone influences. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetBoneInfluence']/*"/>	
        /// <msdn-id>bb174211</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetBoneInfluence([In] unsigned int bone,[Out] unsigned int* vertices,[Out] float* weights)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetBoneInfluence</unmanaged-short>	
        public void GetBoneInfluence(int bone, out int vertices, out float weights) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* vertices_ = &vertices)
                    fixed (void* weights_ = &weights)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, bone, vertices_, weights_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the blend factor and vertex affected by a specified bone influence.</p>	
        /// </summary>	
        /// <param name="boneNum"><dd>  <p>Index of the bone. Must be between 0 and the number of bones.</p> </dd></param>	
        /// <param name="influenceNum"><dd>  <p>Index of the influence array of the specified bone.</p> </dd></param>	
        /// <param name="weightRef"><dd>  <p>Pointer to the blend factor influenced by influenceNum.</p> </dd></param>	
        /// <param name="vertexNumRef"><dd>  <p>Pointer to the vertex influenced by influenceNum.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetBoneVertexInfluence']/*"/>	
        /// <msdn-id>bb174214</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetBoneVertexInfluence([In] unsigned int boneNum,[In] unsigned int influenceNum,[Out] float* pWeight,[Out] unsigned int* pVertexNum)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetBoneVertexInfluence</unmanaged-short>	
        public void GetBoneVertexInfluence(int boneNum, int influenceNum, out float weightRef, out int vertexNumRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* weightRef_ = &weightRef)
                    fixed (void* vertexNumRef_ = &vertexNumRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, boneNum, influenceNum, weightRef_, vertexNumRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the maximum number of influences for any vertex in the mesh.</p>	
        /// </summary>	
        /// <param name="maxVertexInfluences"><dd>  <p>Pointer to the maximum vertex influence.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetMaxVertexInfluences']/*"/>	
        /// <msdn-id>bb174218</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetMaxVertexInfluences([Out] unsigned int* maxVertexInfluences)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetMaxVertexInfluences</unmanaged-short>	
        internal void GetMaxVertexInfluences(out int maxVertexInfluences) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* maxVertexInfluences_ = &maxVertexInfluences)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, maxVertexInfluences_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the number of bones.</p>	
        /// </summary>	
        /// <returns><p>Returns the number of bones.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetNumBones']/*"/>	
        /// <msdn-id>bb174221</msdn-id>	
        /// <unmanaged>unsigned int ID3DXSkinInfo::GetNumBones()</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetNumBones</unmanaged-short>	
        internal int GetNumBones() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the index of the bone influence affecting a single vertex.</p>	
        /// </summary>	
        /// <param name="boneNum"><dd>  <p>Index of the bone. Must be between 0 and the number of bones.</p> </dd></param>	
        /// <param name="vertexNum"><dd>  <p>Index of the vertex for which the bone influence is to be found. Must be between 0 and the number of vertices in the mesh.</p> </dd></param>	
        /// <param name="influenceIndexRef"><dd>  <p>Pointer to the index of the bone influence that affects vertexNum.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the specified bone does not influence the given vertex, S_FALSE is returned. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::FindBoneVertexInfluenceIndex']/*"/>	
        /// <msdn-id>bb174210</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::FindBoneVertexInfluenceIndex([In] unsigned int boneNum,[In] unsigned int vertexNum,[In] unsigned int* pInfluenceIndex)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::FindBoneVertexInfluenceIndex</unmanaged-short>	
        public void FindBoneVertexInfluenceIndex(int boneNum, int vertexNum, int influenceIndexRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, boneNum, vertexNum, &influenceIndexRef,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the maximum face influences in a triangle mesh with the specified index buffer.</p>	
        /// </summary>	
        /// <param name="iBRef"><dd>  <p>Pointer to the index buffer that contains the mesh index data.</p> </dd></param>	
        /// <param name="numFaces"><dd>  <p>Number of faces in the mesh.</p> </dd></param>	
        /// <param name="maxFaceInfluences"><dd>  <p>Pointer to the maximum face influences.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetMaxFaceInfluences']/*"/>	
        /// <msdn-id>bb174217</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetMaxFaceInfluences([In] IDirect3DIndexBuffer9* pIB,[In] unsigned int NumFaces,[Out] unsigned int* maxFaceInfluences)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetMaxFaceInfluences</unmanaged-short>	
        public void GetMaxFaceInfluences(SharpDX.Direct3D9.IndexBuffer iBRef, int numFaces, out int maxFaceInfluences) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* maxFaceInfluences_ = &maxFaceInfluences)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((iBRef == null)?IntPtr.Zero:iBRef.NativePointer), numFaces, maxFaceInfluences_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the minimum bone influence. Influence values smaller than this are ignored.</p>	
        /// </summary>	
        /// <param name="minInfl"><dd>  <p>Minimum influence value. Influence values smaller than this are ignored.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::SetMinBoneInfluence']/*"/>	
        /// <msdn-id>bb174230</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetMinBoneInfluence([In] float MinInfl)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::SetMinBoneInfluence</unmanaged-short>	
        internal void SetMinBoneInfluence(float minInfl) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, minInfl,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the minimum bone influence. Influence values smaller than this are ignored.</p>	
        /// </summary>	
        /// <returns><p>Returns the minimum bone influence value.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetMinBoneInfluence']/*"/>	
        /// <msdn-id>bb174219</msdn-id>	
        /// <unmanaged>float ID3DXSkinInfo::GetMinBoneInfluence()</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetMinBoneInfluence</unmanaged-short>	
        internal float GetMinBoneInfluence() {
            unsafe {
                float __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Callifloat(_nativePointer,((void**)(*(void**)_nativePointer))[13]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets the bone name.</p>	
        /// </summary>	
        /// <param name="bone"><dd>  <p>Bone number</p> </dd></param>	
        /// <param name="nameRef"><dd>  <p>Bone name</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Bone names are returned by <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshFromXof"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::SetBoneName']/*"/>	
        /// <msdn-id>bb174225</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneName([In] unsigned int Bone,[In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::SetBoneName</unmanaged-short>	
        public void SetBoneName(int bone, string nameRef) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, bone, (void*)nameRef_,((void**)(*(void**)_nativePointer))[14]);		
                Marshal.FreeHGlobal(nameRef_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the bone name, from the bone index.</p>	
        /// </summary>	
        /// <param name="bone"><dd>  <p>Bone number.</p> </dd></param>	
        /// <returns><p>Returns the bone name. Do not free this string.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetBoneName']/*"/>	
        /// <msdn-id>bb174212</msdn-id>	
        /// <unmanaged>const char* ID3DXSkinInfo::GetBoneName([In] unsigned int Bone)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetBoneName</unmanaged-short>	
        public string GetBoneName(int bone) {
            unsafe {
                string __result__;
                __result__= 
				Marshal.PtrToStringAnsi(SharpDX.Direct3D9.LocalInterop.CalliSystemIntPtr(_nativePointer, bone,((void**)(*(void**)_nativePointer))[15]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets the bone offset matrix.</p>	
        /// </summary>	
        /// <param name="bone"><dd>  <p>Bone number.</p> </dd></param>	
        /// <param name="boneTransformRef"><dd>  <p>Pointer to the bone offset matrix.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Bone names are returned by <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshFromXof"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::SetBoneOffsetMatrix']/*"/>	
        /// <msdn-id>bb174226</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetBoneOffsetMatrix([In] unsigned int Bone,[In] const D3DXMATRIX* pBoneTransform)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::SetBoneOffsetMatrix</unmanaged-short>	
        public void SetBoneOffsetMatrix(int bone, ref SharpDX.Mathematics.Interop.RawMatrix boneTransformRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* boneTransformRef_ = &boneTransformRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, bone, boneTransformRef_,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the bone offset matrix.</p>	
        /// </summary>	
        /// <param name="bone"><dd>  <p>Bone number.</p> </dd></param>	
        /// <returns><p>Returns a reference to the bone offset matrix. Do not free this reference.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetBoneOffsetMatrix']/*"/>	
        /// <msdn-id>bb174213</msdn-id>	
        /// <unmanaged>D3DXMATRIX* ID3DXSkinInfo::GetBoneOffsetMatrix([In] unsigned int Bone)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetBoneOffsetMatrix</unmanaged-short>	
        public SharpDX.Mathematics.Interop.RawMatrix GetBoneOffsetMatrix(int bone) {
            unsafe {
                SharpDX.Mathematics.Interop.RawMatrix __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawMatrix(_nativePointer, bone,((void**)(*(void**)_nativePointer))[17]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Clones a skin info object.</p>	
        /// </summary>	
        /// <param name="skinInfoOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.SkinInfo"/></strong> object, which will contain the cloned object if the method is successful.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::Clone']/*"/>	
        /// <msdn-id>bb174207</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::Clone([In] ID3DXSkinInfo** ppSkinInfo)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::Clone</unmanaged-short>	
        public void Clone(out SharpDX.Direct3D9.SkinInfo skinInfoOut) {
            unsafe {
                IntPtr skinInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &skinInfoOut_,((void**)(*(void**)_nativePointer))[18]);		
                skinInfoOut= (skinInfoOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.SkinInfo(skinInfoOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Updates bone influence information to match vertices after they are reordered. This method should be called if the target vertex buffer has been reordered externally.</p>	
        /// </summary>	
        /// <param name="numVertices"><dd>  <p>Number of vertices to remap.</p> </dd></param>	
        /// <param name="vertexRemapRef"><dd>  <p>Array of DWORDS whose length is specified by NumVertices.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Each element in pVertexRemap specifies the previous vertex index for that position.  For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap should contain 3.  The vertex remap array returned by <strong><see cref="SharpDX.Direct3D9.Mesh.Optimize"/></strong> can be used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::Remap']/*"/>	
        /// <msdn-id>bb174223</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::Remap([In] unsigned int NumVertices,[In] unsigned int* pVertexRemap)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::Remap</unmanaged-short>	
        public void Remap(int numVertices, int vertexRemapRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, numVertices, &vertexRemapRef,((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the flexible vertex format (FVF) type.</p>	
        /// </summary>	
        /// <param name="fvf"><dd>  <p>Flexible vertex format. See <see cref="SharpDX.Direct3D9.VertexFormat"/>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::SetFVF']/*"/>	
        /// <msdn-id>bb174229</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetFVF([In] unsigned int FVF)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::SetFVF</unmanaged-short>	
        internal void SetFVF(int fvf) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, fvf,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the vertex declaration.</p>	
        /// </summary>	
        /// <param name="declarationRef"><dd>  <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::SetDeclaration']/*"/>	
        /// <msdn-id>bb174228</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::SetDeclaration([In] const D3DVERTEXELEMENT9* pDeclaration)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::SetDeclaration</unmanaged-short>	
        public void SetDeclaration(SharpDX.Direct3D9.VertexElement declarationRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &declarationRef,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the fixed function vertex value.</p>	
        /// </summary>	
        /// <returns><p>Returns the flexible vertex format (FVF) codes.</p></returns>	
        /// <remarks>	
        /// <p>This method can return 0 if the vertex format cannot be mapped directly to an FVF code.  This will occur for a mesh created from a vertex declaration that doesn't have the same order and elements supported by the FVF codes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetFVF']/*"/>	
        /// <msdn-id>bb174216</msdn-id>	
        /// <unmanaged>unsigned int ID3DXSkinInfo::GetFVF()</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetFVF</unmanaged-short>	
        internal int GetFVF() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[22]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets the vertex declaration.</p>	
        /// </summary>	
        /// <param name="declaration"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is <strong><see cref="SharpDX.Direct3D9.VertexFormatDeclaratorCount.Max"/></strong>. The vertex element array ends with the <strong>D3DDECL_END</strong> macro. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The array of elements includes the <strong>D3DDECL_END</strong> macro, which ends the declaration.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::GetDeclaration']/*"/>	
        /// <msdn-id>bb174215</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::GetDeclaration([In] D3DVERTEXELEMENT9* Declaration)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::GetDeclaration</unmanaged-short>	
        public void GetDeclaration(SharpDX.Direct3D9.VertexElement declaration) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &declaration,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Applies software skinning to the target vertices based on the current matrices.</p>	
        /// </summary>	
        /// <param name="boneTransformsRef"><dd>  <p>Bone transform matrix.</p> </dd></param>	
        /// <param name="boneInvTransposeTransformsRef"><dd>  <p>Inverse transpose of the bone transform matrix.</p> </dd></param>	
        /// <param name="verticesSrcRef"><dd>  <p>Pointer to the buffer containing the source vertices.</p> </dd></param>	
        /// <param name="verticesDstRef"><dd>  <p>Pointer to the buffer containing the destination vertices.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>When used to skin vertices with two position elements, this method skins the second position element with the inverse of the bone instead of the bone itself.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::UpdateSkinnedMesh']/*"/>	
        /// <msdn-id>bb174231</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::UpdateSkinnedMesh([In] const D3DXMATRIX* pBoneTransforms,[In] const D3DXMATRIX* pBoneInvTransposeTransforms,[In] const void* pVerticesSrc,[In] void* pVerticesDst)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::UpdateSkinnedMesh</unmanaged-short>	
        public void UpdateSkinnedMesh(ref SharpDX.Mathematics.Interop.RawMatrix boneTransformsRef, ref SharpDX.Mathematics.Interop.RawMatrix boneInvTransposeTransformsRef, System.IntPtr verticesSrcRef, System.IntPtr verticesDstRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* boneTransformsRef_ = &boneTransformsRef)
                    fixed (void* boneInvTransposeTransformsRef_ = &boneInvTransposeTransformsRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, boneTransformsRef_, boneInvTransposeTransformsRef_, (void*)verticesSrcRef, (void*)verticesDstRef,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Takes a mesh and returns a new mesh with per-vertex blend weights and a bone combination table. The table describes which bones affect which subsets of the mesh.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Input mesh. See <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Currently unused.</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Input mesh adjacency information.</p> </dd></param>	
        /// <param name="adjacencyOutRef"><dd>  <p>Output mesh adjacency information.</p> </dd></param>	
        /// <param name="faceRemapRef"><dd>  <p>An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the blended mesh. If the value supplied for this argument is <strong><c>null</c></strong>, face remap data is not returned.</p> </dd></param>	
        /// <param name="vertexRemapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. This parameter is optional; <strong><c>null</c></strong> may be used.</p> </dd></param>	
        /// <param name="maxFaceInflRef"><dd>  <p>Pointer to a DWORD that will contain the maximum number of bone influences required per vertex for this skinning method.</p> </dd></param>	
        /// <param name="numBoneCombinationsRef"><dd>  <p>Pointer to the number of bones in the bone combination table.</p> </dd></param>	
        /// <param name="boneCombinationTableOut"><dd>  <p>Pointer to the bone combination table. The data is organized in a <strong><see cref="SharpDX.Direct3D9.BoneCombination"/></strong> structure.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Pointer to the new mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Each element in the remap array specifies the previous index for that position. For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap will contain 3.</p><p>This method does not run on hardware that does not support fixed-function vertex blending.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::ConvertToBlendedMesh']/*"/>	
        /// <msdn-id>bb174208</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::ConvertToBlendedMesh([In] ID3DXMesh* pMesh,[In] unsigned int Options,[In] const unsigned int* pAdjacencyIn,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pFaceRemap,[In] ID3DXBuffer** ppVertexRemap,[In] unsigned int* pMaxFaceInfl,[In] unsigned int* pNumBoneCombinations,[In] ID3DXBuffer** ppBoneCombinationTable,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::ConvertToBlendedMesh</unmanaged-short>	
        public void ConvertToBlendedMesh(SharpDX.Direct3D9.Mesh meshRef, int options, int adjacencyInRef, int adjacencyOutRef, int faceRemapRef, out SharpDX.Direct3D.Blob vertexRemapOut, int maxFaceInflRef, int numBoneCombinationsRef, out SharpDX.Direct3D.Blob boneCombinationTableOut, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr vertexRemapOut_ = IntPtr.Zero;
                IntPtr boneCombinationTableOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), options, &adjacencyInRef, &adjacencyOutRef, &faceRemapRef, &vertexRemapOut_, &maxFaceInflRef, &numBoneCombinationsRef, &boneCombinationTableOut_, &meshOut_,((void**)(*(void**)_nativePointer))[25]);		
                vertexRemapOut= (vertexRemapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapOut_);	
                boneCombinationTableOut= (boneCombinationTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(boneCombinationTableOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Takes a mesh and returns a new mesh with per-vertex blend weights, indices, and a bone combination table. The table describes which bone palettes affect which subsets of the mesh.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>The input mesh. See <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Currently unused.</p> </dd></param>	
        /// <param name="paletteSize"><dd>  <p>Number of bone matrices available for matrix palette skinning.</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Input mesh adjacency information.</p> </dd></param>	
        /// <param name="adjacencyOutRef"><dd>  <p>Output mesh adjacency information.</p> </dd></param>	
        /// <param name="faceRemapRef"><dd>  <p>An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the blended mesh. If the value supplied for this argument is <strong><c>null</c></strong>, face remap data is not returned.</p> </dd></param>	
        /// <param name="vertexRemapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping. This parameter is optional; <strong><c>null</c></strong> may be used.</p> </dd></param>	
        /// <param name="maxVertexInflRef"><dd>  <p>Pointer to a DWORD that will contain the maximum number of bone influences required per vertex for this skinning method.</p> </dd></param>	
        /// <param name="numBoneCombinationsRef"><dd>  <p>Pointer to the number of bones in the bone combination table.</p> </dd></param>	
        /// <param name="boneCombinationTableOut"><dd>  <p>Pointer to the bone combination table. The data is organized in a <strong><see cref="SharpDX.Direct3D9.BoneCombination"/></strong> structure.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Pointer to the new mesh.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Each element in the remap arrays specifies the previous index for that position. For example, if a vertex was in position 3 but has been remapped to position 5, then the fifth element of pVertexRemap will contain 3.</p><p>This method does not run on hardware that does not support fixed-function vertex blending.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSkinInfo::ConvertToIndexedBlendedMesh']/*"/>	
        /// <msdn-id>bb174209</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSkinInfo::ConvertToIndexedBlendedMesh([In] ID3DXMesh* pMesh,[In] unsigned int Options,[In] unsigned int paletteSize,[In] const unsigned int* pAdjacencyIn,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pFaceRemap,[In] ID3DXBuffer** ppVertexRemap,[In] unsigned int* pMaxVertexInfl,[In] unsigned int* pNumBoneCombinations,[In] ID3DXBuffer** ppBoneCombinationTable,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>ID3DXSkinInfo::ConvertToIndexedBlendedMesh</unmanaged-short>	
        public void ConvertToIndexedBlendedMesh(SharpDX.Direct3D9.Mesh meshRef, int options, int paletteSize, int adjacencyInRef, int adjacencyOutRef, int faceRemapRef, out SharpDX.Direct3D.Blob vertexRemapOut, int maxVertexInflRef, int numBoneCombinationsRef, out SharpDX.Direct3D.Blob boneCombinationTableOut, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr vertexRemapOut_ = IntPtr.Zero;
                IntPtr boneCombinationTableOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), options, paletteSize, &adjacencyInRef, &adjacencyOutRef, &faceRemapRef, &vertexRemapOut_, &maxVertexInflRef, &numBoneCombinationsRef, &boneCombinationTableOut_, &meshOut_,((void**)(*(void**)_nativePointer))[26]);		
                vertexRemapOut= (vertexRemapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapOut_);	
                boneCombinationTableOut= (boneCombinationTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(boneCombinationTableOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D9.Sprite"/> interface provides a set of methods that simplify the process of drawing sprites using Microsoft Direct3D.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.Sprite"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateSprite"/></strong> function.</p><p>The application typically first calls <strong><see cref="SharpDX.Direct3D9.Sprite.Begin"/></strong>, which allows control over the device render state, alpha blending, and sprite transformation and sorting. Then for each sprite to be displayed, call <strong><see cref="SharpDX.Direct3D9.Sprite.Draw"/></strong>. <strong><see cref="SharpDX.Direct3D9.Sprite.Draw"/></strong> can be called repeatedly to store any number of sprites. To display the batched sprites to the device, call <strong><see cref="SharpDX.Direct3D9.Sprite.End"/></strong> or <strong><see cref="SharpDX.Direct3D9.Sprite.Flush"/></strong>.</p><p>The LPD3DXSPRITE type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.Sprite"/></strong> interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.Sprite"/> <see cref="SharpDX.Direct3D9.Sprite"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D9.Sprite"/> *LPD3DXSPRITE;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite']/*"/>	
    /// <msdn-id>bb174249</msdn-id>	
    /// <unmanaged>ID3DXSprite</unmanaged>	
    /// <unmanaged-short>ID3DXSprite</unmanaged-short>	
    [Guid("ba0b762d-7d28-43ec-b9dc-2f84443b0614")]
    public partial class Sprite : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Sprite"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Sprite(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Sprite"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Sprite(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Sprite(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the device associated with the sprite object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::GetDevice']/*"/>	
        /// <msdn-id>bb174254</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXSprite::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets or sets the sprite transform.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::GetTransform']/*"/>	
        /// <msdn-id>bb174255</msdn-id>	
        /// <unmanaged>GetTransform / SetTransform</unmanaged>	
        /// <unmanaged-short>GetTransform</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXSprite::GetTransform([Out] D3DXMATRIX* pTransform)</unmanaged>
        public SharpDX.Mathematics.Interop.RawMatrix Transform {
                get { SharpDX.Mathematics.Interop.RawMatrix __output__; GetTransform(out __output__); return __output__; }
                set { SetTransform(ref value); }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with the sprite object.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the Direct3D device object associated with the sprite object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned.<see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::GetDevice']/*"/>	
        /// <msdn-id>bb174254</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the sprite transform.</p>	
        /// </summary>	
        /// <param name="transformRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> that contains a transform of the sprite from the original world space.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned.<see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::GetTransform']/*"/>	
        /// <msdn-id>bb174255</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::GetTransform([Out] D3DXMATRIX* pTransform)</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::GetTransform</unmanaged-short>	
        internal void GetTransform(out SharpDX.Mathematics.Interop.RawMatrix transformRef) {
            unsafe {
                transformRef = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                fixed (void* transformRef_ = &transformRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, transformRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the sprite transform.</p>	
        /// </summary>	
        /// <param name="transformRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> that contains a transform of the sprite from the original world space. Use this transform to scale, rotate, or transform the sprite.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned.<see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::SetTransform']/*"/>	
        /// <msdn-id>bb174258</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::SetTransform([In] const D3DXMATRIX* pTransform)</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::SetTransform</unmanaged-short>	
        internal void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix transformRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* transformRef_ = &transformRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, transformRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the right-handed world-view transform for a sprite. A call to this method is required before billboarding or sorting sprites.</p>	
        /// </summary>	
        /// <param name="worldRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> that contains a world transform. If <strong><c>null</c></strong>, the identity matrix is used for the world transform.</p> </dd></param>	
        /// <param name="viewRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> that contains a view transform. If <strong><c>null</c></strong>, the identity matrix is used for the view transform.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned.<see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p>A call to this method (or to <strong><see cref="SharpDX.Direct3D9.Sprite.SetWorldViewLH"/></strong>) is required if the sprite will be rendered with the D3DXSprite__BILLBOARD, D3DXSprite__SORT_DEPTH_FRONTTOBACK, or D3DXSprite__SORT_DEPTH_BACKTOFRONT flag value in <strong><see cref="SharpDX.Direct3D9.Sprite.Begin"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::SetWorldViewRH']/*"/>	
        /// <msdn-id>bb174260</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::SetWorldViewRH([In] const D3DXMATRIX* pWorld,[In] const D3DXMATRIX* pView)</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::SetWorldViewRH</unmanaged-short>	
        public void SetWorldViewRH(ref SharpDX.Mathematics.Interop.RawMatrix worldRef, ref SharpDX.Mathematics.Interop.RawMatrix viewRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* worldRef_ = &worldRef)
                    fixed (void* viewRef_ = &viewRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, worldRef_, viewRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the left-handed world-view transform for a sprite. A call to this method is required before billboarding or sorting sprites.</p>	
        /// </summary>	
        /// <param name="worldRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> that contains a world transform. If <strong><c>null</c></strong>, the identity matrix is used for the world transform.</p> </dd></param>	
        /// <param name="viewRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong> that contains a view transform. If <strong><c>null</c></strong>, the identity matrix is used for the view transform.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned.<see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p>A call to this method (or to <strong><see cref="SharpDX.Direct3D9.Sprite.SetWorldViewRH"/></strong>) is required if the sprite will be rendered with the D3DXSprite__BILLBOARD, D3DXSprite__SORT_DEPTH_FRONTTOBACK, or D3DXSprite__SORT_DEPTH_BACKTOFRONT flag value in <strong><see cref="SharpDX.Direct3D9.Sprite.Begin"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::SetWorldViewLH']/*"/>	
        /// <msdn-id>bb174259</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::SetWorldViewLH([In] const D3DXMATRIX* pWorld,[In] const D3DXMATRIX* pView)</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::SetWorldViewLH</unmanaged-short>	
        public void SetWorldViewLH(ref SharpDX.Mathematics.Interop.RawMatrix worldRef, ref SharpDX.Mathematics.Interop.RawMatrix viewRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* worldRef_ = &worldRef)
                    fixed (void* viewRef_ = &viewRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, worldRef_, viewRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Prepares a device for drawing sprites.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Combination of zero or more flags that describe sprite rendering options. For this method, the valid flags are:</p> <ul> <li><see cref="SharpDX.Direct3D9.SpriteFlags.AlphaBlend"/></li> <li>D3DXSPRITE__BILLBOARD</li> <li><see cref="SharpDX.Direct3D9.SpriteFlags.DoNotModifyRenderState"/></li> <li><see cref="SharpDX.Direct3D9.SpriteFlags.DoNotSaveState"/></li> <li><see cref="SharpDX.Direct3D9.SpriteFlags.ObjectSpace"/></li> <li>D3DXSPRITE__SORT_DEPTH_BACKTOFRONT</li> <li>D3DXSPRITE__SORT_DEPTH_FRONTTOBACK</li> <li>D3DXSPRITE__SORT_TEXTURE</li> </ul> <p> For a description of the flags and for information on how to control device state capture and device view transforms, see <see cref="SharpDX.Direct3D9.SpriteFlags"/>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method must be called from inside a <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> . . . <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> sequence. <strong><see cref="SharpDX.Direct3D9.Sprite.Begin"/></strong> cannot be used as a substitute for either <strong><see cref="SharpDX.Direct3D9.Device.BeginScene"/></strong> or <strong><see cref="SharpDX.Direct3D9.RenderToSurface.BeginScene"/></strong>.</p><p>This method will set the following states on the device.</p><p>Render States:</p><table> <tr><th>Type (<strong><see cref="SharpDX.Direct3D9.RenderState"/></strong>)</th><th>Value</th></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.AlphaBlendEnable"/></td><td>TRUE</td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.AlphaFunc"/></td><td><see cref="SharpDX.Direct3D9.Compare.Greater"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.AlphaRef"/></td><td>0x00</td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.AlphaTestEnable"/></td><td>AlphaCmpCaps</td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.BlendOperation"/></td><td><see cref="SharpDX.Direct3D9.BlendOperation.Add"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.Clipping"/></td><td>TRUE</td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.ClipPlaneEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.ColorWriteEnable"/></td><td><see cref="SharpDX.Direct3D9.ColorWriteEnable.Alpha"/> | <see cref="SharpDX.Direct3D9.ColorWriteEnable.Blue"/> | <see cref="SharpDX.Direct3D9.ColorWriteEnable.Green"/> | <see cref="SharpDX.Direct3D9.ColorWriteEnable.Red"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.CullMode"/></td><td><see cref="SharpDX.Direct3D9.Cull.None"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.DestinationBlend"/></td><td><see cref="SharpDX.Direct3D9.Blend.InverseSourceAlpha"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.DiffuseMaterialSource"/></td><td><see cref="SharpDX.Direct3D9.ColorSource.Color1"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.EnableAdaptiveTessellation"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.FillMode"/></td><td><see cref="SharpDX.Direct3D9.FillMode.Solid"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.FogEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.IndexedVertexBlendEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.Lighting"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.RangeFogEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.SeparateAlphaBlendEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.ShadeMode"/></td><td><see cref="SharpDX.Direct3D9.ShadeMode.Gouraud"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.SpecularEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.SourceBlend"/></td><td><see cref="SharpDX.Direct3D9.Blend.SourceAlpha"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.SrgbWriteEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.StencilEnable"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.VertexBlend"/></td><td><see cref="SharpDX.Result.False"/></td></tr> <tr><td><see cref="SharpDX.Direct3D9.RenderState.Wrap0"/></td><td>0</td></tr> </table><p>?</p><p>Texture Stage States:</p><table> <tr><th>Stage Identifier</th><th>Type (<strong><see cref="SharpDX.Direct3D9.TextureStage"/></strong>)</th><th>Value</th></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.AlphaArg1"/></td><td><see cref="SharpDX.Direct3D9.TextureArgument.Texture"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.AlphaArg2"/></td><td><see cref="SharpDX.Direct3D9.TextureArgument.Diffuse"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.AlphaOperation"/></td><td><see cref="SharpDX.Direct3D9.TextureOperation.Modulate"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.ColorArg1"/></td><td><see cref="SharpDX.Direct3D9.TextureArgument.Texture"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.ColorArg2"/></td><td><see cref="SharpDX.Direct3D9.TextureArgument.Diffuse"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.ColorOperation"/></td><td><see cref="SharpDX.Direct3D9.TextureOperation.Modulate"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.TexCoordIndex"/></td><td>0</td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.TextureStage.TextureTransformFlags"/></td><td><see cref="SharpDX.Direct3D9.TextureTransform.Disable"/></td></tr> <tr><td>1</td><td><see cref="SharpDX.Direct3D9.TextureStage.AlphaOperation"/></td><td><see cref="SharpDX.Direct3D9.TextureOperation.Disable"/></td></tr> <tr><td>1</td><td><see cref="SharpDX.Direct3D9.TextureStage.ColorOperation"/></td><td><see cref="SharpDX.Direct3D9.TextureOperation.Disable"/></td></tr> </table><p>?</p><p>Sampler States:</p><table> <tr><th>Sampler Stage Index</th><th>Type (<strong><see cref="SharpDX.Direct3D9.SamplerState"/></strong>)</th><th>Value</th></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.AddressU"/></td><td><see cref="SharpDX.Direct3D9.TextureAddress.Clamp"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.AddressV"/></td><td><see cref="SharpDX.Direct3D9.TextureAddress.Clamp"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.MagFilter"/></td><td><see cref="SharpDX.Direct3D9.TextureFilter.Anisotropic"/> if TextureFilterCaps includes <see cref="SharpDX.Direct3D9.FilterCaps.MagAnisotropic"/>; otherwise <see cref="SharpDX.Direct3D9.TextureFilter.Linear"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.MaxMipLevel"/></td><td>0</td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.MaxAnisotropy"/></td><td>MaxAnisotropy</td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.MinFilter"/></td><td><see cref="SharpDX.Direct3D9.TextureFilter.Anisotropic"/> if TextureFilterCaps includes <see cref="SharpDX.Direct3D9.FilterCaps.MinAnisotropic"/>; otherwise <see cref="SharpDX.Direct3D9.TextureFilter.Linear"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.MipFilter"/></td><td><see cref="SharpDX.Direct3D9.TextureFilter.Linear"/> if TextureFilterCaps includes <see cref="SharpDX.Direct3D9.FilterCaps.MipLinear"/>; otherwise <see cref="SharpDX.Direct3D9.TextureFilter.Point"/></td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.MipMapLodBias"/></td><td>0</td></tr> <tr><td>0</td><td><see cref="SharpDX.Direct3D9.SamplerState.SrgbTexture"/></td><td>0</td></tr> </table><p>?</p><p><strong>Note</strong>??This method disables N-patches.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::Begin']/*"/>	
        /// <msdn-id>bb174250</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::Begin([In] D3DXSPRITE Flags)</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::Begin</unmanaged-short>	
        public void Begin(SharpDX.Direct3D9.SpriteFlags flags = SpriteFlags.None) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, unchecked((int)flags),((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a sprite to the list of batched sprites.</p>	
        /// </summary>	
        /// <param name="textureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface that represents the sprite texture.</p> </dd></param>	
        /// <param name="srcRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that indicates the portion of the source texture to use for the sprite. If this parameter is <strong><c>null</c></strong>, then the entire source image is used for the sprite.</p> </dd></param>	
        /// <param name="centerRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> vector that identifies the center of the sprite. If this argument is <strong><c>null</c></strong>, the point (0,0,0) is used, which is the upper-left corner.</p> </dd></param>	
        /// <param name="positionRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> vector that identifies the position of the sprite. If this argument is <strong><c>null</c></strong>, the point (0,0,0) is used, which is the upper-left corner.</p> </dd></param>	
        /// <param name="color"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> type. The color and alpha channels are modulated by this value. A value of 0xFFFFFFFF maintains the original source color and alpha data. Use the <strong>D3DCOLOR_RGBA</strong> macro to help generate this color.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>To scale, rotate, or translate a sprite, call <strong><see cref="SharpDX.Direct3D9.Sprite.SetTransform"/></strong> with a matrix that contains the scale, rotate, and translate (SRT) values, before calling <see cref="SharpDX.Direct3D9.Sprite.Draw"/>. For information about setting SRT values in a matrix, see Matrix Transforms.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::Draw']/*"/>	
        /// <msdn-id>bb174251</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::Draw([In] IDirect3DTexture9* pTexture,[In] const void* pSrcRect,[In] const void* pCenter,[In] const void* pPosition,[In] D3DCOLOR Color)</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::Draw</unmanaged-short>	
        internal void Draw(SharpDX.Direct3D9.Texture textureRef, System.IntPtr srcRectRef, System.IntPtr centerRef, System.IntPtr positionRef, SharpDX.Mathematics.Interop.RawColorBGRA color) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint76(_nativePointer, (void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer), (void*)srcRectRef, (void*)centerRef, (void*)positionRef, color,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Forces all batched sprites to be submitted to the device. Device states remain as they were after the last call to <strong><see cref="SharpDX.Direct3D9.Sprite.Begin"/></strong>. The list of batched sprites is then cleared.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned.<see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::Flush']/*"/>	
        /// <msdn-id>bb174253</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::Flush()</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::Flush</unmanaged-short>	
        public void Flush() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Calls <strong><see cref="SharpDX.Direct3D9.Sprite.Flush"/></strong> and restores the device state to how it was before <strong><see cref="SharpDX.Direct3D9.Sprite.Begin"/></strong> was called.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned.<see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Sprite.End"/></strong> cannot be used as a substitute for either <strong><see cref="SharpDX.Direct3D9.Device.EndScene"/></strong> or <strong><see cref="SharpDX.Direct3D9.RenderToSurface.EndScene"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::End']/*"/>	
        /// <msdn-id>bb174252</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::End()</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::End</unmanaged-short>	
        public void End() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to release all references to video memory resources and delete all stateblocks. This method should be called whenever a device is lost or before resetting a device.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method should be called whenever the device is lost or before the user calls <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>. Even if the device was not actually lost, <strong><see cref="SharpDX.Direct3D9.Sprite.OnLostDevice"/></strong> is responsible for freeing stateblocks and other resources that may need to be released before resetting the device. As a result, the font object cannot be used again before calling <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong> and then <strong><see cref="SharpDX.Direct3D9.Sprite.OnResetDevice"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::OnLostDevice']/*"/>	
        /// <msdn-id>bb174256</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::OnLostDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::OnLostDevice</unmanaged-short>	
        public void OnLostDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Use this method to re-acquire resources and save initial state.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.Sprite.OnResetDevice"/></strong> should be called each time the device is reset (using <strong><see cref="SharpDX.Direct3D9.Device.Reset"/></strong>), before any other methods are called. This is a good place to re-acquire video-memory resources and capture state blocks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXSprite::OnResetDevice']/*"/>	
        /// <msdn-id>bb174257</msdn-id>	
        /// <unmanaged>HRESULT ID3DXSprite::OnResetDevice()</unmanaged>	
        /// <unmanaged-short>ID3DXSprite::OnResetDevice</unmanaged-short>	
        public void OnResetDevice() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.StateBlock"/> interface to encapsulate render states.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface can be used to save and restore pipeline state. It can also be used to capture the current state.</p><p>The LPDIRECT3DSTATEBLOCK9 and PDIRECT3DSTATEBLOCK9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.StateBlock"/></strong> interface. </p><pre>typedef struct <see cref="SharpDX.Direct3D9.StateBlock"/> *LPDIRECT3DSTATEBLOCK9, *PDIRECT3DSTATEBLOCK9;</pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DStateBlock9']/*"/>	
    /// <msdn-id>bb205887</msdn-id>	
    /// <unmanaged>IDirect3DStateBlock9</unmanaged>	
    /// <unmanaged-short>IDirect3DStateBlock9</unmanaged-short>	
    [Guid("B07C4FE5-310D-4ba8-A23C-4F0F206F218B")]
    public partial class StateBlock : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.StateBlock"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public StateBlock(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.StateBlock"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.StateBlock(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.StateBlock(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the device.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DStateBlock9::GetDevice']/*"/>	
        /// <msdn-id>bb205891</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DStateBlock9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the device.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Pointer to the <see cref="SharpDX.Direct3D9.Device"/> interface that is returned.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DStateBlock9::GetDevice']/*"/>	
        /// <msdn-id>bb205891</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DStateBlock9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DStateBlock9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Capture the current value of states that are included in a stateblock.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails because capture cannot be done while in record mode, the return value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The Capture method captures current values for states within an existing state block. It does not capture the entire state of the device. For example:</p><pre> <see cref="SharpDX.Direct3D9.StateBlock"/>* pStateBlock = <c>null</c>; pd3dDevice-&gt;BeginStateBlock();	
        /// // Add the ZENABLE state to the stateblock 	
        /// pd3dDevice-&gt;SetRenderState ( <see cref="SharpDX.Direct3D9.RenderState.ZEnable"/>, <see cref="SharpDX.Direct3D9.ZBufferType.UseZBuffer"/> );	
        /// pd3dDevice-&gt;EndStateBlock ( &amp;pStateBlock ); // Change the current value that is stored in the state block	
        /// pd3dDevice-&gt;SetRenderState ( <see cref="SharpDX.Direct3D9.RenderState.ZEnable"/>, <see cref="SharpDX.Direct3D9.ZBufferType.DontUseZBuffer"/> );	
        /// pStateBlock-&gt;Capture();			 pStateBlock-&gt;Release();	
        /// </pre><p>Creating an empty stateblock and calling the Capture method does nothing if no states have been set.</p><p>The Capture method  will not capture information for lights that are explicitly or implicitly created after the stateblock is created.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DStateBlock9::Capture']/*"/>	
        /// <msdn-id>bb205890</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DStateBlock9::Capture()</unmanaged>	
        /// <unmanaged-short>IDirect3DStateBlock9::Capture</unmanaged-short>	
        public void Capture() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Apply the state block to the current device state.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails while in record mode, the return value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DStateBlock9::Apply']/*"/>	
        /// <msdn-id>bb205889</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DStateBlock9::Apply()</unmanaged>	
        /// <unmanaged-short>IDirect3DStateBlock9::Apply</unmanaged-short>	
        public void Apply() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.Surface"/> interface to query and prepare surfaces.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPDIRECT3DSURFACE9 and PDIRECT3DSURFACE9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.Surface"/> *LPDIRECT3DSURFACE9, *PDIRECT3DSURFACE9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9']/*"/>	
    /// <msdn-id>bb205892</msdn-id>	
    /// <unmanaged>IDirect3DSurface9</unmanaged>	
    /// <unmanaged-short>IDirect3DSurface9</unmanaged-short>	
    [Guid("0CFBAF3A-9FF6-429a-99B3-A2796AF8B89B")]
    public partial class Surface : SharpDX.Direct3D9.Resource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Surface"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Surface(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Surface"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Surface(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Surface(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a description of the surface.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9::GetDesc']/*"/>	
        /// <msdn-id>bb205895</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DSurface9::GetDesc([Out] D3DSURFACE_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.SurfaceDescription Description {
                get { SharpDX.Direct3D9.SurfaceDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Provides access to the parent cube texture or texture (mipmap) object, if this surface is a child level of a cube texture or a mipmap. This method can also provide access to the parent swap chain if the surface is a back-buffer child.</p>	
        /// </summary>	
        /// <param name="riid"><dd>  <p>Reference identifier of the container being requested. </p> </dd></param>	
        /// <param name="containerOut"><dd>  <p>Address of a reference to fill with the container reference if the query succeeds. See Remarks. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>If the surface is created using <strong>CreateRenderTarget</strong> or <strong>CreateOffscreenPlainSurface</strong> or <strong>CreateDepthStencilSurface</strong>, the surface is considered stand alone. In this case, <strong>GetContainer</strong> will return the Direct3D device used to create the surface.</p><p>If the call succeeds, the reference count of the container is increased by one.</p><p>Here's an example getting the parent texture of a mip surface.</p><pre> // Assumes pSurface is a valid <see cref="SharpDX.Direct3D9.Surface"/> reference	
        /// void *pContainer = <c>null</c>;	
        /// <see cref="SharpDX.Direct3D9.Texture"/> *pTexture = <c>null</c>;	
        /// <see cref="SharpDX.Result"/> hr = pSurface-&gt;GetContainer(IID_IDirect3DTexture9, &amp;pContainer);	
        /// if (SUCCEEDED(hr) &amp;&amp; pContainer)	
        /// { pTexture = (<see cref="SharpDX.Direct3D9.Texture"/> *)pContainer;	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9::GetContainer']/*"/>	
        /// <msdn-id>bb205893</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSurface9::GetContainer([In] const GUID&amp; riid,[Out] void** ppContainer)</unmanaged>	
        /// <unmanaged-short>IDirect3DSurface9::GetContainer</unmanaged-short>	
        internal void GetContainer(System.Guid riid, out System.IntPtr containerOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* containerOut_ = &containerOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &riid, containerOut_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a description of the surface.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.SurfaceDescription"/></strong> structure, describing the surface. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p><p><see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the argument is invalid.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9::GetDesc']/*"/>	
        /// <msdn-id>bb205895</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSurface9::GetDesc([Out] D3DSURFACE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>IDirect3DSurface9::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.SurfaceDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D9.SurfaceDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Locks a rectangle on a surface.</p>	
        /// </summary>	
        /// <param name="lockedRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.LockedRectangle"/></strong> structure that describes the locked region. </p> </dd></param>	
        /// <param name="rectRef"><dd>  <p>Pointer to a rectangle to lock. Specified by a reference to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifying <strong><c>null</c></strong> for this parameter expands the dirty region to cover the entire surface. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.DoNotWait"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p> You may not specify a subrect when using <see cref="SharpDX.Direct3D9.LockFlags.Discard"/>. For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>.</p><p>If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> or <see cref="SharpDX.Direct3D9.ResultCode.WasStillDrawing"/>.</p></returns>	
        /// <remarks>	
        /// <p>If the <see cref="SharpDX.Direct3D9.LockFlags.DoNotWait"/> flag is specified and the driver cannot lock the surface immediately, <strong><see cref="SharpDX.Direct3D9.Surface.LockRectangle"/></strong> will return <see cref="SharpDX.Direct3D9.ResultCode.WasStillDrawing"/> so that an application can use the CPU cycles while waiting for the driver to lock the surface.</p><p>The only lockable format for a depth-stencil surface is <see cref="SharpDX.Direct3D9.Format.D16Lockable"/>. See <see cref="SharpDX.Direct3D9.Format"/>.</p><p>For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when <strong><see cref="SharpDX.Direct3D9.Surface.LockRectangle"/></strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. See <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong> for more information.</p><p>A multisample back buffer cannot be locked.</p><p>This method cannot retrieve data from a surface that is is contained by a texture resource created with <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong> because such a texture must be assigned to <see cref="SharpDX.Direct3D9.Pool.Default"/> memory and is therefore not lockable. In this case, use instead <strong><see cref="SharpDX.Direct3D9.Device.GetRenderTargetData"/></strong> to copy texture data from device memory to system memory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9::LockRect']/*"/>	
        /// <msdn-id>bb205896</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSurface9::LockRect([Out] D3DLOCKED_RECT* pLockedRect,[In] const void* pRect,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DSurface9::LockRect</unmanaged-short>	
        internal void LockRectangle(out SharpDX.Direct3D9.LockedRectangle lockedRectRef, System.IntPtr rectRef, SharpDX.Direct3D9.LockFlags flags) {
            unsafe {
                lockedRectRef = new SharpDX.Direct3D9.LockedRectangle();
                SharpDX.Result __result__;
                fixed (void* lockedRectRef_ = &lockedRectRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, lockedRectRef_, (void*)rectRef, unchecked((int)flags),((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks a rectangle on a surface.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9::UnlockRect']/*"/>	
        /// <msdn-id>bb205898</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSurface9::UnlockRect()</unmanaged>	
        /// <unmanaged-short>IDirect3DSurface9::UnlockRect</unmanaged-short>	
        public void UnlockRectangle() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a device context.</p>	
        /// </summary>	
        /// <returns><dd>  <p>Pointer to the device context for the surface.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The following restrictions apply.</p><ul> <li><strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong> is valid on the following formats only: <see cref="SharpDX.Direct3D9.Format.R5G6B5"/>, <see cref="SharpDX.Direct3D9.Format.X1R5G5B5"/>, <see cref="SharpDX.Direct3D9.Format.R8G8B8"/>, and <see cref="SharpDX.Direct3D9.Format.X8R8G8B8"/>. Formats that contain Alpha are not supported because the GDI implementations don't have a well-defined behavior on the alpha channel. For more information about formats, see <see cref="SharpDX.Direct3D9.Format"/>.</li> <li>Only one device context per surface can be returned at a time.</li> <li><strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong> will fail if the surface is already locked. If the surface is a member of a mipmap or cubemap, <strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong> fails if any other mipmap or cubemap member is locked.</li> <li><strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong> fails on render targets unless they were created lockable (or, in the case of back buffers, with the <see cref="SharpDX.Direct3D9.PresentFlags.LockableBackBuffer"/> flag).</li> <li>For surfaces not created with <strong><see cref="SharpDX.Direct3D9.Device.CreateOffscreenPlainSurface"/></strong>, <strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong> will fail on default pool (<see cref="SharpDX.Direct3D9.Pool.Default"/>) surfaces unless they are dynamic (<see cref="SharpDX.Direct3D9.Usage.Dynamic"/>) or are lockable render targets.</li> <li><strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong> will fail on <see cref="SharpDX.Direct3D9.Pool.Scratch"/> surfaces.</li> </ul><p>When a device context is outstanding on a surface, the application may not call these methods:</p><table> <tr><td><see cref="SharpDX.Direct3D9.CubeTexture"/></td><td> <strong><see cref="SharpDX.Direct3D9.CubeTexture.LockRectangle"/></strong> </td></tr> <tr><td><see cref="SharpDX.Direct3D9.Device"/></td><td> <strong><see cref="SharpDX.Direct3D9.Device.ColorFill"/></strong> </td></tr> <tr><td></td><td> <strong><see cref="SharpDX.Direct3D9.Device.StretchRectangle"/></strong> </td></tr> <tr><td></td><td> <strong><see cref="SharpDX.Direct3D9.Device.UpdateSurface"/></strong> </td></tr> <tr><td></td><td> <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong> </td></tr> <tr><td><see cref="SharpDX.Direct3D9.Surface"/></td><td> <strong><see cref="SharpDX.Direct3D9.Surface.LockRectangle"/></strong> </td></tr> <tr><td><see cref="SharpDX.Direct3D9.SwapChain"/></td><td> <strong><see cref="SharpDX.Direct3D9.SwapChain.Present"/></strong> *</td></tr> <tr><td><see cref="SharpDX.Direct3D9.Texture"/></td><td> <strong><see cref="SharpDX.Direct3D9.Texture.LockRectangle"/></strong> </td></tr> </table><p>?</p><p>* (on a swap chain that contains the surface)</p><p><strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong> causes an implicit lock; do not retain the device context for later use. Call <strong><see cref="SharpDX.Direct3D9.Surface.ReleaseDC"/></strong> to release it.	</p><p>It is valid to call <strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong>/<strong><see cref="SharpDX.Direct3D9.Surface.ReleaseDC"/></strong> on levels of a mipmap or cubemap, however, these calls will be slow to all miplevels except the topmost level, and GDI operations to these miplevels will not be accelerated.</p><p>The hdc provides access to Win32 and GDI functionality.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9::GetDC']/*"/>	
        /// <msdn-id>bb205894</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSurface9::GetDC([Out] HDC* phdc)</unmanaged>	
        /// <unmanaged-short>IDirect3DSurface9::GetDC</unmanaged-short>	
        public System.IntPtr GetDC() {
            unsafe {
                System.IntPtr hdcRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &hdcRef,((void**)(*(void**)_nativePointer))[15]);		
                __result__.CheckError();
                return hdcRef;
            }
        }
        
        /// <summary>	
        /// <p>Release a device context handle.</p>	
        /// </summary>	
        /// <param name="hdc"><dd>  <p>Handle to a device context.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the argument is invalid.</p></returns>	
        /// <remarks>	
        /// <p>An hdc is a Windows resource. It must be released after use so Windows can return it to the pool of available resources.</p><p>This method will release only the device context returned by <strong><see cref="SharpDX.Direct3D9.Surface.GetDC"/></strong>. Otherwise, this method will fail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSurface9::ReleaseDC']/*"/>	
        /// <msdn-id>bb205897</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSurface9::ReleaseDC([In] HDC hdc)</unmanaged>	
        /// <unmanaged-short>IDirect3DSurface9::ReleaseDC</unmanaged-short>	
        public void ReleaseDC(System.IntPtr hdc) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)hdc,((void**)(*(void**)_nativePointer))[16]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Presents the contents of the next buffer in the sequence of back buffers owned by the swap chain.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong>Present</strong> method is a shortcut to Present. Present has been updated to take a flag allowing the application to request that the method return immediately when the driver reports that it cannot schedule a presentation.</p><p>If necessary, a stretch operation is applied to transfer the pixels within the source rectangle to the destination rectangle in the client area of the target window.</p><p>Present will fail if called between <strong>BeginScene</strong> and <strong>EndScene</strong> pairs unless the render target is not the current render target (such as the back buffer you get from creating an additional swap chain). This is a new behavior for Direct3D 9.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9']/*"/>	
    /// <msdn-id>bb205908</msdn-id>	
    /// <unmanaged>IDirect3DSwapChain9</unmanaged>	
    /// <unmanaged-short>IDirect3DSwapChain9</unmanaged-short>	
    [Guid("794950F2-ADFC-458a-905E-10A10B0B503B")]
    public partial class SwapChain : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.SwapChain"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SwapChain(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.SwapChain"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.SwapChain(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.SwapChain(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns information describing the raster of the monitor on which the swap chain is presented.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetRasterStatus']/*"/>	
        /// <msdn-id>bb205907</msdn-id>	
        /// <unmanaged>GetRasterStatus</unmanaged>	
        /// <unmanaged-short>GetRasterStatus</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetRasterStatus([Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>
        public SharpDX.Direct3D9.RasterStatus RasterStatus {
                get { SharpDX.Direct3D9.RasterStatus __output__; GetRasterStatus(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetDisplayMode']/*"/>	
        /// <msdn-id>bb205904</msdn-id>	
        /// <unmanaged>GetDisplayMode</unmanaged>	
        /// <unmanaged-short>GetDisplayMode</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDisplayMode([Out] D3DDISPLAYMODE* pMode)</unmanaged>
        public SharpDX.Direct3D9.DisplayMode DisplayMode {
                get { SharpDX.Direct3D9.DisplayMode __output__; GetDisplayMode(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with the swap chain.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method allows navigation to the owning device object.</p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetDevice']/*"/>	
        /// <msdn-id>bb205903</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the presentation parameters associated with a swap chain.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method can be used to see the presentation parameters of the parent swap chain of a surface (a back buffer, for instance). The parent swap chain can be retrieved with <strong><see cref="SharpDX.Direct3D9.Surface.GetContainer"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetPresentParameters']/*"/>	
        /// <msdn-id>bb205906</msdn-id>	
        /// <unmanaged>GetPresentParameters</unmanaged>	
        /// <unmanaged-short>GetPresentParameters</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetPresentParameters([Out] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>
        public SharpDX.Direct3D9.PresentParameters PresentParameters {
                get { SharpDX.Direct3D9.PresentParameters __output__; GetPresentParameters(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Presents the contents of the next buffer in the sequence of back buffers owned by the swap chain.</p>	
        /// </summary>	
        /// <param name="sourceRectRef"><dd>  <p>Pointer to the source rectangle (see <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong>). Use <strong><c>null</c></strong> to present the entire surface. This value must be <strong><c>null</c></strong> unless the swap chain was created with <see cref="SharpDX.Direct3D9.SwapEffect.Copy"/>. If the rectangle exceeds the source surface, the rectangle is clipped to the source surface. </p> </dd></param>	
        /// <param name="destRectRef"><dd>  <p>Pointer to the destination rectangle in client coordinates (see <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong>). This value must be <strong><c>null</c></strong> unless the swap chain was created with <see cref="SharpDX.Direct3D9.SwapEffect.Copy"/>. Use <strong><c>null</c></strong> to fill the entire client area. If the rectangle exceeds the destination client area, the rectangle is clipped to the destination client area. </p> </dd></param>	
        /// <param name="hDestWindowOverride"><dd>  <p>Destination window whose client area is taken as the target for this presentation. If this value is <strong><c>null</c></strong>, the runtime uses the <strong>hDeviceWindow</strong> member of <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong> for the presentation. </p> </dd></param>	
        /// <param name="dirtyRegionRef"><dd>  <p>This value must be <strong><c>null</c></strong> unless the swap chain was created with <strong><see cref="SharpDX.Direct3D9.SwapEffect.Copy"/></strong>. See Flipping Surfaces (Direct3D 9). If this value is non-<strong><c>null</c></strong>, the contained region is expressed in back buffer coordinates. The rectangles within the region are the minimal set of pixels that need to be updated. This method takes these rectangles into account when optimizing the presentation by copying only the pixels within the region, or some suitably expanded set of rectangles. This is an aid to optimization only, and the application should not rely on the region being copied exactly. The implementation may choose to copy the whole source rectangle.</p> </dd></param>	
        /// <param name="dwFlags"><dd>  <p>Allows the application to request that the method return immediately when the driver reports that it cannot schedule a presentation. Valid values are 0, or any combination of <see cref="SharpDX.Direct3D9.Present.DoNotWait"/> or <see cref="SharpDX.Direct3D9.Present.LinearContent"/>. </p> <ul> <li>If dwFlags = 0, this method behaves as it did prior to Direct3D 9. Present will spin until the hardware is free, without returning an error.</li> <li>If dwFlags = <see cref="SharpDX.Direct3D9.Present.DoNotWait"/>, and the hardware is busy processing or waiting for a vertical sync interval, the method will return <see cref="SharpDX.Direct3D9.ResultCode.WasStillDrawing"/>.</li> <li>If dwFlags = <see cref="SharpDX.Direct3D9.Present.LinearContent"/>, gamma correction is performed from linear space to sRGB for windowed swap chains. This flag will take effect only when the driver exposes <see cref="SharpDX.Direct3D9.Caps3.LinearToSrgbPresentation"/> (see Gamma (Direct3D 9)). Appliations should specify this flag if the backbuffer format is 16-bit floating point in order to match windowed mode present to fullscreen gamma behavior.</li> </ul> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.DeviceLost"/>, <see cref="SharpDX.Direct3D9.ResultCode.DriverInternalError"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The <strong>Present</strong> method is a shortcut to Present. Present has been updated to take a flag allowing the application to request that the method return immediately when the driver reports that it cannot schedule a presentation.</p><p>If necessary, a stretch operation is applied to transfer the pixels within the source rectangle to the destination rectangle in the client area of the target window.</p><p>Present will fail if called between <strong>BeginScene</strong> and <strong>EndScene</strong> pairs unless the render target is not the current render target (such as the back buffer you get from creating an additional swap chain). This is a new behavior for Direct3D 9.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::Present']/*"/>	
        /// <msdn-id>bb205908</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::Present([In, Optional] const void* pSourceRect,[InOut, Optional] const void* pDestRect,[In] HWND hDestWindowOverride,[In] const RGNDATA* pDirtyRegion,[In] unsigned int dwFlags)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9::Present</unmanaged-short>	
        internal void Present(System.IntPtr sourceRectRef, System.IntPtr destRectRef, System.IntPtr hDestWindowOverride, System.IntPtr dirtyRegionRef, int dwFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)sourceRectRef, (void*)destRectRef, (void*)hDestWindowOverride, (void*)dirtyRegionRef, dwFlags,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generates a copy of the swapchain's front buffer and places that copy in a system memory buffer provided by the application.</p>	
        /// </summary>	
        /// <param name="destSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface that will receive a copy of the swapchain's front buffer. The data is returned in successive rows with no intervening space, starting from the vertically highest row to the lowest.  For windowed mode, the size of the destination surface should be the size of the desktop. For full screen mode, the size of the destination surface should be the screen size. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If BackBuffer exceeds or equals the total number of back buffers, the function fails and returns <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.  </p></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetFrontBufferData']/*"/>	
        /// <msdn-id>bb205905</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetFrontBufferData([In] IDirect3DSurface9* pDestSurface)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9::GetFrontBufferData</unmanaged-short>	
        public void GetFrontBufferData(SharpDX.Direct3D9.Surface destSurfaceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a back buffer from the swap chain of the device.</p>	
        /// </summary>	
        /// <param name="iBackBuffer"><dd>  <p>Index of the back buffer object to return. Back buffers are numbered from 0 to the total number of back buffers - 1. A value of 0 returns the first back buffer, not the front buffer. The front buffer is not accessible through this method. Use <strong><see cref="SharpDX.Direct3D9.SwapChain.GetFrontBufferData"/></strong> to retrieve a copy of the front buffer.</p> </dd></param>	
        /// <param name="type"><dd>  <p>Stereo view is not supported in Direct3D 9, so the only valid value for this parameter is <see cref="SharpDX.Direct3D9.BackBufferType.Mono"/>. </p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the returned back buffer surface. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak. You must release any surfaces obtained through this method before releasing the swap chain it belongs to.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetBackBuffer']/*"/>	
        /// <msdn-id>bb205902</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetBackBuffer([In] unsigned int iBackBuffer,[In] D3DBACKBUFFER_TYPE Type,[Out] IDirect3DSurface9** ppBackBuffer)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9::GetBackBuffer</unmanaged-short>	
        internal SharpDX.Direct3D9.Surface GetBackBuffer(int iBackBuffer, SharpDX.Direct3D9.BackBufferType type) {
            unsafe {
                SharpDX.Direct3D9.Surface backBufferOut;
                IntPtr backBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, iBackBuffer, unchecked((int)type), &backBufferOut_,((void**)(*(void**)_nativePointer))[5]);		
                backBufferOut= (backBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(backBufferOut_);	
                __result__.CheckError();
                return backBufferOut;
            }
        }
        
        /// <summary>	
        /// <p>Returns information describing the raster of the monitor on which the swap chain is presented.</p>	
        /// </summary>	
        /// <param name="rasterStatusRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.RasterStatus"/></strong> structure filled with information about the position or other status of the raster on the monitor driven by this adapter. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if pRasterStatus is invalid or if the device does not support reading the current scan line. To determine if the device supports reading the scan line, check for the <see cref="SharpDX.Direct3D9.Caps.ReadScanline"/> flag in the Caps member of <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetRasterStatus']/*"/>	
        /// <msdn-id>bb205907</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetRasterStatus([Out] D3DRASTER_STATUS* pRasterStatus)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9::GetRasterStatus</unmanaged-short>	
        internal void GetRasterStatus(out SharpDX.Direct3D9.RasterStatus rasterStatusRef) {
            unsafe {
                rasterStatusRef = new SharpDX.Direct3D9.RasterStatus();
                SharpDX.Result __result__;
                fixed (void* rasterStatusRef_ = &rasterStatusRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, rasterStatusRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.</p>	
        /// </summary>	
        /// <param name="modeRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayMode"/></strong> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetDisplayMode']/*"/>	
        /// <msdn-id>bb205904</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDisplayMode([Out] D3DDISPLAYMODE* pMode)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9::GetDisplayMode</unmanaged-short>	
        internal void GetDisplayMode(out SharpDX.Direct3D9.DisplayMode modeRef) {
            unsafe {
                modeRef = new SharpDX.Direct3D9.DisplayMode();
                SharpDX.Result __result__;
                fixed (void* modeRef_ = &modeRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, modeRef_,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with the swap chain.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface to fill with the device reference, if the query succeeds. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method allows navigation to the owning device object.</p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetDevice']/*"/>	
        /// <msdn-id>bb205903</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[8]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the presentation parameters associated with a swap chain.</p>	
        /// </summary>	
        /// <param name="presentationParametersRef"><dd>  <p>Pointer to the presentation parameters. See <strong><see cref="SharpDX.Direct3D9.PresentParameters"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method can be used to see the presentation parameters of the parent swap chain of a surface (a back buffer, for instance). The parent swap chain can be retrieved with <strong><see cref="SharpDX.Direct3D9.Surface.GetContainer"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9::GetPresentParameters']/*"/>	
        /// <msdn-id>bb205906</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9::GetPresentParameters([Out] D3DPRESENT_PARAMETERS* pPresentationParameters)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9::GetPresentParameters</unmanaged-short>	
        internal void GetPresentParameters(out SharpDX.Direct3D9.PresentParameters presentationParametersRef) {
            unsafe {
                presentationParametersRef = new SharpDX.Direct3D9.PresentParameters();
                SharpDX.Result __result__;
                fixed (void* presentationParametersRef_ = &presentationParametersRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, presentationParametersRef_,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <strong><see cref="SharpDX.Direct3D9.SwapChain9Ex"/></strong> interface to manipulate a swap chain.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>There is always at least one swap chain for each device, known as the implicit swap chain. However, an additional swap chain for rendering multiple views from the same device can be created by calling the <strong>CreateAdditionalSwapChain</strong> method.</p><p>This interface, like all COM interfaces, inherits from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The <strong>LPDIRECT3DSWAPCHAIN9</strong> and <strong>PDIRECT3DSWAPCHAIN9</strong> types are defined as references to the <strong><see cref="SharpDX.Direct3D9.SwapChain"/></strong> interface.</p><p><strong><see cref="SharpDX.Direct3D9.SwapChain9Ex"/></strong> objects are returned as a reference to an <strong><see cref="SharpDX.Direct3D9.SwapChain"/></strong> object when <strong>GetSwapChain</strong> is called on an instance of <strong><see cref="SharpDX.Direct3D9.DeviceEx"/></strong>.	
    /// The <strong><see cref="SharpDX.Direct3D9.SwapChain9Ex"/></strong> interface is obtained by calling <strong>QueryInterface</strong> on the instance of <strong><see cref="SharpDX.Direct3D9.SwapChain"/></strong> that was returned by <strong>GetSwapChain</strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9Ex']/*"/>	
    /// <msdn-id>bb172503</msdn-id>	
    /// <unmanaged>IDirect3DSwapChain9Ex</unmanaged>	
    /// <unmanaged-short>IDirect3DSwapChain9Ex</unmanaged-short>	
    [Guid("91886CAF-1C3D-4d2e-A0AB-3E4C7D8D3303")]
    public partial class SwapChain9Ex : SharpDX.Direct3D9.SwapChain {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.SwapChain9Ex"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public SwapChain9Ex(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.SwapChain9Ex"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.SwapChain9Ex(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.SwapChain9Ex(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Returns the number of times the swapchain has been processed.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9Ex::GetLastPresentCount']/*"/>	
        /// <msdn-id>bb205900</msdn-id>	
        /// <unmanaged>GetLastPresentCount</unmanaged>	
        /// <unmanaged-short>GetLastPresentCount</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetLastPresentCount([Out] unsigned int* pLastPresentCount)</unmanaged>
        public int LastPresentCount {
                get { int __output__; GetLastPresentCount(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9Ex::GetPresentStats']/*"/>	
        /// <unmanaged>GetPresentStats</unmanaged>	
        /// <unmanaged-short>GetPresentStats</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetPresentStats([Out] D3DPRESENTSTATS* pPresentationStatistics)</unmanaged>
        public SharpDX.Direct3D9.PresentationStatistics PresentStats {
                get { SharpDX.Direct3D9.PresentationStatistics __output__; GetPresentStats(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Returns the number of times the swapchain has been processed.</p>	
        /// </summary>	
        /// <param name="lastPresentCountRef"><dd>  <p>Pointer to a UINT to be filled with the number of times the <strong><see cref="SharpDX.Direct3D9.DeviceEx.PresentEx"/></strong> method has been called. The count will also be incremented by calling some other APIs such as <strong><see cref="SharpDX.Direct3D9.Device.SetDialogBoxMode"/></strong>.</p> </dd></param>	
        /// <returns><p><see cref="SharpDX.Result.Ok"/> the method was successful.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9Ex::GetLastPresentCount']/*"/>	
        /// <msdn-id>bb205900</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetLastPresentCount([Out] unsigned int* pLastPresentCount)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9Ex::GetLastPresentCount</unmanaged-short>	
        internal void GetLastPresentCount(out int lastPresentCountRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* lastPresentCountRef_ = &lastPresentCountRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, lastPresentCountRef_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="presentationStatisticsRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9Ex::GetPresentStats']/*"/>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetPresentStats([Out] D3DPRESENTSTATS* pPresentationStatistics)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9Ex::GetPresentStats</unmanaged-short>	
        internal void GetPresentStats(out SharpDX.Direct3D9.PresentationStatistics presentationStatisticsRef) {
            unsafe {
                presentationStatisticsRef = new SharpDX.Direct3D9.PresentationStatistics();
                SharpDX.Result __result__;
                fixed (void* presentationStatisticsRef_ = &presentationStatisticsRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, presentationStatisticsRef_,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the display mode's spatial resolution, color resolution, refresh frequency, and rotation settings.</p>	
        /// </summary>	
        /// <param name="modeRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayModeEx"/></strong> structure containing data about the display mode of the adapter. As opposed to the display mode of the device, which may not be active if the device does not own full-screen mode. </p> </dd></param>	
        /// <param name="rotationRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.DisplayRotation"/></strong> indicating the type of screen rotation the application will do. The value returned through this reference is important when the <see cref="SharpDX.Direct3D9.PresentFlags.NoAutoRotate"/> flag is used; otherwise, it can be set to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DSwapChain9Ex::GetDisplayModeEx']/*"/>	
        /// <msdn-id>bb509715</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DSwapChain9Ex::GetDisplayModeEx([Out] D3DDISPLAYMODEEX* pMode,[Out] D3DDISPLAYROTATION* pRotation)</unmanaged>	
        /// <unmanaged-short>IDirect3DSwapChain9Ex::GetDisplayModeEx</unmanaged-short>	
        public void GetDisplayModeEx(out SharpDX.Direct3D9.DisplayModeEx modeRef, out SharpDX.Direct3D9.DisplayRotation rotationRef) {
            unsafe {
                var modeRef_ = SharpDX.Direct3D9.DisplayModeEx.__NewNative();
                SharpDX.Result __result__;
                fixed (void* rotationRef_ = &rotationRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &modeRef_, rotationRef_,((void**)(*(void**)_nativePointer))[12]);		
                modeRef = new SharpDX.Direct3D9.DisplayModeEx();
                modeRef.__MarshalFrom(ref modeRef_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.Texture"/> interface to manipulate a texture resource.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface can be obtained by calling the <strong><see cref="SharpDX.Direct3D9.Device.CreateTexture"/></strong> method or one of the <see cref="SharpDX.Direct3D9.D3DX9.CreateTexture"/><em>xxx</em> functions.</p><p>This interface inherits additional functionality from the <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface.</p><p>This interface, like all COM interfaces, inherits from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPDIRECT3DTEXTURE9 and PDIRECT3DTEXTURE9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.Texture"/> *LPDIRECT3DTEXTURE9, *PDIRECT3DTEXTURE9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DTexture9']/*"/>	
    /// <msdn-id>bb205909</msdn-id>	
    /// <unmanaged>IDirect3DTexture9</unmanaged>	
    /// <unmanaged-short>IDirect3DTexture9</unmanaged-short>	
    [Guid("85C31227-3DE5-4f00-9B3A-F11AC38C18B5")]
    public partial class Texture : SharpDX.Direct3D9.BaseTexture {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Texture"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Texture(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Texture"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Texture(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Texture(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a level description of a texture resource.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Identifies a level of the texture resource. This method returns a surface description for the level specified by this parameter. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.SurfaceDescription"/></strong> structure, describing the returned level. </p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DTexture9::GetLevelDesc']/*"/>	
        /// <msdn-id>bb205911</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DTexture9::GetLevelDesc([In] unsigned int Level,[Out] D3DSURFACE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>IDirect3DTexture9::GetLevelDesc</unmanaged-short>	
        public SharpDX.Direct3D9.SurfaceDescription GetLevelDescription(int level) {
            unsafe {
                SharpDX.Direct3D9.SurfaceDescription descRef;
                descRef = new SharpDX.Direct3D9.SurfaceDescription();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level, &descRef,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the specified texture surface level.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Identifies a level of the texture resource. This method returns a surface for the level specified by this parameter. The top-level surface is denoted by 0. </p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the returned surface. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DTexture9::GetSurfaceLevel']/*"/>	
        /// <msdn-id>bb205912</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DTexture9::GetSurfaceLevel([In] unsigned int Level,[Out] IDirect3DSurface9** ppSurfaceLevel)</unmanaged>	
        /// <unmanaged-short>IDirect3DTexture9::GetSurfaceLevel</unmanaged-short>	
        public SharpDX.Direct3D9.Surface GetSurfaceLevel(int level) {
            unsafe {
                SharpDX.Direct3D9.Surface surfaceLevelOut;
                IntPtr surfaceLevelOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level, &surfaceLevelOut_,((void**)(*(void**)_nativePointer))[18]);		
                surfaceLevelOut= (surfaceLevelOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Surface(surfaceLevelOut_);	
                __result__.CheckError();
                return surfaceLevelOut;
            }
        }
        
        /// <summary>	
        /// <p>Locks a rectangle on a texture resource.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Specifies the level of the texture resource to lock. </p> </dd></param>	
        /// <param name="lockedRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.LockedRectangle"/></strong> structure, describing the locked region. </p> </dd></param>	
        /// <param name="rectRef"><dd>  <p>Pointer to a rectangle to lock. Specified by a reference to a <see cref="SharpDX.Mathematics.Interop.RawRectangle"/> structure. Specifying <strong><c>null</c></strong> for this parameter expands the dirty region to cover the entire texture. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p> You may not specify a subrect when using <see cref="SharpDX.Direct3D9.LockFlags.Discard"/>. For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>Textures created with <see cref="SharpDX.Direct3D9.Pool.Default"/> are not lockable. Textures created in video memory are lockable when created with <strong>USAGE_DYNAMIC</strong>.</p><p>For performance reasons, dirty regions are recorded only for level zero of a texture. Dirty regions are automatically recorded when <strong><see cref="SharpDX.Direct3D9.Texture.LockRectangle"/></strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. See <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong> for more information.</p><p>The only lockable format for a depth-stencil texture is D3DLOCK_D16_LOCKABLE.</p><p>Video memory textures cannot be locked, but must be modified by calling <strong><see cref="SharpDX.Direct3D9.Device.UpdateSurface"/></strong> or <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong>. There are exceptions for some proprietary driver pixel formats that Direct3D 9 does not recognize. These can be locked.</p><p>This method cannot retrieve data from a texture resource created with <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong> because such a texture must be assigned to <see cref="SharpDX.Direct3D9.Pool.Default"/> memory and is therefore not lockable. In this case, use instead <strong><see cref="SharpDX.Direct3D9.Device.GetRenderTargetData"/></strong> to copy texture data from device memory to system memory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DTexture9::LockRect']/*"/>	
        /// <msdn-id>bb205913</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DTexture9::LockRect([In] unsigned int Level,[Out] D3DLOCKED_RECT* pLockedRect,[In] const void* pRect,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DTexture9::LockRect</unmanaged-short>	
        internal void LockRectangle(int level, out SharpDX.Direct3D9.LockedRectangle lockedRectRef, System.IntPtr rectRef, SharpDX.Direct3D9.LockFlags flags) {
            unsafe {
                lockedRectRef = new SharpDX.Direct3D9.LockedRectangle();
                SharpDX.Result __result__;
                fixed (void* lockedRectRef_ = &lockedRectRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level, lockedRectRef_, (void*)rectRef, unchecked((int)flags),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks a rectangle on a texture resource.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Specifies the level of the texture resource to unlock. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DTexture9::UnlockRect']/*"/>	
        /// <msdn-id>bb205914</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DTexture9::UnlockRect([In] unsigned int Level)</unmanaged>	
        /// <unmanaged-short>IDirect3DTexture9::UnlockRect</unmanaged-short>	
        public void UnlockRectangle(int level) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a dirty region to a texture resource.</p>	
        /// </summary>	
        /// <param name="dirtyRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure, specifying the dirty region to add. Specifying <strong><c>null</c></strong> expands the dirty region to cover the entire texture. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) rectangle or box is also dirty. Dirty regions are automatically recorded when <strong><see cref="SharpDX.Direct3D9.Texture.LockRectangle"/></strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. The destination surface of <strong><see cref="SharpDX.Direct3D9.Device.UpdateSurface"/></strong> is also marked dirty automatically.</p><p>Using <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> and explicitly specifying dirty regions can be used to increase the efficiency of <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong>. Using this method, applications can optimize what subset of a resource is copied by specifying dirty regions on the resource. However, the dirty regions may be expanded to optimize alignment.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DTexture9::AddDirtyRect']/*"/>	
        /// <msdn-id>bb205910</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DTexture9::AddDirtyRect([In] const void* pDirtyRect)</unmanaged>	
        /// <unmanaged-short>IDirect3DTexture9::AddDirtyRect</unmanaged-short>	
        internal void AddDirtyRectangle(System.IntPtr dirtyRectRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)dirtyRectRef,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D9.TextureShader"/> interface.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.TextureShader"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateTextureShader"/></strong> function.</p><p>The <strong><see cref="SharpDX.Direct3D9.TextureShader"/></strong> interface, like all COM interfaces, inherits the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPD3DXTEXTURESHADER type is defined as a reference to the <strong><see cref="SharpDX.Direct3D9.TextureShader"/></strong> interface. </p><pre> typedef interface <see cref="SharpDX.Direct3D9.TextureShader"/> *LPD3DXTEXTURESHADER;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader']/*"/>	
    /// <msdn-id>bb174276</msdn-id>	
    /// <unmanaged>ID3DXTextureShader</unmanaged>	
    /// <unmanaged-short>ID3DXTextureShader</unmanaged-short>	
    [Guid("3e3d67f8-aa7a-405d-a857-ba01d4758426")]
    public partial class TextureShader : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.TextureShader"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public TextureShader(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.TextureShader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.TextureShader(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.TextureShader(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets a reference to the function DWORD stream.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetFunction']/*"/>	
        /// <msdn-id>bb174283</msdn-id>	
        /// <unmanaged>GetFunction</unmanaged>	
        /// <unmanaged-short>GetFunction</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetFunction([Out] ID3DXBuffer** ppFunction)</unmanaged>
        public SharpDX.Direct3D.Blob Function {
                get { SharpDX.Direct3D.Blob __output__; GetFunction(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a reference to the constant table.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetConstantBuffer']/*"/>	
        /// <msdn-id>bb174278</msdn-id>	
        /// <unmanaged>GetConstantBuffer</unmanaged>	
        /// <unmanaged-short>GetConstantBuffer</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetConstantBuffer([Out] ID3DXBuffer** ppConstantBuffer)</unmanaged>
        public SharpDX.Direct3D.Blob ConstantBuffer {
                get { SharpDX.Direct3D.Blob __output__; GetConstantBuffer(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets a description of the constant table.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetDesc']/*"/>	
        /// <msdn-id>bb174282</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.ConstantTableDescription Description {
                get { SharpDX.Direct3D9.ConstantTableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets a reference to the function DWORD stream.</p>	
        /// </summary>	
        /// <param name="functionOut"><dd>  <p>A reference to the function DWORD stream. See <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetFunction']/*"/>	
        /// <msdn-id>bb174283</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetFunction([Out] ID3DXBuffer** ppFunction)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::GetFunction</unmanaged-short>	
        internal void GetFunction(out SharpDX.Direct3D.Blob functionOut) {
            unsafe {
                IntPtr functionOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &functionOut_,((void**)(*(void**)_nativePointer))[3]);		
                functionOut= (functionOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(functionOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a reference to the constant table.</p>	
        /// </summary>	
        /// <param name="constantBufferOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which contains the constants.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetConstantBuffer']/*"/>	
        /// <msdn-id>bb174278</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetConstantBuffer([Out] ID3DXBuffer** ppConstantBuffer)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::GetConstantBuffer</unmanaged-short>	
        internal void GetConstantBuffer(out SharpDX.Direct3D.Blob constantBufferOut) {
            unsafe {
                IntPtr constantBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &constantBufferOut_,((void**)(*(void**)_nativePointer))[4]);		
                constantBufferOut= (constantBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(constantBufferOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a description of the constant table.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>The attributes of the constant table. See <strong><see cref="SharpDX.Direct3D9.ConstantTableDescription"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetDesc']/*"/>	
        /// <msdn-id>bb174282</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetDesc([Out] D3DXCONSTANTTABLE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.ConstantTableDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D9.ConstantTableDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[5]);		
                descRef = new SharpDX.Direct3D9.ConstantTableDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a reference to the array of constants in the constant table.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to a constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="constantDescRef"><dd>  <p>Returns a reference to an array of descriptions. See <strong><see cref="SharpDX.Direct3D9.ConstantDescription"/></strong>.</p> </dd></param>	
        /// <param name="countRef"><dd>  <p>The input supplied must be the maximum size of the array. The output is the number of elements that are filled in the array when the function returns.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>Samplers can appear more than once in a constant table, therefore, this method can return an array of descriptions each with a different register index.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetConstantDesc']/*"/>	
        /// <msdn-id>bb174280</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::GetConstantDesc([In] D3DXHANDLE hConstant,[Out, Buffer] D3DXCONSTANT_DESC* pConstantDesc,[InOut] unsigned int* pCount)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::GetConstantDesc</unmanaged-short>	
        internal void GetConstantDescription(SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Direct3D9.ConstantDescription[] constantDescRef, ref int countRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Direct3D9.ConstantDescription.__Native[] constantDescRef__ = new SharpDX.Direct3D9.ConstantDescription.__Native[constantDescRef.Length];
                SharpDX.Result __result__;
                fixed (void* constantDescRef_ = constantDescRef__)
                    fixed (void* countRef_ = &countRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, constantDescRef_, countRef_,((void**)(*(void**)_nativePointer))[6]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                for (int i = 0; i < constantDescRef.Length; i++)
                    constantDescRef[i].__MarshalFrom(ref constantDescRef__[i]);				
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a constant by looking up its index.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>A handle to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="index"><dd>  <p>Zero-based index of the constant.</p> </dd></param>	
        /// <returns><p>Returns a unique identifier to the constant.</p></returns>	
        /// <remarks>	
        /// <p>To get a constant from an array of constants, use <strong><see cref="SharpDX.Direct3D9.TextureShader.GetConstantElement"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetConstant']/*"/>	
        /// <msdn-id>bb174277</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXTextureShader::GetConstant([In] D3DXHANDLE hConstant,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::GetConstant</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetConstant(SharpDX.Direct3D9.EffectHandle effectHandle, int index) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, effectHandle_, index,((void**)(*(void**)_nativePointer))[7]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Gets a constant by looking up its name.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>A handle to the parent data structure. If the constant is a top-level parameter (there is no parent data structure), use <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="nameRef"><dd>  <p>A string containing the name of the constant.</p> </dd></param>	
        /// <returns><p>Returns a unique identifier to the constant.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetConstantByName']/*"/>	
        /// <msdn-id>bb174279</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXTextureShader::GetConstantByName([In] D3DXHANDLE hConstant,[In] const char* pName)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::GetConstantByName</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetConstantByName(SharpDX.Direct3D9.EffectHandle effectHandle, string nameRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, effectHandle_, (void*)nameRef_,((void**)(*(void**)_nativePointer))[8]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                Marshal.FreeHGlobal(nameRef_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a constant from the constant table.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>A handle to the array of constants.  This value may not be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="index"><dd>  <p>Zero-based index of the element in the constant table.</p> </dd></param>	
        /// <returns><p>Returns a unique identifier to the constant.</p></returns>	
        /// <remarks>	
        /// <p>To get a constant that is not part of an array, use <strong><see cref="SharpDX.Direct3D9.TextureShader.GetConstant"/></strong> or <strong><see cref="SharpDX.Direct3D9.TextureShader.GetConstantByName"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::GetConstantElement']/*"/>	
        /// <msdn-id>bb174281</msdn-id>	
        /// <unmanaged>D3DXHANDLE ID3DXTextureShader::GetConstantElement([In] D3DXHANDLE hConstant,[In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::GetConstantElement</unmanaged-short>	
        public SharpDX.Direct3D9.EffectHandle GetConstantElement(SharpDX.Direct3D9.EffectHandle effectHandle, int index) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Direct3D9.EffectHandle __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CallivoidPtr(_nativePointer, effectHandle_, index,((void**)(*(void**)_nativePointer))[9]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Sets the constants to the default values declared in the shader.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetDefaults']/*"/>	
        /// <msdn-id>bb174286</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetDefaults()</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetDefaults</unmanaged-short>	
        public void SetDefaults() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets the constant table with the data in the buffer.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to a constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>A reference to a buffer containing the constant data.</p> </dd></param>	
        /// <param name="bytes"><dd>  <p>Size of the buffer, in bytes.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetValue']/*"/>	
        /// <msdn-id>bb174297</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetValue([In] D3DXHANDLE hConstant,[In] const void* pData,[In] unsigned int Bytes)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetValue</unmanaged-short>	
        public void SetValue(SharpDX.Direct3D9.EffectHandle effectHandle, System.IntPtr dataRef, int bytes) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, (void*)dataRef, bytes,((void**)(*(void**)_nativePointer))[11]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a <see cref="SharpDX.Mathematics.Interop.RawBool"/> value.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="b"><dd>  <p><see cref="SharpDX.Mathematics.Interop.RawBool"/> value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetBool']/*"/>	
        /// <msdn-id>bb174284</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetBool([In] D3DXHANDLE hConstant,[In] BOOL b)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetBool</unmanaged-short>	
        public void SetBool(SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawBool b) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint85(_nativePointer, effectHandle_, b,((void**)(*(void**)_nativePointer))[12]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of <see cref="SharpDX.Mathematics.Interop.RawBool"/> values.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="bRef"><dd>  <p>Array of <see cref="SharpDX.Mathematics.Interop.RawBool"/> values.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of <see cref="SharpDX.Mathematics.Interop.RawBool"/> values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetBoolArray']/*"/>	
        /// <msdn-id>bb174285</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetBoolArray([In] D3DXHANDLE hConstant,[In] const BOOL* pb,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetBoolArray</unmanaged-short>	
        public void SetBoolArray(SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawBool bRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, &bRef, count,((void**)(*(void**)_nativePointer))[13]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an integer value.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="n"><dd>  <p>Integer value.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetInt']/*"/>	
        /// <msdn-id>bb174289</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetInt([In] D3DXHANDLE hConstant,[In] int n)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetInt</unmanaged-short>	
        public void SetInt(SharpDX.Direct3D9.EffectHandle effectHandle, int n) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, n,((void**)(*(void**)_nativePointer))[14]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of integers.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="nRef"><dd>  <p>Array of integers.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of integers in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetIntArray']/*"/>	
        /// <msdn-id>bb174290</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetIntArray([In] D3DXHANDLE hConstant,[In] const int* pn,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetIntArray</unmanaged-short>	
        public void SetIntArray(SharpDX.Direct3D9.EffectHandle effectHandle, int nRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, &nRef, count,((void**)(*(void**)_nativePointer))[15]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a floating-point number.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="f"><dd>  <p>Floating-point number.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetFloat']/*"/>	
        /// <msdn-id>bb174287</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetFloat([In] D3DXHANDLE hConstant,[In] float f)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetFloat</unmanaged-short>	
        public void SetFloat(SharpDX.Direct3D9.EffectHandle effectHandle, float f) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, f,((void**)(*(void**)_nativePointer))[16]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of floating-point numbers.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="fRef"><dd>  <p>Array of floating-point numbers.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of floating-point values in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetFloatArray']/*"/>	
        /// <msdn-id>bb174288</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetFloatArray([In] D3DXHANDLE hConstant,[In] const float* pf,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetFloatArray</unmanaged-short>	
        public void SetFloatArray(SharpDX.Direct3D9.EffectHandle effectHandle, float fRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, &fRef, count,((void**)(*(void**)_nativePointer))[17]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a 4D vector.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the vector constant. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Pointer to a 4D vector. See <strong><see cref="SharpDX.Mathematics.Interop.RawVector4"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetVector']/*"/>	
        /// <msdn-id>bb174298</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetVector([In] D3DXHANDLE hConstant,[In] const D3DXVECTOR4* pVector)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetVector</unmanaged-short>	
        public void SetVector(SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawVector4 vectorRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, &vectorRef,((void**)(*(void**)_nativePointer))[18]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of 4D vectors.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of vector constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="vectorRef"><dd>  <p>Array of 4D vectors. See <strong><see cref="SharpDX.Mathematics.Interop.RawVector4"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of vectors in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetVectorArray']/*"/>	
        /// <msdn-id>bb174299</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetVectorArray([In] D3DXHANDLE hConstant,[In] const D3DXVECTOR4* pVector,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetVectorArray</unmanaged-short>	
        public void SetVectorArray(SharpDX.Direct3D9.EffectHandle effectHandle, SharpDX.Mathematics.Interop.RawVector4 vectorRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, &vectorRef, count,((void**)(*(void**)_nativePointer))[19]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a non-transposed matrix.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the matrix of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a non-transposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A non-transposed matrix contains row-major data; that is, each vector is contained in a row.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetMatrix']/*"/>	
        /// <msdn-id>bb174291</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrix([In] D3DXHANDLE hConstant,[In] const D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetMatrix</unmanaged-short>	
        public void SetMatrix(SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, matrixRef_,((void**)(*(void**)_nativePointer))[20]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of non-transposed matrices.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of constant matrices. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Array of non-transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A non-transposed matrix contains row-major data; that is, each vector is contained in a row.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetMatrixArray']/*"/>	
        /// <msdn-id>bb174292</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixArray([In] D3DXHANDLE hConstant,[In] const D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetMatrixArray</unmanaged-short>	
        public void SetMatrixArray(SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, matrixRef_, count,((void**)(*(void**)_nativePointer))[21]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of references to non-transposed matrices.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to an array of constant matrices. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to non-transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A non-transposed matrix contains row-major data; that is, each vector is contained in a row.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetMatrixPointerArray']/*"/>	
        /// <msdn-id>bb174293</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixPointerArray([In] D3DXHANDLE hConstant,[In] const D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetMatrixPointerArray</unmanaged-short>	
        public void SetMatrixPointerArray(SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, matrixOut_, count,((void**)(*(void**)_nativePointer))[22]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets a transposed matrix.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the matrix of constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Pointer to a transposed matrix. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetMatrixTranspose']/*"/>	
        /// <msdn-id>bb174294</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixTranspose([In] D3DXHANDLE hConstant,[In] const D3DXMATRIX* pMatrix)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetMatrixTranspose</unmanaged-short>	
        public void SetMatrixTranspose(SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, matrixRef_,((void**)(*(void**)_nativePointer))[23]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of transposed matrices.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of matrix constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixRef"><dd>  <p>Array of transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetMatrixTransposeArray']/*"/>	
        /// <msdn-id>bb174295</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixTransposeArray([In] D3DXHANDLE hConstant,[In] const D3DXMATRIX* pMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetMatrixTransposeArray</unmanaged-short>	
        public void SetMatrixTransposeArray(SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixRef, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixRef_ = &matrixRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, matrixRef_, count,((void**)(*(void**)_nativePointer))[24]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Sets an array of references to transposed matrices.</p>	
        /// </summary>	
        /// <param name="effectHandle"><dd>  <p>Unique identifier to the array of matrix constants. See <see cref="SharpDX.Direct3D9.EffectHandle"/>.</p> </dd></param>	
        /// <param name="matrixOut"><dd>  <p>Array of references to transposed matrices. See <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of matrices in the array.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>A transposed matrix contains column-major data; that is, each vector is contained in a column.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXTextureShader::SetMatrixTransposePointerArray']/*"/>	
        /// <msdn-id>bb174296</msdn-id>	
        /// <unmanaged>HRESULT ID3DXTextureShader::SetMatrixTransposePointerArray([In] D3DXHANDLE hConstant,[In] const D3DXMATRIX** ppMatrix,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3DXTextureShader::SetMatrixTransposePointerArray</unmanaged-short>	
        public void SetMatrixTransposePointerArray(SharpDX.Direct3D9.EffectHandle effectHandle, ref SharpDX.Mathematics.Interop.RawMatrix matrixOut, int count) {
            unsafe {
                var effectHandle_ = new SharpDX.Direct3D9.EffectHandle.__Native();
                SharpDX.Direct3D9.EffectHandle.__MarshalTo(ref effectHandle, ref effectHandle_);
                SharpDX.Result __result__;
                fixed (void* matrixOut_ = &matrixOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, effectHandle_, matrixOut_, count,((void**)(*(void**)_nativePointer))[25]);		
                SharpDX.Direct3D9.EffectHandle.__MarshalFree(ref effectHandle, ref effectHandle_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.VertexBuffer"/> interface to manipulate vertex buffer resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.Device.CreateVertexBuffer"/></strong> method.</p><p>This interface inherits additional functionality from the <strong><see cref="SharpDX.Direct3D9.Resource"/></strong> interface.</p><p>This interface, like all COM interfaces, inherits from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPDIRECT3DVERTEXBUFFER9 and PDIRECT3DVERTEXBUFFER9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.VertexBuffer"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.VertexBuffer"/> *LPDIRECT3DVERTEXBUFFER9, *PDIRECT3DVERTEXBUFFER9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexBuffer9']/*"/>	
    /// <msdn-id>bb205915</msdn-id>	
    /// <unmanaged>IDirect3DVertexBuffer9</unmanaged>	
    /// <unmanaged-short>IDirect3DVertexBuffer9</unmanaged-short>	
    [Guid("B64BB1B5-FD70-4df6-BF91-19D0A12455E3")]
    public partial class VertexBuffer : SharpDX.Direct3D9.Resource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.VertexBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VertexBuffer(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.VertexBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.VertexBuffer(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.VertexBuffer(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a description of the vertex buffer resource.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexBuffer9::GetDesc']/*"/>	
        /// <msdn-id>bb205916</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::GetDesc([Out] D3DVERTEXBUFFER_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.VertexBufferDescription Description {
                get { SharpDX.Direct3D9.VertexBufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Locks a range of vertex data and obtains a reference to the vertex buffer memory.</p>	
        /// </summary>	
        /// <param name="offsetToLock"><dd>  <p>Offset into the vertex data to lock, in bytes. To lock the entire vertex buffer, specify 0 for both parameters, SizeToLock and OffsetToLock.</p> </dd></param>	
        /// <param name="sizeToLock"><dd>  <p>Size of the vertex data to lock, in bytes. To lock the entire vertex buffer, specify 0 for both parameters, SizeToLock and OffsetToLock.</p> </dd></param>	
        /// <param name="bDataOut"><dd>  <p>VOID* reference to a memory buffer containing the returned vertex data. </p> </dd></param>	
        /// <param name="lockFlags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/></li> </ul> <p> For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>As a general rule, do not hold a lock across more than one frame. When working with vertex buffers, you are allowed to make multiple lock calls; however, you must ensure that the number of lock calls match the number of unlock calls. DrawPrimitive calls will not succeed with any outstanding lock count on any currently set vertex buffer.</p><p>The <see cref="SharpDX.Direct3D9.LockFlags.Discard"/> and <see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/> flags are valid only on buffers created with <see cref="SharpDX.Direct3D9.Usage.Dynamic"/>.</p><p>For information about using <see cref="SharpDX.Direct3D9.LockFlags.Discard"/> or <see cref="SharpDX.Direct3D9.LockFlags.NoOverwrite"/> with <strong><see cref="SharpDX.Direct3D9.VertexBuffer.Lock_"/></strong>, see Using Dynamic Vertex and Index Buffers.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexBuffer9::Lock']/*"/>	
        /// <msdn-id>bb205917</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::Lock([In] unsigned int OffsetToLock,[In] unsigned int SizeToLock,[Out] void** ppbData,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DVertexBuffer9::Lock</unmanaged-short>	
        internal void Lock_(int offsetToLock, int sizeToLock, out System.IntPtr bDataOut, SharpDX.Direct3D9.LockFlags lockFlags) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* bDataOut_ = &bDataOut)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, offsetToLock, sizeToLock, bDataOut_, unchecked((int)lockFlags),((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks vertex data.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexBuffer9::Unlock']/*"/>	
        /// <msdn-id>bb205918</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::Unlock()</unmanaged>	
        /// <unmanaged-short>IDirect3DVertexBuffer9::Unlock</unmanaged-short>	
        public void Unlock() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[12]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a description of the vertex buffer resource.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.VertexBufferDescription"/></strong> structure, describing the returned vertex buffer. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the argument is invalid.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexBuffer9::GetDesc']/*"/>	
        /// <msdn-id>bb205916</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVertexBuffer9::GetDesc([Out] D3DVERTEXBUFFER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>IDirect3DVertexBuffer9::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.VertexBufferDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D9.VertexBufferDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[13]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.VertexDeclaration"/> interface to encapsulate the vertex shader declaration.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A vertex shader declaration is made up of an array of vertex elements.</p><p>The LPDIRECT3DVERTEXDECLARATION9 and PDIRECT3DVERTEXDECLARATION9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.VertexDeclaration"/></strong> interface. </p><pre>typedef struct <see cref="SharpDX.Direct3D9.VertexDeclaration"/> *LPDIRECT3DVERTEXDECLARATION9, *PDIRECT3DVERTEXDECLARATION9;</pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexDeclaration9']/*"/>	
    /// <msdn-id>bb205919</msdn-id>	
    /// <unmanaged>IDirect3DVertexDeclaration9</unmanaged>	
    /// <unmanaged-short>IDirect3DVertexDeclaration9</unmanaged-short>	
    [Guid("DD13C59C-36FA-4098-A8FB-C7ED39DC8546")]
    public partial class VertexDeclaration : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.VertexDeclaration"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VertexDeclaration(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.VertexDeclaration"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.VertexDeclaration(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.VertexDeclaration(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the current device.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexDeclaration9::GetDevice']/*"/>	
        /// <msdn-id>bb205921</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DVertexDeclaration9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the current device.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Pointer to the <see cref="SharpDX.Direct3D9.Device"/> interface that is returned.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexDeclaration9::GetDevice']/*"/>	
        /// <msdn-id>bb205921</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVertexDeclaration9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DVertexDeclaration9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the vertex shader declaration.</p>	
        /// </summary>	
        /// <param name="elementRef"><dd>  <p>Array of vertex elements (see <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>) that make up a vertex shader declaration. The application needs to allocate enough room for this. The vertex element array ends with the <strong>D3DDECL_END</strong> macro.</p> </dd></param>	
        /// <param name="numElementsRef"><dd>  <p>Number of elements in the array. The application needs to allocate enough room for this. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The number of elements, pNumElements, includes the <strong>D3DDECL_END</strong> macro, which ends the declaration. So the element count is actually one higher than the number of valid vertex elements.</p><p>Here's an example that will return the vertex declaration array of up to 256 elements:</p><pre> <see cref="SharpDX.Direct3D9.VertexElement"/> decl[MAXD3DDECLLENGTH];	
        /// UINT numElements;	
        /// <see cref="SharpDX.Result"/> hr = m_pVertexDeclaration-&gt;GetDeclaration( decl, &amp;numElements);	
        /// </pre><p>Specify <strong><c>null</c></strong> for pDeclto get the number of elements in the declaration.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexDeclaration9::GetDeclaration']/*"/>	
        /// <msdn-id>bb205920</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVertexDeclaration9::GetDeclaration([Out, Buffer] D3DVERTEXELEMENT9* pElement,[InOut] unsigned int* pNumElements)</unmanaged>	
        /// <unmanaged-short>IDirect3DVertexDeclaration9::GetDeclaration</unmanaged-short>	
        internal void GetDeclaration(SharpDX.Direct3D9.VertexElement[] elementRef, ref int numElementsRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* elementRef_ = elementRef)
                    fixed (void* numElementsRef_ = &numElementsRef)
                        __result__= 
        				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, elementRef_, numElementsRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.VertexShader"/> interface to encapsulate the functionality of a vertex shader.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The LPDIRECT3DVERTEXSHADER9 and PDIRECT3DVERTEXSHADER9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.VertexShader"/></strong> interface. </p><pre>typedef struct <see cref="SharpDX.Direct3D9.VertexShader"/> *LPDIRECT3DVERTEXSHADER9, *PDIRECT3DVERTEXSHADER9;</pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexShader9']/*"/>	
    /// <msdn-id>bb205922</msdn-id>	
    /// <unmanaged>IDirect3DVertexShader9</unmanaged>	
    /// <unmanaged-short>IDirect3DVertexShader9</unmanaged-short>	
    [Guid("EFC5557E-6265-4613-8A94-43857889EB36")]
    public partial class VertexShader : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.VertexShader"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VertexShader(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.VertexShader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.VertexShader(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.VertexShader(nativePointer);
		}
        
        
        /// <summary>Constant MaxDynamicFlowControlDepth.</summary>
        /// <unmanaged>D3DVS20_MAX_DYNAMICFLOWCONTROLDEPTH</unmanaged>
        public const int MaxDynamicFlowControlDepth = 24;
        
        /// <summary>Constant MinDynamicFlowControlDepth.</summary>
        /// <unmanaged>D3DVS20_MIN_DYNAMICFLOWCONTROLDEPTH</unmanaged>
        public const int MinDynamicFlowControlDepth = 0;
        
        /// <summary>Constant MaxTemps.</summary>
        /// <unmanaged>D3DVS20_MAX_NUMTEMPS</unmanaged>
        public const int MaxTemps = 32;
        
        /// <summary>Constant MinTemps.</summary>
        /// <unmanaged>D3DVS20_MIN_NUMTEMPS</unmanaged>
        public const int MinTemps = 12;
        
        /// <summary>Constant MaxStaticFlowControlDepth.</summary>
        /// <unmanaged>D3DVS20_MAX_STATICFLOWCONTROLDEPTH</unmanaged>
        public const int MaxStaticFlowControlDepth = 4;
        
        /// <summary>Constant MinStaticFlowControlDepth.</summary>
        /// <unmanaged>D3DVS20_MIN_STATICFLOWCONTROLDEPTH</unmanaged>
        public const int MinStaticFlowControlDepth = 1;
        
        /// <summary>	
        /// <p>Gets the device.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexShader9::GetDevice']/*"/>	
        /// <msdn-id>bb205923</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DVertexShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the device.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Pointer to the <see cref="SharpDX.Direct3D9.Device"/> interface that is returned.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexShader9::GetDevice']/*"/>	
        /// <msdn-id>bb205923</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVertexShader9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DVertexShader9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets a reference to the shader data.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to a buffer that contains the shader data. The application needs to allocate enough room for this. </p> </dd></param>	
        /// <param name="sizeOfDataRef"><dd>  <p>Size of the data, in bytes. To get the buffer size that is needed to retrieve the data, set pData = <strong><c>null</c></strong> when calling GetFunction. Then call GetFunction with the returned size, to get the buffer data.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVertexShader9::GetFunction']/*"/>	
        /// <msdn-id>bb205924</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVertexShader9::GetFunction([In] void* arg0,[InOut] unsigned int* pSizeOfData)</unmanaged>	
        /// <unmanaged-short>IDirect3DVertexShader9::GetFunction</unmanaged-short>	
        internal void GetFunction(System.IntPtr arg0, ref int sizeOfDataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0, sizeOfDataRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface to manipulate volume resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.VolumeTexture.GetVolumeLevel"/></strong> method.</p><p>This interface, like all COM interfaces, inherits from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPDIRECT3DVOLUME9 and PDIRECT3DVOLUME9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.Volume"/> *LPDIRECT3DVOLUME9, *PDIRECT3DVOLUME9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9']/*"/>	
    /// <msdn-id>bb205932</msdn-id>	
    /// <unmanaged>IDirect3DVolume9</unmanaged>	
    /// <unmanaged-short>IDirect3DVolume9</unmanaged-short>	
    [Guid("24F416E6-1F67-4aa7-B88E-D33F6F3128A1")]
    public partial class Volume : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.Volume"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Volume(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.Volume"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.Volume(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.Volume(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the device associated with a volume.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method allows navigation to the owning device object. </p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::GetDevice']/*"/>	
        /// <msdn-id>bb205936</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>
        public SharpDX.Direct3D9.Device Device {
                get { SharpDX.Direct3D9.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a description of the volume.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::GetDesc']/*"/>	
        /// <msdn-id>bb205935</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDesc([Out] D3DVOLUME_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D9.VolumeDescription Description {
                get { SharpDX.Direct3D9.VolumeDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the device associated with a volume.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface to fill with the device reference, if the query succeeds. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>This method allows navigation to the owning device object. </p><p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::GetDevice']/*"/>	
        /// <msdn-id>bb205936</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDevice([Out] IDirect3DDevice9** ppDevice)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D9.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Associates data with the volume that is intended for use by the application, not by Direct3D.</p>	
        /// </summary>	
        /// <param name="refguid"><dd>  <p>Reference to the globally unique identifier that identifies the private data to set.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to a buffer that contains the data to associate with the volume. </p> </dd></param>	
        /// <param name="sizeOfData"><dd>  <p>Size of the buffer at pData in bytes. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Value that describes the type of data being passed, or indicates to the application that the data should be invalidated when the resource changes. </p> <p></p> <table> <tr><th>Item</th><th>Description</th></tr> <tr><td> <p>(none)</p> </td><td> <p>If no flags are specified, Direct3D allocates memory to hold the data within the buffer and copies the data into the new buffer. The buffer allocated by Direct3D is automatically freed, as appropriate.</p> </td></tr> <tr><td> <p>D3DSPD_IUNKNOWN</p> </td><td> <p>The data at pData is a reference to an <strong><see cref="SharpDX.ComObject"/></strong> interface. SizeOfData must be set to the size of a reference to an <strong><see cref="SharpDX.ComObject"/></strong> interface, sizeof(<see cref="SharpDX.ComObject"/>*). Direct3D automatically calls <strong><see cref="SharpDX.ComObject"/></strong> through pData and <see cref="SharpDX.ComObject"/> when the private data is destroyed. Private data will be destroyed by a subsequent call to <strong><see cref="SharpDX.Direct3D9.Volume.SetPrivateData"/></strong> with the same <see cref="System.Guid"/>, a subsequent call to <strong><see cref="SharpDX.Direct3D9.Volume.FreePrivateData"/></strong>, or when the <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> object is released. For more information, see Remarks.</p> </td></tr> </table> <p>?</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Direct3D does not manage the memory at pData. If this buffer was dynamically allocated, it is the calling application's responsibility to free the memory.</p><p>Data is passed by value, and multiple sets of data can be associated with a single volume.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::SetPrivateData']/*"/>	
        /// <msdn-id>bb205939</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::SetPrivateData([In] const GUID&amp; refguid,[In] const void* pData,[In] unsigned int SizeOfData,[In] unsigned int Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::SetPrivateData</unmanaged-short>	
        public void SetPrivateData(System.Guid refguid, System.IntPtr dataRef, int sizeOfData, int flags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &refguid, (void*)dataRef, sizeOfData, flags,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Copies the private data associated with the volume to a provided buffer.</p>	
        /// </summary>	
        /// <param name="refguid"><dd>  <p>Reference to (C++) or address of (C) the globally unique identifier that identifies the private data to retrieve. </p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to a previously allocated buffer to fill with the requested private data if the call succeeds. The application calling this method is responsible for allocating and releasing this buffer. If this parameter is <strong><c>null</c></strong>, this method will return the buffer size in pSizeOfData.</p> </dd></param>	
        /// <param name="sizeOfDataRef"><dd>  <p>Pointer to the size of the buffer at  pData, in bytes. If this value is less than the actual size of the private data, such as 0, the method sets this parameter to the required buffer size, and the method returns <see cref="SharpDX.Direct3D9.ResultCode.MoreData"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.MoreData"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotFound"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::GetPrivateData']/*"/>	
        /// <msdn-id>bb205937</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetPrivateData([In] const GUID&amp; refguid,[In] void* pData,[Out] unsigned int* pSizeOfData)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::GetPrivateData</unmanaged-short>	
        public void GetPrivateData(System.Guid refguid, System.IntPtr dataRef, out int sizeOfDataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* sizeOfDataRef_ = &sizeOfDataRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &refguid, (void*)dataRef, sizeOfDataRef_,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Frees the specified private data associated with this volume.</p>	
        /// </summary>	
        /// <param name="refguid"><dd>  <p>Reference to the globally unique identifier that identifies the private data to free.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotFound"/>.</p></returns>	
        /// <remarks>	
        /// <p>Direct3D calls this method automatically when a volume is released. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::FreePrivateData']/*"/>	
        /// <msdn-id>bb205933</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::FreePrivateData([In] const GUID&amp; refguid)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::FreePrivateData</unmanaged-short>	
        public void FreePrivateData(System.Guid refguid) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &refguid,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Provides access to the parent volume texture object, if this surface is a child level of a volume texture.</p>	
        /// </summary>	
        /// <param name="riid"><dd>  <p>Reference identifier of the volume being requested. </p> </dd></param>	
        /// <param name="containerOut"><dd>  <p>Address of a reference to fill with the container reference, if the query succeeds. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>If the call succeeds, the reference count of the container is increased by one.</p><p>Here's an example getting the parent volume texture of a volume texture.</p><pre> // Assumes pSurface is a valid <see cref="SharpDX.Direct3D9.Volume"/> reference	
        /// void *pContainer = <c>null</c>;	
        /// <see cref="SharpDX.Direct3D9.VolumeTexture"/> *pVolumeTexture = <c>null</c>;	
        /// <see cref="SharpDX.Result"/> hr = pVolume-&gt;GetContainer(IID_IDirect3DVolumeTexture9, &amp;pContainer);	
        /// if (SUCCEEDED(hr) &amp;&amp; pContainer)	
        /// { pVolumeTexture = (<see cref="SharpDX.Direct3D9.VolumeTexture"/> *)pContainer;	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::GetContainer']/*"/>	
        /// <msdn-id>bb205934</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetContainer([In] const GUID&amp; riid,[In] void** ppContainer)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::GetContainer</unmanaged-short>	
        public void GetContainer(System.Guid riid, System.IntPtr containerOut) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &riid, (void*)containerOut,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a description of the volume.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.VolumeDescription"/></strong> structure, describing the volume. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/> is returned if the argument is invalid.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::GetDesc']/*"/>	
        /// <msdn-id>bb205935</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::GetDesc([Out] D3DVOLUME_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D9.VolumeDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D9.VolumeDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Locks a box on a volume resource.</p>	
        /// </summary>	
        /// <param name="lockedVolumeRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.LockedBox"/></strong> structure, describing the locked region. </p> </dd></param>	
        /// <param name="boxRef"><dd>  <p>Pointer to a box to lock. Specified by a reference to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifying <strong><c>null</c></strong> for this parameter locks the entire volume. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p> For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when <strong><see cref="SharpDX.Direct3D9.Volume.LockBox"/></strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. See <strong><see cref="SharpDX.Direct3D9.Device.UpdateTexture"/></strong> for more information.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::LockBox']/*"/>	
        /// <msdn-id>bb205938</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::LockBox([Out] D3DLOCKED_BOX* pLockedVolume,[In] const void* pBox,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::LockBox</unmanaged-short>	
        internal void LockBox(out SharpDX.Direct3D9.LockedBox lockedVolumeRef, System.IntPtr boxRef, SharpDX.Direct3D9.LockFlags flags) {
            unsafe {
                lockedVolumeRef = new SharpDX.Direct3D9.LockedBox();
                SharpDX.Result __result__;
                fixed (void* lockedVolumeRef_ = &lockedVolumeRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, lockedVolumeRef_, (void*)boxRef, unchecked((int)flags),((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks a box on a volume resource.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolume9::UnlockBox']/*"/>	
        /// <msdn-id>bb205940</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolume9::UnlockBox()</unmanaged>	
        /// <unmanaged-short>IDirect3DVolume9::UnlockBox</unmanaged-short>	
        public void UnlockBox() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.VolumeTexture"/> interface to manipulate a volume texture resource.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface can be obtained by calling the <strong>CreateVolumeTexture</strong> method or one of the <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTexture"/><em>xxx</em> functions.</p><p>This interface inherits additional functionality from the <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface.</p><p>This interface, like all COM interfaces, inherits from the <strong><see cref="SharpDX.ComObject"/></strong> interface.</p><p>The LPDIRECT3DVOLUMETEXTURE9 and PDIRECT3DVOLUMETEXTURE9 types are defined as references to the <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D9.VolumeTexture"/> *LPDIRECT3DVOLUMETEXTURE9, *PDIRECT3DVOLUMETEXTURE9;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolumeTexture9']/*"/>	
    /// <msdn-id>bb205941</msdn-id>	
    /// <unmanaged>IDirect3DVolumeTexture9</unmanaged>	
    /// <unmanaged-short>IDirect3DVolumeTexture9</unmanaged-short>	
    [Guid("2518526C-E789-4111-A7B9-47EF328D13E6")]
    public partial class VolumeTexture : SharpDX.Direct3D9.BaseTexture {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.VolumeTexture"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public VolumeTexture(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.VolumeTexture"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.VolumeTexture(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.VolumeTexture(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a level description of a volume texture resource.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Identifies a level of the volume texture resource. This method returns a volume description for the level specified by this parameter. </p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.VolumeDescription"/></strong> structure, describing the returned volume texture level. </p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolumeTexture9::GetLevelDesc']/*"/>	
        /// <msdn-id>bb205943</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::GetLevelDesc([In] unsigned int Level,[Out] D3DVOLUME_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolumeTexture9::GetLevelDesc</unmanaged-short>	
        public SharpDX.Direct3D9.VolumeDescription GetLevelDescription(int level) {
            unsafe {
                SharpDX.Direct3D9.VolumeDescription descRef;
                descRef = new SharpDX.Direct3D9.VolumeDescription();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level, &descRef,((void**)(*(void**)_nativePointer))[17]);		
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the specified volume texture level.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Identifies a level of the volume texture resource. This method returns a volume for the level specified by this parameter. </p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface, representing the returned volume level. </p> </dd></returns>	
        /// <remarks>	
        /// <p>Calling this method will increase the internal reference count on the <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. Failure to call <strong>IUnknown::Release</strong> when finished using this <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface results in a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolumeTexture9::GetVolumeLevel']/*"/>	
        /// <msdn-id>bb205944</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::GetVolumeLevel([In] unsigned int Level,[Out] IDirect3DVolume9** ppVolumeLevel)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolumeTexture9::GetVolumeLevel</unmanaged-short>	
        public SharpDX.Direct3D9.Volume GetVolumeLevel(int level) {
            unsafe {
                SharpDX.Direct3D9.Volume volumeLevelOut;
                IntPtr volumeLevelOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level, &volumeLevelOut_,((void**)(*(void**)_nativePointer))[18]);		
                volumeLevelOut= (volumeLevelOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Volume(volumeLevelOut_);	
                __result__.CheckError();
                return volumeLevelOut;
            }
        }
        
        /// <summary>	
        /// <p>Locks a box on a volume texture resource.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Specifies the level of the volume texture resource to lock. </p> </dd></param>	
        /// <param name="lockedVolumeRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.LockedBox"/></strong> structure, describing the locked region. </p> </dd></param>	
        /// <param name="boxRef"><dd>  <p>Pointer to the volume to lock. This parameter is specified by a reference to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifying <strong><c>null</c></strong> for this parameter locks the entire volume level. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Combination of zero or more locking flags that describe the type of lock to perform. For this method, the valid flags are:  </p> <ul> <li><see cref="SharpDX.Direct3D9.LockFlags.Discard"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.NoSystemLock"/></li> <li><see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/></li> </ul> <p> For a description of the flags, see <see cref="SharpDX.Direct3D9.LockFlags"/>. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>For performance reasons, dirty regions are only recorded for level zero of a texture. Dirty regions are automatically recorded when <strong>LockBox</strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>. For more information, see <strong>UpdateTexture</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolumeTexture9::LockBox']/*"/>	
        /// <msdn-id>bb205945</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::LockBox([In] unsigned int Level,[Out] D3DLOCKED_BOX* pLockedVolume,[In] const void* pBox,[In] D3DLOCK Flags)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolumeTexture9::LockBox</unmanaged-short>	
        internal void LockBox(int level, out SharpDX.Direct3D9.LockedBox lockedVolumeRef, System.IntPtr boxRef, SharpDX.Direct3D9.LockFlags flags) {
            unsafe {
                lockedVolumeRef = new SharpDX.Direct3D9.LockedBox();
                SharpDX.Result __result__;
                fixed (void* lockedVolumeRef_ = &lockedVolumeRef)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level, lockedVolumeRef_, (void*)boxRef, unchecked((int)flags),((void**)(*(void**)_nativePointer))[19]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Unlocks a box on a volume texture resource.</p>	
        /// </summary>	
        /// <param name="level"><dd>  <p>Specifies the level of the volume texture resource to unlock. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolumeTexture9::UnlockBox']/*"/>	
        /// <msdn-id>bb205946</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::UnlockBox([In] unsigned int Level)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolumeTexture9::UnlockBox</unmanaged-short>	
        public void UnlockBox(int level) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, level,((void**)(*(void**)_nativePointer))[20]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a dirty region to a volume texture resource.</p>	
        /// </summary>	
        /// <param name="dirtyBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure, specifying the dirty region to add. Specifying <strong><c>null</c></strong> expands the dirty region to cover the entire volume texture. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the method fails, the return value can be <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>. </p></returns>	
        /// <remarks>	
        /// <p>For performance reasons, dirty regions are only recorded for level zero of a texture. For sublevels, it is assumed that the corresponding (scaled) box is also dirty. Dirty regions are automatically recorded when <strong>LockBox</strong> is called without <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> or <see cref="SharpDX.Direct3D9.LockFlags.ReadOnly"/>.</p><p>Using <see cref="SharpDX.Direct3D9.LockFlags.NoDirtyUpdate"/> and explicitly specifying dirty regions can be used to increase the efficiency of <strong>UpdateTexture</strong>. Using this method, applications can optimize what subset of a resource is copied by specifying dirty boxes on the resource. However, the dirty regions may be expanded to optimize alignment.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='IDirect3DVolumeTexture9::AddDirtyBox']/*"/>	
        /// <msdn-id>bb205942</msdn-id>	
        /// <unmanaged>HRESULT IDirect3DVolumeTexture9::AddDirtyBox([In] const void* pDirtyBox)</unmanaged>	
        /// <unmanaged-short>IDirect3DVolumeTexture9::AddDirtyBox</unmanaged-short>	
        internal void AddDirtyBox(System.IntPtr dirtyBoxRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)dirtyBoxRef,((void**)(*(void**)_nativePointer))[21]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.XFile"/> interface to create instances of the <strong><see cref="SharpDX.Direct3D9.XFileEnumObject"/></strong> and <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> interfaces, and to register templates. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <see cref="SharpDX.Direct3D9.XFile"/> object also contains a local template store. This local storage may be added to only with the <strong><see cref="SharpDX.Direct3D9.XFile.RegisterEnumTemplates"/></strong> and <strong><see cref="SharpDX.Direct3D9.XFile.RegisterTemplates"/></strong> methods.</p><p> <strong><see cref="SharpDX.Direct3D9.XFileEnumObject"/></strong> and <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> objects created with <strong><see cref="SharpDX.Direct3D9.XFile.CreateEnumObject"/></strong> and <strong><see cref="SharpDX.Direct3D9.XFile.CreateSaveObject"/></strong> also utilize the template store of the parent <see cref="SharpDX.Direct3D9.XFile"/> object.</p><p>The <see cref="SharpDX.Direct3D9.XFile"/> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.D3DX9.FileCreate"/></strong> function.</p><p>The globally unique identifier (<see cref="System.Guid"/>) for the <see cref="SharpDX.Direct3D9.XFile"/> interface is IID_ID3DXFile.</p><p>The LPD3DXFILE type is defined as a reference to the <see cref="SharpDX.Direct3D9.XFile"/> interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.XFile"/> *LPD3DXFILE;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFile']/*"/>	
    /// <msdn-id>bb205836</msdn-id>	
    /// <unmanaged>ID3DXFile</unmanaged>	
    /// <unmanaged-short>ID3DXFile</unmanaged-short>	
    [Guid("cef08cf9-7b4f-4429-9624-2a690a933201")]
    public partial class XFile : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.XFile"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public XFile(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.XFile"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.XFile(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.XFile(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Creates an enumerator object that will read a .x file.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>The data source. Either:</p> <ul> <li>A file name</li> <li>A <strong>D3DXF_FILELOADMEMORY</strong> structure</li> <li>A <strong>D3DXF_FILELOADRESOURCE</strong> structure</li> </ul> <p> Depending on the value of loadflags.</p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Value that specifies the source of the data. This value can be one of the D3DXF_FILELOADOPTIONS flags.</p> </dd></param>	
        /// <param name="arg2"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.XFileEnumObject"/></strong> interface, representing the created enumerator object. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR.</p></returns>	
        /// <remarks>	
        /// <p>After using this method, use one of the <strong><see cref="SharpDX.Direct3D9.XFileEnumObject"/></strong> methods to retrieve a data object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFile::CreateEnumObject']/*"/>	
        /// <msdn-id>bb173957</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFile::CreateEnumObject([In] const void* arg0,[In] unsigned int arg1,[In] ID3DXFileEnumObject** arg2)</unmanaged>	
        /// <unmanaged-short>ID3DXFile::CreateEnumObject</unmanaged-short>	
        public void CreateEnumObject(System.IntPtr arg0, int arg1, out SharpDX.Direct3D9.XFileEnumObject arg2) {
            unsafe {
                IntPtr arg2_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0, arg1, &arg2_,((void**)(*(void**)_nativePointer))[3]);		
                arg2= (arg2_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileEnumObject(arg2_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a save object that will be used to save data to a .x file.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to the name of the file to use for saving data.</p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Value that specifies the name of the file to which data is to be saved. This value can be one of the File Save Options flags.</p> </dd></param>	
        /// <param name="arg2"><dd>  <p>Indicates the format to use when saving the .x file. This value can be one of the File Formats flags. For more information, see Remarks.</p> </dd></param>	
        /// <param name="arg3"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> interface, representing the created save object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR.</p></returns>	
        /// <remarks>	
        /// <p>After using this method, use methods of the <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> interface to create data objects and to save templates or data.</p><p>For the saved file format <em>dwFileFormat</em>, one of the binary, legacy binary, or text flags in File Formats must be specified. The file can be compressed by using the optional <see cref="SharpDX.Direct3D9.XFileFormat.Compressed"/> flag.</p><p>The file format values can be combined in a logical OR to create compressed text or compressed binary files. If you indicate that the file format should be text and compressed, the file will be written out first as text and then compressed. However, compressed text files are not as efficient as binary text files; in most cases, therefore, you will want to indicate binary and compressed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFile::CreateSaveObject']/*"/>	
        /// <msdn-id>bb173958</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFile::CreateSaveObject([In] const void* arg0,[In] unsigned int arg1,[In] unsigned int arg2,[In] ID3DXFileSaveObject** arg3)</unmanaged>	
        /// <unmanaged-short>ID3DXFile::CreateSaveObject</unmanaged-short>	
        public void CreateSaveObject(System.IntPtr arg0, int arg1, int arg2, out SharpDX.Direct3D9.XFileSaveObject arg3) {
            unsafe {
                IntPtr arg3_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0, arg1, arg2, &arg3_,((void**)(*(void**)_nativePointer))[4]);		
                arg3= (arg3_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileSaveObject(arg3_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Registers custom templates.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to a buffer consisting of a .x file in text or binary format that contains templates.</p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Size of the buffer pointed to by pvData, in bytes.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_PARSEERROR.</p></returns>	
        /// <remarks>	
        /// <p>The following code fragment provides an example call to <strong>RegisterTemplates</strong> And example contents for the buffer to which <strong>pvData</strong> points.</p><pre> #define XSKINEXP_TEMPLATES \ "xof 0303txt 0032\ template XSkinMeshHeader \ { \ &lt;3CF169CE-FF7C-44ab-93C0-F78F62D172E2&gt; \ WORD nMaxSkinWeightsPerVertex; \ WORD nMaxSkinWeightsPerFace; \ WORD nBones; \ } \ template VertexDuplicationIndices \ { \ &lt;B8D65549-D7C9-4995-89CF-53A9A8B031E3&gt; \ DWORD nIndices; \ DWORD nOriginalVertices; \ array DWORD indices[nIndices]; \ } \ template SkinWeights \ { \ &lt;6F0D123B-BAD2-4167-A0D0-80224F25FABB&gt; \ STRING transformNodeName;\ DWORD nWeights; \ array DWORD vertexIndices[nWeights]; \ array float weights[nWeights]; \ Matrix4x4 matrixOffset; \ }"	
        /// .	
        /// .	
        /// . LPD3DXFILE pD3DXFile = <c>null</c>; if ( FAILED  (hr = pD3DXFile-&gt;RegisterTemplates(  (LPVOID)XSKINEXP_TEMPLATES, sizeof( XSKINEXP_TEMPLATES ) - 1 ) ) )	
        /// goto End;	
        /// </pre><p>All templates must specify a name and a UUID.</p><p>This method calls the <strong>RegisterEnumTemplates</strong> method, obtaining an <strong><see cref="SharpDX.Direct3D9.XFileEnumObject"/></strong> interface reference by calling <strong>CreateEnumObject</strong> with <strong>pvData</strong> as the first parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFile::RegisterTemplates']/*"/>	
        /// <msdn-id>bb173960</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFile::RegisterTemplates([In] const void* arg0,[In] SIZE_T arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFile::RegisterTemplates</unmanaged-short>	
        public void RegisterTemplates(System.IntPtr arg0, SharpDX.PointerSize arg1) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0, (void*)arg1,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Registers custom templates, given an <strong><see cref="SharpDX.Direct3D9.XFileEnumObject"/></strong> enumeration object.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/> .</p><p>If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <remarks>	
        /// <p>When this method is called, it copies templates stored with the <see cref="SharpDX.Direct3D9.XFileEnumObject"/>, representing the file, to the local template store of the <strong><see cref="SharpDX.Direct3D9.XFile"/></strong> object.</p><p>If an <strong><see cref="SharpDX.Direct3D9.XFileEnumObject"/></strong> reference is not available, call the <strong>RegisterTemplates</strong> method instead.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFile::RegisterEnumTemplates']/*"/>	
        /// <msdn-id>bb173959</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFile::RegisterEnumTemplates([In] ID3DXFileEnumObject* arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFile::RegisterEnumTemplates</unmanaged-short>	
        public void RegisterEnumTemplates(SharpDX.Direct3D9.XFileEnumObject arg0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)((arg0 == null)?IntPtr.Zero:arg0.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.XFileData"/> interface to build or to access the immediate hierarchy of the data object. Template restrictions determine the hierarchy.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Data types allowed by the template are called optional members. The optional members are not required, but an object might miss important information without them. These optional members are saved as children of the data object. A child can be another data object or a reference to an earlier data object.</p><p>The <see cref="System.Guid"/> for the <see cref="SharpDX.Direct3D9.XFileData"/> interface is IID_ID3DXFileData.</p><p>The LPD3DXFILEDATA type is defined as a reference to this interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.XFileData"/> *LPD3DXFILEDATA;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData']/*"/>	
    /// <msdn-id>bb205837</msdn-id>	
    /// <unmanaged>ID3DXFileData</unmanaged>	
    /// <unmanaged-short>ID3DXFileData</unmanaged-short>	
    [Guid("cef08cfd-7b4f-4429-9624-2a690a933201")]
    public partial class XFileData : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.XFileData"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public XFileData(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.XFileData"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.XFileData(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.XFileData(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the enumeration object in this file data object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetEnum']/*"/>	
        /// <msdn-id>bb205840</msdn-id>	
        /// <unmanaged>GetEnum</unmanaged>	
        /// <unmanaged-short>GetEnum</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileData::GetEnum([Out] ID3DXFileEnumObject** arg0)</unmanaged>
        public SharpDX.Direct3D9.XFileEnumObject Enum {
                get { SharpDX.Direct3D9.XFileEnumObject __output__; GetEnum(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the template ID in this file data object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetType']/*"/>	
        /// <msdn-id>bb205843</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileData::GetType([Out] GUID* arg0)</unmanaged>
        public System.Guid TypeInfo {
                get { System.Guid __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Indicates whether this file data object is a reference object that points to another child data object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::IsReference']/*"/>	
        /// <msdn-id>bb205844</msdn-id>	
        /// <unmanaged>IsReference</unmanaged>	
        /// <unmanaged-short>IsReference</unmanaged-short>	
        /// <unmanaged>BOOL ID3DXFileData::IsReference()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsReference {
                get { return IsReference_(); }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of children in this file data object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetChildren']/*"/>	
        /// <msdn-id>bb205839</msdn-id>	
        /// <unmanaged>GetChildren</unmanaged>	
        /// <unmanaged-short>GetChildren</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileData::GetChildren([Out] SIZE_T* arg0)</unmanaged>
        public SharpDX.PointerSize Children {
                get { SharpDX.PointerSize __output__; GetChildren(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the enumeration object in this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Address of a reference to receive the enumeration object in this file data object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetEnum']/*"/>	
        /// <msdn-id>bb205840</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::GetEnum([Out] ID3DXFileEnumObject** arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::GetEnum</unmanaged-short>	
        internal void GetEnum(out SharpDX.Direct3D9.XFileEnumObject arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0_,((void**)(*(void**)_nativePointer))[3]);		
                arg0= (arg0_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileEnumObject(arg0_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the name of this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Address of a reference to receive the name of this file data object. If this parameter is <strong><c>null</c></strong>, then puiSize will return the size of the string. If szName points to valid memory, the name of this file data object will be copied into szName up to the number of characters given by puiSize. </p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Pointer to the size of the string that represents the name of this file data object. This parameter can be <strong><c>null</c></strong> if szName provides a reference to the name. This parameter will return the size of the string if szName is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <remarks>	
        /// <p>For this method to succeed, either szName or <em>puiSize</em> must be non-<strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetName']/*"/>	
        /// <msdn-id>bb205842</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::GetName([In] char* arg0,[Out] SIZE_T* arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::GetName</unmanaged-short>	
        public void GetName(string arg0, out SharpDX.PointerSize arg1) {
            unsafe {
                IntPtr arg0_ = Utilities.StringToHGlobalAnsi(arg0);
                arg1 = new SharpDX.PointerSize();
                SharpDX.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0_, arg1_,((void**)(*(void**)_nativePointer))[4]);		
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <see cref="System.Guid"/> of this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to a <see cref="System.Guid"/> to receive the ID of this file data object. If the file data object has no ID, the returned parameter value will be GUID_NULL.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetId']/*"/>	
        /// <msdn-id>bb205841</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::GetId([In] GUID* arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::GetId</unmanaged-short>	
        public void GetId(System.Guid arg0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Accesses the .x file data.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to the size of the .x file data.</p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Address of a reference to receive the <strong><see cref="SharpDX.Direct3D9.XFileData"/></strong> file data object's interface reference. See Remarks.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <remarks>	
        /// <p>The <em>ppData</em> reference is only valid during a <strong><see cref="SharpDX.Direct3D9.XFileData.Lock"/></strong> ... <strong><see cref="SharpDX.Direct3D9.XFileData.Unlock"/></strong> sequence. You can make multiple lock calls. However, you must ensure that the number of lock calls matches the number of unlock calls.</p><p>Because file data is not guaranteed to be aligned properly with byte boundaries, you should access <em>ppData</em> with UNALIGNED references.</p><p>Returned parameter values are not guaranteed to be valid due to possible file corruption; therefore, your code should verify the returned parameter values.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::Lock']/*"/>	
        /// <msdn-id>bb205845</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::Lock([In] SIZE_T* arg0,[In] const void** arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::Lock</unmanaged-short>	
        public void Lock(SharpDX.PointerSize arg0, System.IntPtr arg1) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0, (void*)arg1,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Ends the lifespan of the <em>ppData</em> reference returned by <strong><see cref="SharpDX.Direct3D9.XFileData.Lock"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>The return value is <see cref="SharpDX.Result.Ok"/>.</p></returns>	
        /// <remarks>	
        /// <p>You must ensure that the number of <strong><see cref="SharpDX.Direct3D9.XFileData.Lock"/></strong> calls matches the number of <strong><see cref="SharpDX.Direct3D9.XFileData.Unlock"/></strong> calls. After calling Unlock, the ppData reference returned by <strong><see cref="SharpDX.Direct3D9.XFileData.Lock"/></strong> should no longer be used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::Unlock']/*"/>	
        /// <msdn-id>bb205846</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::Unlock()</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::Unlock</unmanaged-short>	
        public void Unlock() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the template ID in this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to the <see cref="System.Guid"/> representing the template in this file data object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetType']/*"/>	
        /// <msdn-id>bb205843</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::GetType([Out] GUID* arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::GetType</unmanaged-short>	
        internal void GetTypeInfo(out System.Guid arg0) {
            unsafe {
                arg0 = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, arg0_,((void**)(*(void**)_nativePointer))[8]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Indicates whether this file data object is a reference object that points to another child data object.</p>	
        /// </summary>	
        /// <returns><p>Returns <strong>TRUE</strong> if the file data object is a reference object; returns <strong><see cref="SharpDX.Result.False"/></strong> otherwise.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::IsReference']/*"/>	
        /// <msdn-id>bb205844</msdn-id>	
        /// <unmanaged>BOOL ID3DXFileData::IsReference()</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::IsReference</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsReference_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of children in this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Address of a reference to receive the number of children in this file data object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetChildren']/*"/>	
        /// <msdn-id>bb205839</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::GetChildren([Out] SIZE_T* arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::GetChildren</unmanaged-short>	
        internal void GetChildren(out SharpDX.PointerSize arg0) {
            unsafe {
                arg0 = new SharpDX.PointerSize();
                SharpDX.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, arg0_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a child object in this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>ID of the child object to retrieve.</p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Address of a reference to receive the child object's interface reference.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following values: D3DXFERR_BADVALUE, D3DXFERR_NOMOREOBJECTS.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileData::GetChild']/*"/>	
        /// <msdn-id>bb205838</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileData::GetChild([In] SIZE_T arg0,[Out] ID3DXFileData** arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileData::GetChild</unmanaged-short>	
        public void GetChild(SharpDX.PointerSize arg0, out SharpDX.Direct3D9.XFileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0, &arg1_,((void**)(*(void**)_nativePointer))[11]);		
                arg1= (arg1_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileData(arg1_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.XFileEnumObject"/> interface to cycle through the child file data objects in the file and to retrieve a child object by its globally unique identifier (<see cref="System.Guid"/>) or by its name.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <see cref="System.Guid"/> for the <see cref="SharpDX.Direct3D9.XFileEnumObject"/> interface is IID_ID3DXFileEnumObject.</p><p>The LPD3DXFILEENUMOBJECT type is defined as a reference to this interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.XFileEnumObject"/> *LPD3DXFILEENUMOBJECT;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject']/*"/>	
    /// <msdn-id>bb205847</msdn-id>	
    /// <unmanaged>ID3DXFileEnumObject</unmanaged>	
    /// <unmanaged-short>ID3DXFileEnumObject</unmanaged-short>	
    [Guid("cef08cfc-7b4f-4429-9624-2a690a933201")]
    public partial class XFileEnumObject : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.XFileEnumObject"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public XFileEnumObject(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.XFileEnumObject"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.XFileEnumObject(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.XFileEnumObject(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.Direct3D9.XFile"/></strong> object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject::GetFile']/*"/>	
        /// <msdn-id>bb205852</msdn-id>	
        /// <unmanaged>GetFile</unmanaged>	
        /// <unmanaged-short>GetFile</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>
        public SharpDX.Direct3D9.XFile File {
                get { SharpDX.Direct3D9.XFile __output__; GetFile(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of child objects in this file data object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject::GetChildren']/*"/>	
        /// <msdn-id>bb205849</msdn-id>	
        /// <unmanaged>GetChildren</unmanaged>	
        /// <unmanaged-short>GetChildren</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetChildren([Out] SIZE_T* arg0)</unmanaged>
        public SharpDX.PointerSize Children {
                get { SharpDX.PointerSize __output__; GetChildren(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the <strong><see cref="SharpDX.Direct3D9.XFile"/></strong> object.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject::GetFile']/*"/>	
        /// <msdn-id>bb205852</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileEnumObject::GetFile</unmanaged-short>	
        internal void GetFile(out SharpDX.Direct3D9.XFile arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0_,((void**)(*(void**)_nativePointer))[3]);		
                arg0= (arg0_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFile(arg0_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the number of child objects in this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Address of a reference to receive the number of child objects in this file data object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject::GetChildren']/*"/>	
        /// <msdn-id>bb205849</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetChildren([Out] SIZE_T* arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileEnumObject::GetChildren</unmanaged-short>	
        internal void GetChildren(out SharpDX.PointerSize arg0) {
            unsafe {
                arg0 = new SharpDX.PointerSize();
                SharpDX.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, arg0_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves a child object in this file data object.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>ID of the child object to retrieve.</p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Address of a reference to receive the child object's interface reference.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, D3DXFERR_NOMOREOBJECTS.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject::GetChild']/*"/>	
        /// <msdn-id>bb205848</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetChild([In] SIZE_T arg0,[Out] ID3DXFileData** arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileEnumObject::GetChild</unmanaged-short>	
        public void GetChild(SharpDX.PointerSize arg0, out SharpDX.Direct3D9.XFileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0, &arg1_,((void**)(*(void**)_nativePointer))[5]);		
                arg1= (arg1_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileData(arg1_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the data object that has the specified <see cref="System.Guid"/>.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Reference to the requested <see cref="System.Guid"/>. </p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.XFileData"/></strong> interface, representing the returned file data object. </p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following:DXFILEERR_BADVALUE, DXFILEERR_NOTFOUND.</p></returns>	
        /// <remarks>	
        /// <p>Obtain the <see cref="System.Guid"/> rguid of the current file data object with the <strong><see cref="SharpDX.Direct3D9.XFileData.GetId"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject::GetDataObjectById']/*"/>	
        /// <msdn-id>bb205850</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetDataObjectById([In] const GUID&amp; arg0,[In] ID3DXFileData** arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileEnumObject::GetDataObjectById</unmanaged-short>	
        public void GetDataObjectById(System.Guid arg0, out SharpDX.Direct3D9.XFileData arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0, &arg1_,((void**)(*(void**)_nativePointer))[6]);		
                arg1= (arg1_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileData(arg1_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the data object that has the specified name.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to the requested name. </p> </dd></param>	
        /// <param name="arg1"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.XFileData"/></strong> interface, representing the returned file data object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following:DXFILEERR_BADVALUE, DXFILEERR_NOTFOUND.</p></returns>	
        /// <remarks>	
        /// <p>Obtain the name szName of the current file data object with the <strong><see cref="SharpDX.Direct3D9.XFileData.GetName"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileEnumObject::GetDataObjectByName']/*"/>	
        /// <msdn-id>bb205851</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileEnumObject::GetDataObjectByName([In] const char* arg0,[In] ID3DXFileData** arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileEnumObject::GetDataObjectByName</unmanaged-short>	
        public void GetDataObjectByName(string arg0, out SharpDX.Direct3D9.XFileData arg1) {
            unsafe {
                IntPtr arg0_ = Utilities.StringToHGlobalAnsi(arg0);
                IntPtr arg1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0_, &arg1_,((void**)(*(void**)_nativePointer))[7]);		
                Marshal.FreeHGlobal(arg0_ );
                arg1= (arg1_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileData(arg1_);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.XFileSaveData"/> interface to add data objects as children of a .x file data node.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <see cref="System.Guid"/> for the <see cref="SharpDX.Direct3D9.XFileSaveObject"/> interface is IID_ID3DXFileSaveObject.</p><p>The LPD3DXFileSaveData type is defined as a reference to this interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.XFileSaveData"/> *LPD3DXFILESAVEDATA;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData']/*"/>	
    /// <msdn-id>bb205853</msdn-id>	
    /// <unmanaged>ID3DXFileSaveData</unmanaged>	
    /// <unmanaged-short>ID3DXFileSaveData</unmanaged-short>	
    [Guid("cef08cfb-7b4f-4429-9624-2a690a933201")]
    public partial class XFileSaveData : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.XFileSaveData"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public XFileSaveData(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.XFileSaveData"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.XFileSaveData(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.XFileSaveData(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieves a reference to this <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> file data node.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::GetSave']/*"/>	
        /// <msdn-id>bb173951</msdn-id>	
        /// <unmanaged>GetSave</unmanaged>	
        /// <unmanaged-short>GetSave</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetSave([Out] ID3DXFileSaveObject** arg0)</unmanaged>
        public SharpDX.Direct3D9.XFileSaveObject Save {
                get { SharpDX.Direct3D9.XFileSaveObject __output__; GetSave(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves the template ID of this file data node.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::GetType']/*"/>	
        /// <msdn-id>bb173952</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetType([Out] GUID* arg0)</unmanaged>
        public System.Guid TypeInfo {
                get { System.Guid __output__; GetTypeInfo(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Retrieves a reference to this <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> file data node.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::GetSave']/*"/>	
        /// <msdn-id>bb173951</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetSave([Out] ID3DXFileSaveObject** arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveData::GetSave</unmanaged-short>	
        internal void GetSave(out SharpDX.Direct3D9.XFileSaveObject arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0_,((void**)(*(void**)_nativePointer))[3]);		
                arg0= (arg0_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileSaveObject(arg0_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the name of this <strong><see cref="SharpDX.Direct3D9.XFileSaveData"/></strong> file data node.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <param name="arg1">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <remarks>	
        /// <p>For this method to succeed, either <em>szName</em> or <em>puiSize</em> must be non-<strong><c>null</c></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::GetName']/*"/>	
        /// <msdn-id>bb173950</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetName([In] char* arg0,[Out] SIZE_T* arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveData::GetName</unmanaged-short>	
        public void GetName(string arg0, out SharpDX.PointerSize arg1) {
            unsafe {
                IntPtr arg0_ = Utilities.StringToHGlobalAnsi(arg0);
                arg1 = new SharpDX.PointerSize();
                SharpDX.Result __result__;
                fixed (void* arg1_ = &arg1)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0_, arg1_,((void**)(*(void**)_nativePointer))[4]);		
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the <see cref="System.Guid"/> of this <strong><see cref="SharpDX.Direct3D9.XFileSaveData"/></strong> file data node.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::GetId']/*"/>	
        /// <msdn-id>bb205856</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetId([In] GUID* arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveData::GetId</unmanaged-short>	
        public void GetId(System.Guid arg0) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieves the template ID of this file data node.</p>	
        /// </summary>	
        /// <param name="arg0"><dd>  <p>Pointer to the <see cref="System.Guid"/> representing the template in this file data node.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::GetType']/*"/>	
        /// <msdn-id>bb173952</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::GetType([Out] GUID* arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveData::GetType</unmanaged-short>	
        internal void GetTypeInfo(out System.Guid arg0) {
            unsafe {
                arg0 = new System.Guid();
                SharpDX.Result __result__;
                fixed (void* arg0_ = &arg0)
                    __result__= 
    				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, arg0_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a data object as a child of the <strong><see cref="SharpDX.Direct3D9.XFileSaveData"/></strong> file data node.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <param name="arg1">No documentation.</param>	
        /// <param name="arg2">No documentation.</param>	
        /// <param name="arg3">No documentation.</param>	
        /// <param name="arg4">No documentation.</param>	
        /// <param name="arg5">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::AddDataObject']/*"/>	
        /// <msdn-id>bb205854</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::AddDataObject([In] const GUID&amp; arg0,[In] const char* arg1,[In] const GUID* arg2,[In] SIZE_T arg3,[In] const void* arg4,[In] ID3DXFileSaveData** arg5)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveData::AddDataObject</unmanaged-short>	
        public void AddDataObject(System.Guid arg0, string arg1, System.Guid arg2, SharpDX.PointerSize arg3, System.IntPtr arg4, out SharpDX.Direct3D9.XFileSaveData arg5) {
            unsafe {
                IntPtr arg1_ = Utilities.StringToHGlobalAnsi(arg1);
                IntPtr arg5_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0, (void*)arg1_, &arg2, (void*)arg3, (void*)arg4, &arg5_,((void**)(*(void**)_nativePointer))[7]);		
                Marshal.FreeHGlobal(arg1_ );
                arg5= (arg5_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileSaveData(arg5_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a data reference as a child of this <strong><see cref="SharpDX.Direct3D9.XFileSaveData"/></strong> file data node. The data reference points to a file data object.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <param name="arg1">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, D3DXFERR_BADVALUE, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The file data object being referenced must have either a name or a <see cref="System.Guid"/>. The file data object must also derive from a different parent <strong><see cref="SharpDX.Direct3D9.XFileSaveData"/></strong> object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveData::AddDataReference']/*"/>	
        /// <msdn-id>bb205855</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveData::AddDataReference([In] const char* arg0,[In] const GUID* arg1)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveData::AddDataReference</unmanaged-short>	
        public void AddDataReference(string arg0, System.Guid arg1) {
            unsafe {
                IntPtr arg0_ = Utilities.StringToHGlobalAnsi(arg0);
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, (void*)arg0_, &arg1,((void**)(*(void**)_nativePointer))[8]);		
                Marshal.FreeHGlobal(arg0_ );
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D9.XFileSaveObject"/> interface to write a .x file to disk, and to add and save data objects and templates. </p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Templates are not required in every file. For example, you could put all templates into a single .x file rather than duplicating them in every .x file.</p><p>The <see cref="SharpDX.Direct3D9.XFileSaveObject"/> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D9.XFile.CreateSaveObject"/></strong> method.</p><p>The globally unique identifier (<see cref="System.Guid"/>) for the <see cref="SharpDX.Direct3D9.XFileSaveObject"/> interface is IID_ID3DXFileSaveObject.</p><p>The LPD3DXFILESAVEOBJECT type is defined as a reference to this interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D9.XFileSaveObject"/> *LPD3DXFILESAVEOBJECT;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveObject']/*"/>	
    /// <msdn-id>bb173953</msdn-id>	
    /// <unmanaged>ID3DXFileSaveObject</unmanaged>	
    /// <unmanaged-short>ID3DXFileSaveObject</unmanaged-short>	
    [Guid("cef08cfa-7b4f-4429-9624-2a690a933201")]
    public partial class XFileSaveObject : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D9.XFileSaveObject"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public XFileSaveObject(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D9.XFileSaveObject"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D9.XFileSaveObject(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D9.XFileSaveObject(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.Direct3D9.XFile"/></strong> interface of the object that created this <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> object.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveObject::GetFile']/*"/>	
        /// <msdn-id>bb173955</msdn-id>	
        /// <unmanaged>GetFile</unmanaged>	
        /// <unmanaged-short>GetFile</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DXFileSaveObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>
        public SharpDX.Direct3D9.XFile File {
                get { SharpDX.Direct3D9.XFile __output__; GetFile(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Gets the <strong><see cref="SharpDX.Direct3D9.XFile"/></strong> interface of the object that created this <strong><see cref="SharpDX.Direct3D9.XFileSaveObject"/></strong> object.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADVALUE, E_NOINTERFACE, E_POINTER.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveObject::GetFile']/*"/>	
        /// <msdn-id>bb173955</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveObject::GetFile([Out] ID3DXFile** arg0)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveObject::GetFile</unmanaged-short>	
        internal void GetFile(out SharpDX.Direct3D9.XFile arg0) {
            unsafe {
                IntPtr arg0_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0_,((void**)(*(void**)_nativePointer))[3]);		
                arg0= (arg0_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFile(arg0_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Adds a data object as a child of the <strong><see cref="SharpDX.Direct3D9.XFileSaveData"/></strong> object.</p>	
        /// </summary>	
        /// <param name="arg0">No documentation.</param>	
        /// <param name="arg1">No documentation.</param>	
        /// <param name="arg2">No documentation.</param>	
        /// <param name="arg3">No documentation.</param>	
        /// <param name="arg4">No documentation.</param>	
        /// <param name="arg5">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DXFERR_BADOBJECT, DXFILEERR_BADVALUE, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If a data reference object will reference the data object, either the szName or pId parameter must be non-<strong><c>null</c></strong>.</p><p>Save the created data to disk by using the <strong><see cref="SharpDX.Direct3D9.XFileSaveObject.Save"/></strong> method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveObject::AddDataObject']/*"/>	
        /// <msdn-id>bb173954</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveObject::AddDataObject([In] const GUID&amp; arg0,[In] const char* arg1,[In] const GUID* arg2,[In] SIZE_T arg3,[In] const void* arg4,[In] ID3DXFileSaveData** arg5)</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveObject::AddDataObject</unmanaged-short>	
        public void AddDataObject(System.Guid arg0, string arg1, System.Guid arg2, SharpDX.PointerSize arg3, System.IntPtr arg4, out SharpDX.Direct3D9.XFileSaveData arg5) {
            unsafe {
                IntPtr arg1_ = Utilities.StringToHGlobalAnsi(arg1);
                IntPtr arg5_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer, &arg0, (void*)arg1_, &arg2, (void*)arg3, (void*)arg4, &arg5_,((void**)(*(void**)_nativePointer))[4]);		
                Marshal.FreeHGlobal(arg1_ );
                arg5= (arg5_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFileSaveData(arg5_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Saves a data object and its children to a .x file on disk.</p>	
        /// </summary>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be the following: D3DXFERR_BADOBJECT.</p></returns>	
        /// <remarks>	
        /// <p>After this method succeeds, <strong><see cref="SharpDX.Direct3D9.XFileSaveObject.AddDataObject"/></strong>, <strong><see cref="SharpDX.Direct3D9.XFileSaveData.AddDataObject"/></strong> and <strong><see cref="SharpDX.Direct3D9.XFileSaveData.AddDataReference"/></strong> can no longer be called until a new <strong><see cref="SharpDX.Direct3D9.XFile"/></strong> object is created.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DXFileSaveObject::Save']/*"/>	
        /// <msdn-id>bb173956</msdn-id>	
        /// <unmanaged>HRESULT ID3DXFileSaveObject::Save()</unmanaged>	
        /// <unmanaged-short>ID3DXFileSaveObject::Save</unmanaged-short>	
        public void Save() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D9.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
    }
}
