// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct3D9 namespace.
//     This code was generated by a tool.
//     Date : 28/03/2015 21:51:15
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct3D9 {

#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574

        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.Direct3D9.D3D9']/*"/>	
    static  partial class D3D9 {   
        
        /// <summary>Constant SdkVersion.</summary>
        /// <unmanaged>D3D_SDK_VERSION</unmanaged>
        public const int SdkVersion = 32;
        
        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> object and returns an interface to it.</p>	
        /// </summary>	
        /// <param name="sDKVersion">No documentation.</param>	
        /// <param name="arg1">No documentation.</param>	
        /// <returns><ul> <li> <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/> if Direct3DEx features are not supported (no WDDM driver is installed) or if the <strong>SDKVersion</strong> does not match the version of the DLL. </li> <li> D3DERR_OUTOFMEMORY if out-of-memory conditions are detected when creating the enumerator object. </li> <li><see cref="SharpDX.Result.Ok"/> if the creation of the enumerator object is successful.</li> </ul></returns>	
        /// <remarks>	
        /// <p> The <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> object is the first object that the application creates and the last object thta the application releases. Functions for enumerating and retrieving capabilities of a device are accessible through the <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> object. This enables applications to select devices without creating them. </p><p> The <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> interface supports enumeration of active display adapters and allows the creation of <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> objects. If the user dynamically adds adapters (either by adding devices to the desktop, or by hot-docking a laptop), these devices are not included in the enumeration. Creating a new <strong><see cref="SharpDX.Direct3D9.Direct3DEx"/></strong> interface will expose the new devices. </p><p> Pass the <see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/> flag to this function to ensure that header files used in the compiled application match the version of the installed runtime DLLs. <see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/> is changed in the runtime only when a header or another code change would require rebuilding the application. If this function fails, it indicates that the versions of the header file and the runtime DLL do not match. </p><p><strong>Note</strong>??Direct3DCreate9Ex is supported only in Windows Vista, Windows Server 2008, and Windows 7.   Earlier versions of the D3D9.dll library do not include Direct3D9Ex and Direct3DCreate9Ex. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='Direct3DCreate9Ex']/*"/>	
        /// <msdn-id>bb219676</msdn-id>	
        /// <unmanaged>HRESULT Direct3DCreate9Ex([In] unsigned int SDKVersion,[Out, Fast] IDirect3D9Ex** arg1)</unmanaged>	
        /// <unmanaged-short>Direct3DCreate9Ex</unmanaged-short>	
        public static void Create9Ex(int sDKVersion, SharpDX.Direct3D9.Direct3DEx arg1) {
            unsafe {
                IntPtr arg1_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				Direct3DCreate9Ex_(sDKVersion, &arg1_);		
                ((SharpDX.Direct3D9.Direct3DEx)arg1).NativePointer = arg1_;
                __result__.CheckError();
            }
        }

        [DllImport("d3d9.dll", EntryPoint = "Direct3DCreate9Ex", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int Direct3DCreate9Ex_(int arg0,void* arg1);

        
        /// <summary>	
        /// <p>Create an <see cref="SharpDX.Direct3D9.Direct3D"/> object and return an interface to it.</p>	
        /// </summary>	
        /// <param name="sDKVersion"><dd>  <p>The value of this parameter should be <see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/>. See Remarks.</p> </dd></param>	
        /// <returns><p>If successful, this function returns a reference to an <strong><see cref="SharpDX.Direct3D9.Direct3D"/></strong> interface; otherwise, a <strong><c>null</c></strong> reference is returned.</p></returns>	
        /// <remarks>	
        /// <p>The Direct3D object is the first Direct3D COM object that your graphical application needs to create and the last object that your application needs to release. Functions for enumerating and retrieving capabilities of a device are accessible through the Direct3D object. This enables applications to select devices without creating them.</p><p>Create an <see cref="SharpDX.Direct3D9.Direct3D"/> object as shown here:</p><pre> LPDIRECT3D9 g_pD3D = <c>null</c>; if( <c>null</c> == (g_pD3D = Direct3DCreate9(<see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/>))) return E_FAIL;	
        /// </pre><p>The <see cref="SharpDX.Direct3D9.Direct3D"/> interface supports enumeration of active display adapters and allows the creation of <strong><see cref="SharpDX.Direct3D9.Device"/></strong> objects. If the user dynamically adds adapters (either by adding devices to the desktop, or by hot-docking a laptop), those devices will not be included in the enumeration. Creating a new <see cref="SharpDX.Direct3D9.Direct3D"/> interface will expose the new devices.</p><p><see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/> is passed to this function to ensure that the header files against which an application is compiled match the version of the runtime DLL's that are installed on the machine. <see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/> is only changed in the runtime when a header change (or other code change) would require an application to be rebuilt. If this function fails, it indicates that the header file version does not match the runtime DLL version.</p><p>For an example, see Creating a Device (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='Direct3DCreate9']/*"/>	
        /// <msdn-id>bb219685</msdn-id>	
        /// <unmanaged>IDirect3D9* Direct3DCreate9([In] unsigned int SDKVersion)</unmanaged>	
        /// <unmanaged-short>Direct3DCreate9</unmanaged-short>	
        public static SharpDX.Direct3D9.Direct3D Create9(int sDKVersion) {
            unsafe {
                SharpDX.Direct3D9.Direct3D __result__;
                __result__= 
				new SharpDX.Direct3D9.Direct3D((IntPtr)Direct3DCreate9_(sDKVersion));		
                return __result__;
            }
        }

        [DllImport("d3d9.dll", EntryPoint = "Direct3DCreate9", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern System.IntPtr Direct3DCreate9_(int arg0);

    }
        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.Direct3D9.D3DX9']/*"/>	
    static  partial class D3DX9 {   
        
        /// <summary>Constant Version.</summary>
        /// <unmanaged>D3DX_VERSION</unmanaged>
        public const int Version = 2306;
        
        /// <summary>Constant SdkVersion.</summary>
        /// <unmanaged>D3DX_SDK_VERSION</unmanaged>
        public const int SdkVersion = 43;
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>	
        /// <param name="wszName">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPERF_SetMarker']/*"/>	
        /// <unmanaged>void D3DPERF_SetMarker([In] D3DCOLOR col,[In] const wchar_t* wszName)</unmanaged>	
        /// <unmanaged-short>D3DPERF_SetMarker</unmanaged-short>	
        public static void SetMarker(SharpDX.Mathematics.Interop.RawColorBGRA col, string wszName) {
            unsafe {
                IntPtr wszName_ = Utilities.StringToHGlobalUni(wszName);
                D3DPERF_SetMarker_(col, (void*)wszName_);		
                Marshal.FreeHGlobal(wszName_ );
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetMarker", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void D3DPERF_SetMarker_(SharpDX.Mathematics.Interop.RawColorBGRA arg0,void* arg1);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="dwOptions">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPERF_SetOptions']/*"/>	
        /// <unmanaged>void D3DPERF_SetOptions([In] unsigned int dwOptions)</unmanaged>	
        /// <unmanaged-short>D3DPERF_SetOptions</unmanaged-short>	
        public static void SetOptions(int dwOptions) {
            unsafe {
                D3DPERF_SetOptions_(dwOptions);		
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetOptions", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void D3DPERF_SetOptions_(int arg0);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPERF_GetStatus']/*"/>	
        /// <unmanaged>unsigned int D3DPERF_GetStatus()</unmanaged>	
        /// <unmanaged-short>D3DPERF_GetStatus</unmanaged-short>	
        public static int GetStatus() {
            unsafe {
                int __result__;
                __result__= 
				D3DPERF_GetStatus_();		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_GetStatus", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DPERF_GetStatus_();

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="col">No documentation.</param>	
        /// <param name="wszName">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPERF_SetRegion']/*"/>	
        /// <unmanaged>void D3DPERF_SetRegion([In] D3DCOLOR col,[In] const wchar_t* wszName)</unmanaged>	
        /// <unmanaged-short>D3DPERF_SetRegion</unmanaged-short>	
        public static void SetRegion(SharpDX.Mathematics.Interop.RawColorBGRA col, string wszName) {
            unsafe {
                IntPtr wszName_ = Utilities.StringToHGlobalUni(wszName);
                D3DPERF_SetRegion_(col, (void*)wszName_);		
                Marshal.FreeHGlobal(wszName_ );
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_SetRegion", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern void D3DPERF_SetRegion_(SharpDX.Mathematics.Interop.RawColorBGRA arg0,void* arg1);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPERF_EndEvent']/*"/>	
        /// <unmanaged>int D3DPERF_EndEvent()</unmanaged>	
        /// <unmanaged-short>D3DPERF_EndEvent</unmanaged-short>	
        public static int EndEvent() {
            unsafe {
                int __result__;
                __result__= 
				D3DPERF_EndEvent_();		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_EndEvent", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DPERF_EndEvent_();

        
        /// <summary>	
        /// <p>Marks the beginning of a section of event code.</p>	
        /// </summary>	
        /// <param name="col"><dd> <p>A <strong><c>null</c></strong>-terminated <strong>UNICODE</strong> string that contains the name of the event. The name is not relevant to the operating system. You can choose a name that is meaningful when the calling application is running under the Direct3D profiling tool.A <strong><c>null</c></strong> reference produces undefined results.</p> </dd></param>	
        /// <param name="wszName">No documentation.</param>	
        /// <returns><p>Returns the number of previous calls to <strong>BeginEvent</strong> that have not yet been finalized by calls to the <strong>ID3DUserDefinedAnnotation::EndEvent</strong> method.</p><p>The return value is ?1 if the calling application is not running under a Direct3D profiling tool.</p></returns>	
        /// <remarks>	
        /// <p>You call the <strong>EndEvent</strong> method to mark the end of the section of event code.</p><p>A user can visualize the event when the calling application is running under an enabled Direct3D profiling tool such as Microsoft Visual Studio Ultimate?2012.</p><p><strong>BeginEvent</strong> has no effect if the calling application is not running under an enabled Direct3D profiling tool.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPERF_BeginEvent']/*"/>	
        /// <msdn-id>hh446884</msdn-id>	
        /// <unmanaged>int D3DPERF_BeginEvent([In] D3DCOLOR col,[In] const wchar_t* wszName)</unmanaged>	
        /// <unmanaged-short>D3DPERF_BeginEvent</unmanaged-short>	
        public static int BeginEvent(SharpDX.Mathematics.Interop.RawColorBGRA col, string wszName) {
            unsafe {
                IntPtr wszName_ = Utilities.StringToHGlobalUni(wszName);
                int __result__;
                __result__= 
				D3DPERF_BeginEvent_(col, (void*)wszName_);		
                Marshal.FreeHGlobal(wszName_ );
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_BeginEvent", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DPERF_BeginEvent_(SharpDX.Mathematics.Interop.RawColorBGRA arg0,void* arg1);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DPERF_QueryRepeatFrame']/*"/>	
        /// <unmanaged>BOOL D3DPERF_QueryRepeatFrame()</unmanaged>	
        /// <unmanaged-short>D3DPERF_QueryRepeatFrame</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool QueryRepeatFrame() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				D3DPERF_QueryRepeatFrame_();		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DPERF_QueryRepeatFrame", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D3DPERF_QueryRepeatFrame_();

        
        /// <summary>	
        /// <p>Adds a child frame to a frame.</p>	
        /// </summary>	
        /// <param name="frameParentRef"><dd>  <p>Pointer to the parent node.</p> </dd></param>	
        /// <param name="frameChildRef"><dd>  <p>Pointer to the child node.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFrameAppendChild']/*"/>	
        /// <msdn-id>bb172846</msdn-id>	
        /// <unmanaged>HRESULT D3DXFrameAppendChild([In] D3DXFRAME* pFrameParent,[In] const D3DXFRAME* pFrameChild)</unmanaged>	
        /// <unmanaged-short>D3DXFrameAppendChild</unmanaged-short>	
        public static void FrameAppendChild(ref SharpDX.Direct3D9.Frame frameParentRef, ref SharpDX.Direct3D9.Frame frameChildRef) {
            unsafe {
                var frameParentRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameParentRef.__MarshalTo(ref frameParentRef_);
                var frameChildRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameChildRef.__MarshalTo(ref frameChildRef_);
                SharpDX.Result __result__;
                __result__= 
				D3DXFrameAppendChild_(&frameParentRef_, &frameChildRef_);		
                frameParentRef.__MarshalFree(ref frameParentRef_);
                frameChildRef.__MarshalFree(ref frameChildRef_);
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameAppendChild", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFrameAppendChild_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Loads the first frame hierarchy from a .x file.</p>	
        /// </summary>	
        /// <param name="filename"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="meshOptions"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration that specify creation options for the mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object associated with the mesh.</p> </dd></param>	
        /// <param name="allocRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.IAllocateHierarchy"/></strong> interface.</p> </dd></param>	
        /// <param name="userDataLoaderRef"><dd>  <p>Application provided interface that allows loading of user data. See <strong><see cref="SharpDX.Direct3D9.ILoadUserData"/></strong>.</p> </dd></param>	
        /// <param name="frameHierarchyOut"><dd>  <p>Returns a reference to the loaded frame hierarchy. See <strong><see cref="SharpDX.Direct3D9.Frame"/></strong>.</p> </dd></param>	
        /// <param name="animControllerOut"><dd>  <p>Returns a reference to the animation controller corresponding to animation in the .x file. This is created with default tracks and events. See <strong><see cref="SharpDX.Direct3D9.AnimationController"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/>. Otherwise, the function call resolves to D3DXLoadMeshHierarchyFromXA.</p><p>All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh.</p><p><strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong> loads the animation data and frame hierarchy from a .x file. It scans the .x file and builds a frame hierarchy and animation controller according to the <strong><see cref="SharpDX.Direct3D9.IAllocateHierarchy"/></strong>-derived object passed to it through pAlloc. Loading the data requires several steps as follows:</p><ol> <li>Derive <strong><see cref="SharpDX.Direct3D9.IAllocateHierarchy"/></strong>, implementing each method.  This controls how frames and meshes are allocated and freed.</li> <li>Derive <strong><see cref="SharpDX.Direct3D9.ILoadUserData"/></strong>, implementing each method. If your .x file has no embedded user-defined data, or if you do not need it, you can skip this part.</li> <li>Create an object of your <strong><see cref="SharpDX.Direct3D9.IAllocateHierarchy"/></strong> class, and optionally of your LoadUserData class. You do not need to call any methods of these objects yourself.</li> <li>Call <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadMeshHierarchyFromXW"/></strong>, passing in your <strong><see cref="SharpDX.Direct3D9.IAllocateHierarchy"/></strong> object and your <strong><see cref="SharpDX.Direct3D9.ILoadUserData"/></strong> object (or <strong><c>null</c></strong>) to create the frame hierarchy and animation controller.  All the animation sets and frames are automatically registered to the animation controller.</li> </ol><p>During the load, <strong>CreateFrame</strong> and <strong>LoadFrameChildData</strong> are called back on each frame to control loading and allocation of the frame.  The application defines these methods to control how frames are stored.  <strong>CreateMeshContainer</strong> and <strong>LoadMeshChildData</strong> are called back on each mesh object to control loading and allocation of mesh objects.  <strong>LoadTopLevelData</strong> is called back for each top level object that doesn't get loaded by the other methods.</p><p>To free this data, call ID3DXAnimationController::Release to free the animation sets, and <strong>D3DXFRAMEDestroy</strong>, passing in the root node of the frame hierarchy and an object of your derived <strong><see cref="SharpDX.Direct3D9.IAllocateHierarchy"/></strong> class.  <strong>DestroyFrame</strong> and <strong>DestroyMeshContainer</strong> will each be called for every frame and mesh object in the frame hierarchy.  Your implementation of <strong>DestroyFrame</strong> should release everything allocated by <strong>CreateFrame</strong>, and likewise for the mesh container methods.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadMeshHierarchyFromXW']/*"/>	
        /// <msdn-id>bb172894</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXW([In] const wchar_t* Filename,[In] unsigned int MeshOptions,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXAllocateHierarchy* pAlloc,[In] ID3DXLoadUserData* pUserDataLoader,[In] D3DXFRAME** ppFrameHierarchy,[In] ID3DXAnimationController** ppAnimController)</unmanaged>	
        /// <unmanaged-short>D3DXLoadMeshHierarchyFromXW</unmanaged-short>	
        public static void LoadMeshHierarchyFromXW(string filename, int meshOptions, SharpDX.Direct3D9.Device d3DDeviceRef, SharpDX.Direct3D9.IAllocateHierarchy allocRef, SharpDX.Direct3D9.ILoadUserData userDataLoaderRef, ref SharpDX.Direct3D9.Frame frameHierarchyOut, out SharpDX.Direct3D9.AnimationController animControllerOut) {
            unsafe {
                IntPtr filename_ = Utilities.StringToHGlobalUni(filename);
                var frameHierarchyOut_ = new SharpDX.Direct3D9.Frame.__Native();
                frameHierarchyOut.__MarshalTo(ref frameHierarchyOut_);
                IntPtr animControllerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadMeshHierarchyFromXW_((void*)filename_, meshOptions, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), (void*)((allocRef == null)?IntPtr.Zero:allocRef.NativePointer), (void*)((userDataLoaderRef == null)?IntPtr.Zero:userDataLoaderRef.NativePointer), &frameHierarchyOut_, &animControllerOut_);		
                Marshal.FreeHGlobal(filename_ );
                frameHierarchyOut.__MarshalFree(ref frameHierarchyOut_);
                animControllerOut= (animControllerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.AnimationController(animControllerOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadMeshHierarchyFromXW_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Given a frame hierarchy, registers all the named matrices in the animation mixer.</p>	
        /// </summary>	
        /// <param name="frameRootRef"><dd>  <p>The top level node in the frame hierarchy.</p> </dd></param>	
        /// <param name="animControllerRef"><dd>  <p>Pointer to the animation controller object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFrameRegisterNamedMatrices']/*"/>	
        /// <msdn-id>bb172851</msdn-id>	
        /// <unmanaged>HRESULT D3DXFrameRegisterNamedMatrices([In] D3DXFRAME* pFrameRoot,[In] ID3DXAnimationController* pAnimController)</unmanaged>	
        /// <unmanaged-short>D3DXFrameRegisterNamedMatrices</unmanaged-short>	
        public static void FrameRegisterNamedMatrices(ref SharpDX.Direct3D9.Frame frameRootRef, SharpDX.Direct3D9.AnimationController animControllerRef) {
            unsafe {
                var frameRootRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                SharpDX.Result __result__;
                __result__= 
				D3DXFrameRegisterNamedMatrices_(&frameRootRef_, (void*)((animControllerRef == null)?IntPtr.Zero:animControllerRef.NativePointer));		
                frameRootRef.__MarshalFree(ref frameRootRef_);
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameRegisterNamedMatrices", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFrameRegisterNamedMatrices_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Loads the first frame hierarchy from a .x file.</p>	
        /// </summary>	
        /// <param name="memory"><dd>  <p>Pointer to a buffer that contains the mesh hierarchy.</p> </dd></param>	
        /// <param name="sizeOfMemory"><dd>  <p>Size of the pMemory buffer, in bytes.</p> </dd></param>	
        /// <param name="meshOptions"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration that specify creation options for the mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object associated with the mesh.</p> </dd></param>	
        /// <param name="allocRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.IAllocateHierarchy"/></strong> interface.</p> </dd></param>	
        /// <param name="userDataLoaderRef"><dd>  <p>Application provided interface that allows loading of user data. See <strong><see cref="SharpDX.Direct3D9.ILoadUserData"/></strong>.</p> </dd></param>	
        /// <param name="frameHierarchyOut"><dd>  <p>Returns a reference to the loaded frame hierarchy. See <strong><see cref="SharpDX.Direct3D9.Frame"/></strong>.</p> </dd></param>	
        /// <param name="animControllerOut"><dd>  <p>Returns a reference to the animation controller corresponding to animation in the .x file. This is created with default tracks and events. See <strong><see cref="SharpDX.Direct3D9.AnimationController"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadMeshHierarchyFromXInMemory']/*"/>	
        /// <msdn-id>bb172895</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadMeshHierarchyFromXInMemory([In] const void* Memory,[In] unsigned int SizeOfMemory,[In] unsigned int MeshOptions,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXAllocateHierarchy* pAlloc,[In] ID3DXLoadUserData* pUserDataLoader,[In] D3DXFRAME** ppFrameHierarchy,[In] ID3DXAnimationController** ppAnimController)</unmanaged>	
        /// <unmanaged-short>D3DXLoadMeshHierarchyFromXInMemory</unmanaged-short>	
        public static void LoadMeshHierarchyFromXInMemory(System.IntPtr memory, int sizeOfMemory, int meshOptions, SharpDX.Direct3D9.Device d3DDeviceRef, SharpDX.Direct3D9.IAllocateHierarchy allocRef, SharpDX.Direct3D9.ILoadUserData userDataLoaderRef, ref SharpDX.Direct3D9.Frame frameHierarchyOut, out SharpDX.Direct3D9.AnimationController animControllerOut) {
            unsafe {
                var frameHierarchyOut_ = new SharpDX.Direct3D9.Frame.__Native();
                frameHierarchyOut.__MarshalTo(ref frameHierarchyOut_);
                IntPtr animControllerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadMeshHierarchyFromXInMemory_((void*)memory, sizeOfMemory, meshOptions, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), (void*)((allocRef == null)?IntPtr.Zero:allocRef.NativePointer), (void*)((userDataLoaderRef == null)?IntPtr.Zero:userDataLoaderRef.NativePointer), &frameHierarchyOut_, &animControllerOut_);		
                frameHierarchyOut.__MarshalFree(ref frameHierarchyOut_);
                animControllerOut= (animControllerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.AnimationController(animControllerOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshHierarchyFromXInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadMeshHierarchyFromXInMemory_(void* arg0,int arg1,int arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Creates a <strong><see cref="SharpDX.Direct3D9.CompressedAnimationSet"/></strong> key framed animation set interface that stores key frame data in a compressed format.</p>	
        /// </summary>	
        /// <param name="nameRef">No documentation.</param>	
        /// <param name="ticksPerSecond">No documentation.</param>	
        /// <param name="playback">No documentation.</param>	
        /// <param name="compressedDataRef">No documentation.</param>	
        /// <param name="numCallbackKeys">No documentation.</param>	
        /// <param name="callbackKeysRef">No documentation.</param>	
        /// <param name="animationSetOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCompressedAnimationSet']/*"/>	
        /// <msdn-id>bb172754</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCompressedAnimationSet([In] const char* pName,[In] double TicksPerSecond,[In] D3DXPLAYBACK_TYPE Playback,[In] ID3DXBuffer* pCompressedData,[In] unsigned int NumCallbackKeys,[In] const D3DXKEY_CALLBACK* pCallbackKeys,[In] ID3DXCompressedAnimationSet** ppAnimationSet)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCompressedAnimationSet</unmanaged-short>	
        public static void CreateCompressedAnimationSet(string nameRef, double ticksPerSecond, SharpDX.Direct3D9.PlaybackType playback, SharpDX.Direct3D.Blob compressedDataRef, int numCallbackKeys, SharpDX.Direct3D9.CallbackKey callbackKeysRef, out SharpDX.Direct3D9.CompressedAnimationSet animationSetOut) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                IntPtr animationSetOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateCompressedAnimationSet_((void*)nameRef_, ticksPerSecond, unchecked((int)playback), (void*)((compressedDataRef == null)?IntPtr.Zero:compressedDataRef.NativePointer), numCallbackKeys, &callbackKeysRef, &animationSetOut_);		
                Marshal.FreeHGlobal(nameRef_ );
                animationSetOut= (animationSetOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CompressedAnimationSet(animationSetOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCompressedAnimationSet", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCompressedAnimationSet_(void* arg0,double arg1,int arg2,void* arg3,int arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Creates a .x file and saves the mesh hierarchy and corresponding animations in it.</p>	
        /// </summary>	
        /// <param name="filename"><dd>  <p>Pointer to a string that specifies the name of the .x file identifying the saved mesh. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="xFormat"><dd>  <p>Format of the .x file (text or binary, compressed or not). See <see cref="SharpDX.Direct3D9.XFileFormat"/>. <see cref="SharpDX.Direct3D9.XFileFormat.Compressed"/> can be combined (using a logical OR) with either the <see cref="SharpDX.Direct3D9.XFileFormat.Binary"/> or <see cref="SharpDX.Direct3D9.XFileFormat.Text"/> flags to reduce the output file size.</p> </dd></param>	
        /// <param name="frameRootRef"><dd>  <p>Root node of the hierarchy to be saved. See <strong><see cref="SharpDX.Direct3D9.Frame"/></strong>.</p> </dd></param>	
        /// <param name="animControllerRef"><dd>  <p>Animation controller that has animation sets to be stored. See <strong><see cref="SharpDX.Direct3D9.AnimationController"/></strong>.</p> </dd></param>	
        /// <param name="userDataSaverRef"><dd>  <p>Application-provided interface that allows saving of user data. See <strong><see cref="SharpDX.Direct3D9.ISaveUserData"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.SaveMeshHierarchyToFileW"/>. Otherwise, the function call resolves to D3DXSaveMeshHierarchyToFileA.</p><p>This function does not save compressed animation sets.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveMeshHierarchyToFileW']/*"/>	
        /// <msdn-id>bb205427</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveMeshHierarchyToFileW([In] const wchar_t* Filename,[In] unsigned int XFormat,[In] const D3DXFRAME* pFrameRoot,[In] ID3DXAnimationController* pAnimController,[In] ID3DXSaveUserData* pUserDataSaver)</unmanaged>	
        /// <unmanaged-short>D3DXSaveMeshHierarchyToFileW</unmanaged-short>	
        public static void SaveMeshHierarchyToFileW(string filename, int xFormat, ref SharpDX.Direct3D9.Frame frameRootRef, SharpDX.Direct3D9.AnimationController animControllerRef, SharpDX.Direct3D9.ISaveUserData userDataSaverRef) {
            unsafe {
                IntPtr filename_ = Utilities.StringToHGlobalUni(filename);
                var frameRootRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                SharpDX.Result __result__;
                __result__= 
				D3DXSaveMeshHierarchyToFileW_((void*)filename_, xFormat, &frameRootRef_, (void*)((animControllerRef == null)?IntPtr.Zero:animControllerRef.NativePointer), (void*)((userDataSaverRef == null)?IntPtr.Zero:userDataSaverRef.NativePointer));		
                Marshal.FreeHGlobal(filename_ );
                frameRootRef.__MarshalFree(ref frameRootRef_);
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshHierarchyToFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveMeshHierarchyToFileW_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Computes the bounding sphere of all the meshes in the frame hierarchy.</p>	
        /// </summary>	
        /// <param name="frameRootRef"><dd>  <p>Pointer to the root node.</p> </dd></param>	
        /// <param name="objectCenterRef"><dd>  <p>Returns the center of the bounding sphere.</p> </dd></param>	
        /// <param name="objectRadiusRef"><dd>  <p>Returns the radius of the bounding sphere.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFrameCalculateBoundingSphere']/*"/>	
        /// <msdn-id>bb172847</msdn-id>	
        /// <unmanaged>HRESULT D3DXFrameCalculateBoundingSphere([In] const D3DXFRAME* pFrameRoot,[In] D3DXVECTOR3* pObjectCenter,[In] float* pObjectRadius)</unmanaged>	
        /// <unmanaged-short>D3DXFrameCalculateBoundingSphere</unmanaged-short>	
        public static void FrameCalculateBoundingSphere(ref SharpDX.Direct3D9.Frame frameRootRef, SharpDX.Mathematics.Interop.RawVector3 objectCenterRef, float objectRadiusRef) {
            unsafe {
                var frameRootRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                SharpDX.Result __result__;
                __result__= 
				D3DXFrameCalculateBoundingSphere_(&frameRootRef_, &objectCenterRef, &objectRadiusRef);		
                frameRootRef.__MarshalFree(ref frameRootRef_);
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameCalculateBoundingSphere", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFrameCalculateBoundingSphere_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Creates an animation controller object.</p>	
        /// </summary>	
        /// <param name="maxNumMatrices"><dd>  <p>Maximum number of animation outputs the controller can support.</p> </dd></param>	
        /// <param name="maxNumAnimationSets"><dd>  <p>Maximum number of animation sets that can be mixed.</p> </dd></param>	
        /// <param name="maxNumTracks"><dd>  <p>Maximum number of animation sets that can be mixed simultaneously.</p> </dd></param>	
        /// <param name="maxNumEvents"><dd>  <p>Maximum number of outstanding events that the controller will support.</p> </dd></param>	
        /// <param name="animControllerOut"><dd>  <p>Pointer to the animation controller object created. See <strong><see cref="SharpDX.Direct3D9.AnimationController"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>An animation controller controls an animation mixer. The controller adds methods to modify blending parameters over time to enable smooth transitions.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateAnimationController']/*"/>	
        /// <msdn-id>bb172751</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateAnimationController([In] unsigned int MaxNumMatrices,[In] unsigned int MaxNumAnimationSets,[In] unsigned int MaxNumTracks,[In] unsigned int MaxNumEvents,[In] ID3DXAnimationController** ppAnimController)</unmanaged>	
        /// <unmanaged-short>D3DXCreateAnimationController</unmanaged-short>	
        public static void CreateAnimationController(int maxNumMatrices, int maxNumAnimationSets, int maxNumTracks, int maxNumEvents, out SharpDX.Direct3D9.AnimationController animControllerOut) {
            unsafe {
                IntPtr animControllerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateAnimationController_(maxNumMatrices, maxNumAnimationSets, maxNumTracks, maxNumEvents, &animControllerOut_);		
                animControllerOut= (animControllerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.AnimationController(animControllerOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateAnimationController", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateAnimationController_(int arg0,int arg1,int arg2,int arg3,void* arg4);

        
        /// <summary>	
        /// <p>Finds the child frame of a root frame.</p>	
        /// </summary>	
        /// <param name="frameRootRef"><dd>  <p>Pointer to the root frame. See <strong><see cref="SharpDX.Direct3D9.Frame"/></strong>.</p> </dd></param>	
        /// <param name="name"><dd>  <p>Name of the child frame to find.</p> </dd></param>	
        /// <returns><p>Returns the child frame if it is found, or <strong><c>null</c></strong> otherwise. See <strong><see cref="SharpDX.Direct3D9.Frame"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFrameFind']/*"/>	
        /// <msdn-id>bb172849</msdn-id>	
        /// <unmanaged>D3DXFRAME* D3DXFrameFind([In] const D3DXFRAME* pFrameRoot,[In] const char* Name)</unmanaged>	
        /// <unmanaged-short>D3DXFrameFind</unmanaged-short>	
        public static SharpDX.Direct3D9.Frame FrameFind(ref SharpDX.Direct3D9.Frame frameRootRef, string name) {
            unsafe {
                var frameRootRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D9.Frame __result__;
                __result__= 
				D3DXFrameFind_(&frameRootRef_, (void*)name_);		
                frameRootRef.__MarshalFree(ref frameRootRef_);
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameFind", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Direct3D9.Frame D3DXFrameFind_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Creates a <strong><see cref="SharpDX.Direct3D9.KeyframedAnimationSet"/></strong> key framed animation set interface.</p>	
        /// </summary>	
        /// <param name="nameRef">No documentation.</param>	
        /// <param name="ticksPerSecond">No documentation.</param>	
        /// <param name="playback">No documentation.</param>	
        /// <param name="numAnimations">No documentation.</param>	
        /// <param name="numCallbackKeys">No documentation.</param>	
        /// <param name="callbackKeysRef">No documentation.</param>	
        /// <param name="animationSetOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateKeyframedAnimationSet']/*"/>	
        /// <msdn-id>bb172776</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateKeyframedAnimationSet([In] const char* pName,[In] double TicksPerSecond,[In] D3DXPLAYBACK_TYPE Playback,[In] unsigned int NumAnimations,[In] unsigned int NumCallbackKeys,[In] const D3DXKEY_CALLBACK* pCallbackKeys,[In] ID3DXKeyframedAnimationSet** ppAnimationSet)</unmanaged>	
        /// <unmanaged-short>D3DXCreateKeyframedAnimationSet</unmanaged-short>	
        public static void CreateKeyframedAnimationSet(string nameRef, double ticksPerSecond, SharpDX.Direct3D9.PlaybackType playback, int numAnimations, int numCallbackKeys, SharpDX.Direct3D9.CallbackKey callbackKeysRef, out SharpDX.Direct3D9.KeyframedAnimationSet animationSetOut) {
            unsafe {
                IntPtr nameRef_ = Utilities.StringToHGlobalAnsi(nameRef);
                IntPtr animationSetOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateKeyframedAnimationSet_((void*)nameRef_, ticksPerSecond, unchecked((int)playback), numAnimations, numCallbackKeys, &callbackKeysRef, &animationSetOut_);		
                Marshal.FreeHGlobal(nameRef_ );
                animationSetOut= (animationSetOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.KeyframedAnimationSet(animationSetOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateKeyframedAnimationSet", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateKeyframedAnimationSet_(void* arg0,double arg1,int arg2,int arg3,int arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Destroys the subtree of frames under the root, including the root.</p>	
        /// </summary>	
        /// <param name="frameRootRef"><dd>  <p>Pointer to the root node.</p> </dd></param>	
        /// <param name="allocRef"><dd>  <p>Allocation interface used to deallocate nodes of the frame hierarchy.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFrameDestroy']/*"/>	
        /// <msdn-id>bb172848</msdn-id>	
        /// <unmanaged>HRESULT D3DXFrameDestroy([In] D3DXFRAME* pFrameRoot,[In] ID3DXAllocateHierarchy* pAlloc)</unmanaged>	
        /// <unmanaged-short>D3DXFrameDestroy</unmanaged-short>	
        public static void FrameDestroy(ref SharpDX.Direct3D9.Frame frameRootRef, SharpDX.Direct3D9.IAllocateHierarchy allocRef) {
            unsafe {
                var frameRootRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                SharpDX.Result __result__;
                __result__= 
				D3DXFrameDestroy_(&frameRootRef_, (void*)((allocRef == null)?IntPtr.Zero:allocRef.NativePointer));		
                frameRootRef.__MarshalFree(ref frameRootRef_);
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameDestroy", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFrameDestroy_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Counts number of frames in a subtree that have non-null names.</p>	
        /// </summary>	
        /// <param name="frameRootRef"><dd>  <p>Pointer to the root node of the subtree.</p> </dd></param>	
        /// <returns><p>Returns the frame count.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFrameNumNamedMatrices']/*"/>	
        /// <msdn-id>bb172850</msdn-id>	
        /// <unmanaged>unsigned int D3DXFrameNumNamedMatrices([In] const D3DXFRAME* pFrameRoot)</unmanaged>	
        /// <unmanaged-short>D3DXFrameNumNamedMatrices</unmanaged-short>	
        public static int FrameNumNamedMatrices(ref SharpDX.Direct3D9.Frame frameRootRef) {
            unsafe {
                var frameRootRef_ = new SharpDX.Direct3D9.Frame.__Native();
                frameRootRef.__MarshalTo(ref frameRootRef_);
                int __result__;
                __result__= 
				D3DXFrameNumNamedMatrices_(&frameRootRef_);		
                frameRootRef.__MarshalFree(ref frameRootRef_);
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFrameNumNamedMatrices", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFrameNumNamedMatrices_(void* arg0);

        
        /// <summary>	
        /// <p>Creates a render environment map.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, which is the device to associate with the render surface.</p> </dd></param>	
        /// <param name="size"><dd>  <p>Size of the render surface.</p> </dd></param>	
        /// <param name="mipLevels"><dd>  <p>The number of mipmap levels.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type that describes the pixel format of the environment map.</p> </dd></param>	
        /// <param name="depthStencil"><dd>  <p>If <strong>TRUE</strong>, the render surface supports a depth-stencil surface. Otherwise, this member is set to <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <param name="depthStencilFormat"><dd>  <p>If DepthStencil is set to <strong>TRUE</strong>, this parameter is a member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type that describes the depth-stencil format of the environment map.</p> </dd></param>	
        /// <param name="renderToEnvMapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.RenderToEnvironmentMap"/></strong> interface that represents the created render environment map.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateRenderToEnvMap']/*"/>	
        /// <msdn-id>bb172790</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateRenderToEnvMap([In] IDirect3DDevice9* pDevice,[In] unsigned int Size,[In] unsigned int MipLevels,[In] D3DFORMAT Format,[In] BOOL DepthStencil,[In] D3DFORMAT DepthStencilFormat,[In] ID3DXRenderToEnvMap** ppRenderToEnvMap)</unmanaged>	
        /// <unmanaged-short>D3DXCreateRenderToEnvMap</unmanaged-short>	
        public static void CreateRenderToEnvMap(SharpDX.Direct3D9.Device deviceRef, int size, int mipLevels, SharpDX.Direct3D9.Format format, SharpDX.Mathematics.Interop.RawBool depthStencil, SharpDX.Direct3D9.Format depthStencilFormat, out SharpDX.Direct3D9.RenderToEnvironmentMap renderToEnvMapOut) {
            unsafe {
                IntPtr renderToEnvMapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateRenderToEnvMap_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), size, mipLevels, unchecked((int)format), depthStencil, unchecked((int)depthStencilFormat), &renderToEnvMapOut_);		
                renderToEnvMapOut= (renderToEnvMapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.RenderToEnvironmentMap(renderToEnvMapOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateRenderToEnvMap", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateRenderToEnvMap_(void* arg0,int arg1,int arg2,int arg3,SharpDX.Mathematics.Interop.RawBool arg4,int arg5,void* arg6);

        
        /// <summary>	
        /// <p>Returns the driver level.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface representing the device.</p> </dd></param>	
        /// <returns><p>The driver level. See remarks.</p></returns>	
        /// <remarks>	
        /// <p>This method returns the driver version, which is one of the following:</p><ul> <li>700 - Direct3D 7 level driver</li> <li>800 - Direct3D 8 level driver</li> <li>900 - Direct3D 9 level driver</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetDriverLevel']/*"/>	
        /// <msdn-id>bb172865</msdn-id>	
        /// <unmanaged>unsigned int D3DXGetDriverLevel([In] IDirect3DDevice9* pDevice)</unmanaged>	
        /// <unmanaged-short>D3DXGetDriverLevel</unmanaged-short>	
        public static int GetDriverLevel(SharpDX.Direct3D9.Device deviceRef) {
            unsafe {
                int __result__;
                __result__= 
				D3DXGetDriverLevel_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer));		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetDriverLevel", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetDriverLevel_(void* arg0);

        
        /// <summary>	
        /// <p>Creates a font object for a device and font.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device to be associated with the font object.</p> </dd></param>	
        /// <param name="height"><dd>  <p>The height of the characters in logical units.</p> </dd></param>	
        /// <param name="width"><dd>  <p>The width of the characters in logical units.</p> </dd></param>	
        /// <param name="weight"><dd>  <p>Typeface weight. One example is bold.</p> </dd></param>	
        /// <param name="mipLevels"><dd>  <p>The number of mipmap levels.</p> </dd></param>	
        /// <param name="italic"><dd>  <p>True for italic font, false otherwise.</p> </dd></param>	
        /// <param name="charSet"><dd>  <p>The character set of the font.</p> </dd></param>	
        /// <param name="outputPrecision"><dd>  <p>Specifies how Windows should attempt to match the desired font sizes and characteristics with actual fonts. Use OUT_TT_ONLY_PRECIS for instance, to ensure that you always get a TrueType font.</p> </dd></param>	
        /// <param name="quality"><dd>  <p>Specifies how Windows should match the desired font with a real font. It applies to raster fonts only and should not affect TrueType fonts.</p> </dd></param>	
        /// <param name="pitchAndFamily"><dd>  <p>Pitch and family index.</p> </dd></param>	
        /// <param name="faceNameRef"><dd>  <p>String containing the typeface name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks. </p> </dd></param>	
        /// <param name="fontOut"><dd>  <p>Returns a reference to an <strong><see cref="SharpDX.Direct3D9.Font"/></strong> interface, representing the created font object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The creation of an <see cref="SharpDX.Direct3D9.Font"/> object requires that the device supports 32-bit color.</p><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateFont"/>. Otherwise, the function call resolves to D3DXCreateFontA because ANSI strings are being used.</p><p>If you want more information about font parameters, see The Logical Font.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateFontW']/*"/>	
        /// <msdn-id>bb172773</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateFontW([In] IDirect3DDevice9* pDevice,[In] int Height,[In] unsigned int Width,[In] unsigned int Weight,[In] unsigned int MipLevels,[In] BOOL Italic,[In] unsigned int CharSet,[In] unsigned int OutputPrecision,[In] unsigned int Quality,[In] unsigned int PitchAndFamily,[In] const wchar_t* pFaceName,[Out, Fast] ID3DXFont** ppFont)</unmanaged>	
        /// <unmanaged-short>D3DXCreateFontW</unmanaged-short>	
        public static void CreateFont(SharpDX.Direct3D9.Device deviceRef, int height, int width, int weight, int mipLevels, SharpDX.Mathematics.Interop.RawBool italic, int charSet, int outputPrecision, int quality, int pitchAndFamily, string faceNameRef, SharpDX.Direct3D9.Font fontOut) {
            unsafe {
                IntPtr faceNameRef_ = Utilities.StringToHGlobalUni(faceNameRef);
                IntPtr fontOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateFontW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), height, width, weight, mipLevels, italic, charSet, outputPrecision, quality, pitchAndFamily, (void*)faceNameRef_, &fontOut_);		
                Marshal.FreeHGlobal(faceNameRef_ );
                ((SharpDX.Direct3D9.Font)fontOut).NativePointer = fontOut_;
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateFontW_(void* arg0,int arg1,int arg2,int arg3,int arg4,SharpDX.Mathematics.Interop.RawBool arg5,int arg6,int arg7,int arg8,int arg9,void* arg10,void* arg11);

        
        /// <summary>	
        /// <p>Creates a render surface.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device to be associated with the render surface.</p> </dd></param>	
        /// <param name="width"><dd>  <p>Width of the render surface, in pixels.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the render surface, in pixels.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the pixel format of the render surface.</p> </dd></param>	
        /// <param name="depthStencil"><dd>  <p>If <strong>TRUE</strong>, the render surface supports a depth-stencil surface. Otherwise, this member is set to <strong><see cref="SharpDX.Result.False"/></strong>. This function will create a new depth buffer.</p> </dd></param>	
        /// <param name="depthStencilFormat"><dd>  <p>If  <em>DepthStencil</em> is set to <strong>TRUE</strong>, this parameter is a member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the depth-stencil format of the render surface.</p> </dd></param>	
        /// <param name="renderToSurfaceOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.RenderToSurface"/></strong> interface, representing the created render surface.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateRenderToSurface']/*"/>	
        /// <msdn-id>bb172791</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateRenderToSurface([In] IDirect3DDevice9* pDevice,[In] unsigned int Width,[In] unsigned int Height,[In] D3DFORMAT Format,[In] BOOL DepthStencil,[In] D3DFORMAT DepthStencilFormat,[Out, Fast] ID3DXRenderToSurface** ppRenderToSurface)</unmanaged>	
        /// <unmanaged-short>D3DXCreateRenderToSurface</unmanaged-short>	
        public static void CreateRenderToSurface(SharpDX.Direct3D9.Device deviceRef, int width, int height, SharpDX.Direct3D9.Format format, SharpDX.Mathematics.Interop.RawBool depthStencil, SharpDX.Direct3D9.Format depthStencilFormat, SharpDX.Direct3D9.RenderToSurface renderToSurfaceOut) {
            unsafe {
                IntPtr renderToSurfaceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateRenderToSurface_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), width, height, unchecked((int)format), depthStencil, unchecked((int)depthStencilFormat), &renderToSurfaceOut_);		
                ((SharpDX.Direct3D9.RenderToSurface)renderToSurfaceOut).NativePointer = renderToSurfaceOut_;
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateRenderToSurface", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateRenderToSurface_(void* arg0,int arg1,int arg2,int arg3,SharpDX.Mathematics.Interop.RawBool arg4,int arg5,void* arg6);

        
        /// <summary>	
        /// <p>Creates a sprite object which is associated with a particular device. Sprite objects are used to draw 2D images to the screen.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device to be associated with the sprite.</p> </dd></param>	
        /// <param name="spriteOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Sprite"/></strong> interface. This interface allows the user to access sprite functions. </p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>.If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This interface can be used to draw two dimensional images in screen space of the associated device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateSprite']/*"/>	
        /// <msdn-id>bb172797</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateSprite([In] IDirect3DDevice9* pDevice,[Out, Fast] ID3DXSprite** ppSprite)</unmanaged>	
        /// <unmanaged-short>D3DXCreateSprite</unmanaged-short>	
        public static void CreateSprite(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.Sprite spriteOut) {
            unsafe {
                IntPtr spriteOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateSprite_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), &spriteOut_);		
                ((SharpDX.Direct3D9.Sprite)spriteOut).NativePointer = spriteOut_;
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSprite", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateSprite_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Creates a font object indirectly for both a device and a font.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device to be associated with the font object.</p> </dd></param>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.FontDescription"/></strong> structure, describing the attributes of the font object to create. If the compiler settings require Unicode, the data type <see cref="SharpDX.Direct3D9.FontDescription"/> resolves to <see cref="SharpDX.Direct3D9.FontDescription"/>; otherwise, the data type resolves to D3DXFONT_DESCA. See Remarks.</p> </dd></param>	
        /// <param name="fontOut"><dd>  <p>Returns a reference to an <strong><see cref="SharpDX.Direct3D9.Font"/></strong> interface, representing the created font object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateFontIndirect"/>. Otherwise, the function call resolves to D3DXCreateFontIndirectA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateFontIndirectW']/*"/>	
        /// <msdn-id>bb172774</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateFontIndirectW([In] IDirect3DDevice9* pDevice,[In] const D3DXFONT_DESCW* pDesc,[Out, Fast] ID3DXFont** ppFont)</unmanaged>	
        /// <unmanaged-short>D3DXCreateFontIndirectW</unmanaged-short>	
        public static void CreateFontIndirect(SharpDX.Direct3D9.Device deviceRef, ref SharpDX.Direct3D9.FontDescription descRef, SharpDX.Direct3D9.Font fontOut) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D9.FontDescription.__Native();
                descRef.__MarshalTo(ref descRef_);
                IntPtr fontOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateFontIndirectW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), &descRef_, &fontOut_);		
                descRef.__MarshalFree(ref descRef_);
                ((SharpDX.Direct3D9.Font)fontOut).NativePointer = fontOut_;
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateFontIndirectW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateFontIndirectW_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Uses a left-handed coordinate system to create a line.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the created box mesh.</p> </dd></param>	
        /// <param name="lineOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Line"/></strong> interface.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> Flexible Vertex Format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateLine']/*"/>	
        /// <msdn-id>bb172778</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateLine([In] IDirect3DDevice9* pDevice,[Out, Fast] ID3DXLine** ppLine)</unmanaged>	
        /// <unmanaged-short>D3DXCreateLine</unmanaged-short>	
        public static void CreateLine(SharpDX.Direct3D9.Device deviceRef, SharpDX.Direct3D9.Line lineOut) {
            unsafe {
                IntPtr lineOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateLine_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), &lineOut_);		
                ((SharpDX.Direct3D9.Line)lineOut).NativePointer = lineOut_;
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateLine", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateLine_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Turns on or off all D3DX debug output.</p>	
        /// </summary>	
        /// <param name="mute"><dd>  <p>If <strong>TRUE</strong>, debugger output is halted; if <strong><see cref="SharpDX.Result.False"/></strong>, debug output is enabled.</p> </dd></param>	
        /// <returns><p>Returns the previous value of Mute.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXDebugMute']/*"/>	
        /// <msdn-id>bb172817</msdn-id>	
        /// <unmanaged>BOOL D3DXDebugMute([In] BOOL Mute)</unmanaged>	
        /// <unmanaged-short>D3DXDebugMute</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool DebugMute(SharpDX.Mathematics.Interop.RawBool mute) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				D3DXDebugMute_(mute);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXDebugMute", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D3DXDebugMute_(SharpDX.Mathematics.Interop.RawBool arg0);

        
        /// <summary>	
        /// <p>Verify that the version of D3DX you compiled with is the version that you are running.</p>	
        /// </summary>	
        /// <param name="d3DSdkVersion"><dd>  <p>Use <see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/>. See remarks.</p> </dd></param>	
        /// <param name="d3DXSdkVersion"><dd>  <p>Use <see cref="SharpDX.Direct3D9.D3DX9.SdkVersion"/>. See remarks.</p> </dd></param>	
        /// <returns><p>Returns <strong>TRUE</strong> if the version of D3DX you compiled against is the version you are running with; otherwise, <strong><see cref="SharpDX.Result.False"/></strong> is returned.</p></returns>	
        /// <remarks>	
        /// <p>Use this function during the initialization of your application like this:</p><pre> <see cref="SharpDX.Result"/> CD3DXMyApplication::Initialize(<see cref="System.IntPtr"/> hInstance,  LPCSTR szWindowName, LPCSTR szClassName, UINT uWidth, UINT uHeight)	
        /// { <see cref="SharpDX.Result"/> hr; if (!<see cref="SharpDX.Direct3D9.D3DX9.CheckVersion"/>(<see cref="SharpDX.Direct3D9.D3D9.SdkVersion"/>, <see cref="SharpDX.Direct3D9.D3DX9.SdkVersion"/>)) return E_FAIL; ...	
        /// }	
        /// </pre><p>Use <strong>Direct3DCreate9</strong> to verify that the correct runtime is installed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCheckVersion']/*"/>	
        /// <msdn-id>bb172717</msdn-id>	
        /// <unmanaged>BOOL D3DXCheckVersion([In] unsigned int D3DSdkVersion,[In] unsigned int D3DXSdkVersion)</unmanaged>	
        /// <unmanaged-short>D3DXCheckVersion</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool CheckVersion(int d3DSdkVersion, int d3DXSdkVersion) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				D3DXCheckVersion_(d3DSdkVersion, d3DXSdkVersion);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckVersion", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D3DXCheckVersion_(int arg0,int arg1);

        
        /// <summary>	
        /// <p>Create an effect from an ASCII or binary effect description.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to the device that will create the effect. See <strong><see cref="SharpDX.Direct3D9.Device"/></strong>.</p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p>Pointer to a buffer containing an effect description.</p> </dd></param>	
        /// <param name="srcDataLen"><dd>  <p>Length of the effect data, in bytes.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional <strong><c>null</c></strong>-terminated array of <strong><see cref="SharpDX.Direct3D9.Macro"/></strong> structures that describe preprocessor definitions. This value can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>If <em>pSrcData</em> contains a text effect, flags can be a combination of <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags and <see cref="SharpDX.Direct3D9.FX"/> flags; otherwise, <em>pSrcData</em> contains a binary effect and the only flags honored are <see cref="SharpDX.Direct3D9.FX"/> flags. The Direct3D 10 HLSL compiler is now the default. See Effect-Compiler Tool for details.</p> </dd></param>	
        /// <param name="poolRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.EffectPool"/></strong> object to use for shared parameters. If this value is <strong><c>null</c></strong>, no parameters will be shared.</p> </dd></param>	
        /// <param name="effectOut"><dd>  <p>Returns a reference to an <strong><see cref="SharpDX.Direct3D9.Effect"/></strong> interface.</p> </dd></param>	
        /// <param name="compilationErrorsOut"><dd>  <p>Returns a buffer containing a listing of compile errors.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffect']/*"/>	
        /// <msdn-id>bb172763</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffect([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataLen,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXEffectPool* pPool,[In] ID3DXEffect** ppEffect,[In] ID3DXBuffer** ppCompilationErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffect</unmanaged-short>	
        public static void CreateEffect(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataLen, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, SharpDX.Direct3D9.EffectPool poolRef, out SharpDX.Direct3D9.Effect effectOut, out SharpDX.Direct3D.Blob compilationErrorsOut) {
            unsafe {
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr effectOut_ = IntPtr.Zero;
                IntPtr compilationErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffect_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataLen, definesRef_, (void*)includeRef, flags, (void*)((poolRef == null)?IntPtr.Zero:poolRef.NativePointer), &effectOut_, &compilationErrorsOut_);		
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Effect(effectOut_);	
                compilationErrorsOut= (compilationErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compilationErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffect", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffect_(void* arg0,void* arg1,int arg2,void* arg3,void* arg4,int arg5,void* arg6,void* arg7,void* arg8);

        
        /// <summary>	
        /// <p>Disassemble an effect.</p>	
        /// </summary>	
        /// <param name="effectRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Effect"/></strong> interface that contains the effect.</p> </dd></param>	
        /// <param name="enableColorCode"><dd>  <p>Enable color coding to make the disassembly easier to read.</p> </dd></param>	
        /// <param name="disassemblyOut"><dd>  <p>Returns a buffer containing the disassembled shader. See <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXDisassembleEffect']/*"/>	
        /// <msdn-id>bb172819</msdn-id>	
        /// <unmanaged>HRESULT D3DXDisassembleEffect([In] ID3DXEffect* pEffect,[In] BOOL EnableColorCode,[In] ID3DXBuffer** ppDisassembly)</unmanaged>	
        /// <unmanaged-short>D3DXDisassembleEffect</unmanaged-short>	
        public static void DisassembleEffect(SharpDX.Direct3D9.Effect effectRef, SharpDX.Mathematics.Interop.RawBool enableColorCode, out SharpDX.Direct3D.Blob disassemblyOut) {
            unsafe {
                IntPtr disassemblyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXDisassembleEffect_((void*)((effectRef == null)?IntPtr.Zero:effectRef.NativePointer), enableColorCode, &disassemblyOut_);		
                disassemblyOut= (disassemblyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(disassemblyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXDisassembleEffect", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXDisassembleEffect_(void* arg0,SharpDX.Mathematics.Interop.RawBool arg1,void* arg2);

        
        /// <summary>	
        /// <p>Create an effect from an ASCII or binary effect description. This is an extended version of <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromResourceW"/></strong> that allows an application to control which parameters are ignored by the effects system.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="skipConstantsRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="poolRef">No documentation.</param>	
        /// <param name="effectOut">No documentation.</param>	
        /// <param name="compilationErrorsOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function is an extended version of <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromResourceW"/></strong> that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate.</p><p>This function checks each constant in pSkipConstants to see that:</p><ul> <li>It is bound to a constant register.</li> <li>It is only used in HLSL shader code.</li> </ul><p> If a constant is named in the string that is not present in the effect, it is ignored.</p><p>If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR.</p><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromResourceW"/>. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used.</p><p><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromResourceW"/> loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectFromResourceExW']/*"/>	
        /// <msdn-id>bb172771</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceExW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] const char* pSkipConstants,[In] unsigned int Flags,[In] ID3DXEffectPool* pPool,[In] ID3DXEffect** ppEffect,[In] ID3DXBuffer** ppCompilationErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectFromResourceExW</unmanaged-short>	
        public static void CreateEffectFromResourceExW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, string skipConstantsRef, int flags, SharpDX.Direct3D9.EffectPool poolRef, out SharpDX.Direct3D9.Effect effectOut, out SharpDX.Direct3D.Blob compilationErrorsOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr skipConstantsRef_ = Utilities.StringToHGlobalAnsi(skipConstantsRef);
                IntPtr effectOut_ = IntPtr.Zero;
                IntPtr compilationErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectFromResourceExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, definesRef_, (void*)includeRef, (void*)skipConstantsRef_, flags, (void*)((poolRef == null)?IntPtr.Zero:poolRef.NativePointer), &effectOut_, &compilationErrorsOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(skipConstantsRef_ );
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Effect(effectOut_);	
                compilationErrorsOut= (compilationErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compilationErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectFromResourceExW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,int arg6,void* arg7,void* arg8,void* arg9);

        
        /// <summary>	
        /// <p>Create an effect from an ASCII or binary effect description.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to the device.</p> </dd></param>	
        /// <param name="hSrcModule"><dd>  <p>Handle to a module containing the effect description. If this parameter is <strong><c>null</c></strong>, the current module will be used.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Pointer to the resource. This parameter supports both Unicode and ANSI strings. See Remarks.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional <strong><c>null</c></strong>-terminated array of <strong><see cref="SharpDX.Direct3D9.Macro"/></strong> structures that describe preprocessor definitions. This value can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>If <em>hSrcModule</em> contains a text effect, flags can be a combination of <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags and <see cref="SharpDX.Direct3D9.FX"/> flags; otherwise, <em>hSrcModule</em> contains a binary effect and the only flags honored are <see cref="SharpDX.Direct3D9.FX"/> flags. The Direct3D 10 HLSL compiler is now the default. See Effect-Compiler Tool for details.</p> </dd></param>	
        /// <param name="poolRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.EffectPool"/></strong> object to use for shared parameters. If this value is <strong><c>null</c></strong>, no parameters will be shared.</p> </dd></param>	
        /// <param name="effectOut"><dd>  <p>Returns a buffer containing the compiled effect.</p> </dd></param>	
        /// <param name="compilationErrorsOut"><dd>  <p>Returns a buffer containing a listing of compile errors.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR.</p><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromResourceW"/>. Otherwise, the function call resolves to D3DXCreateEffectFromResourceA because ANSI strings are being used.</p><p><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromResourceW"/> loads data from a resource of type RT_RCDATA. See MSDN for more information about Windows resources.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectFromResourceW']/*"/>	
        /// <msdn-id>bb172770</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectFromResourceW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXEffectPool* pPool,[In] ID3DXEffect** ppEffect,[In] ID3DXBuffer** ppCompilationErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectFromResourceW</unmanaged-short>	
        public static void CreateEffectFromResourceW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, SharpDX.Direct3D9.EffectPool poolRef, out SharpDX.Direct3D9.Effect effectOut, out SharpDX.Direct3D.Blob compilationErrorsOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr effectOut_ = IntPtr.Zero;
                IntPtr compilationErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectFromResourceW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, definesRef_, (void*)includeRef, flags, (void*)((poolRef == null)?IntPtr.Zero:poolRef.NativePointer), &effectOut_, &compilationErrorsOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Effect(effectOut_);	
                compilationErrorsOut= (compilationErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compilationErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,void* arg6,void* arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates an effect compiler from an ASCII effect description.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>Pointer to a buffer containing an effect description.</p> </dd></param>	
        /// <param name="srcDataLen"><dd>  <p>Length, in bytes, of the effect data.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional <strong><c>null</c></strong>-terminated array of <strong><see cref="SharpDX.Direct3D9.Macro"/></strong> structures that describe preprocessor definitions. This value can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Compile options identified by various flags (see <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags). The Direct3D 10 HLSL compiler is now the default. See Effect-Compiler Tool for details.</p> </dd></param>	
        /// <param name="compilerOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.EffectCompiler"/></strong> interface containing the effect compiler. </p> </dd></param>	
        /// <param name="parseErrorsOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface containing any error messages that occurred during compilation. This parameter can be set to <strong><c>null</c></strong> to ignore error messages. </p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectCompiler']/*"/>	
        /// <msdn-id>bb172764</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectCompiler([In] const void* pSrcData,[In] unsigned int SrcDataLen,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[Out, Fast] ID3DXEffectCompiler** ppCompiler,[In] ID3DXBuffer** ppParseErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectCompiler</unmanaged-short>	
        public static void CreateEffectCompiler(System.IntPtr srcDataRef, int srcDataLen, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, SharpDX.Direct3D9.EffectCompiler compilerOut, out SharpDX.Direct3D.Blob parseErrorsOut) {
            unsafe {
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr compilerOut_ = IntPtr.Zero;
                IntPtr parseErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectCompiler_((void*)srcDataRef, srcDataLen, definesRef_, (void*)includeRef, flags, &compilerOut_, &parseErrorsOut_);		
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                ((SharpDX.Direct3D9.EffectCompiler)compilerOut).NativePointer = compilerOut_;
                parseErrorsOut= (parseErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(parseErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompiler", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectCompiler_(void* arg0,int arg1,void* arg2,void* arg3,int arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Create an effect from an ASCII or binary effect description. This function is an extended version of <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromFileW"/></strong> that allows an application to control which parameters are ignored by the effects system.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="srcFileRef">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="skipConstantsRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="poolRef">No documentation.</param>	
        /// <param name="effectOut">No documentation.</param>	
        /// <param name="compilationErrorsOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function is an extended version of <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromFileW"/></strong> that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate.</p><p>This function checks each constant in pSkipConstants to see that:</p><ul> <li>It is bound to a constant register.</li> <li>It is only used in HLSL shader code.</li> </ul><p> If a constant is named in the string that is not present in the effect, it is ignored.</p><p>If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR.</p><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromFileW"/>. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectFromFileExW']/*"/>	
        /// <msdn-id>bb172769</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileExW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] const char* pSkipConstants,[In] unsigned int Flags,[In] ID3DXEffectPool* pPool,[In] ID3DXEffect** ppEffect,[In] ID3DXBuffer** ppCompilationErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectFromFileExW</unmanaged-short>	
        public static void CreateEffectFromFileExW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, string skipConstantsRef, int flags, SharpDX.Direct3D9.EffectPool poolRef, out SharpDX.Direct3D9.Effect effectOut, out SharpDX.Direct3D.Blob compilationErrorsOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr skipConstantsRef_ = Utilities.StringToHGlobalAnsi(skipConstantsRef);
                IntPtr effectOut_ = IntPtr.Zero;
                IntPtr compilationErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectFromFileExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, definesRef_, (void*)includeRef, (void*)skipConstantsRef_, flags, (void*)((poolRef == null)?IntPtr.Zero:poolRef.NativePointer), &effectOut_, &compilationErrorsOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(skipConstantsRef_ );
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Effect(effectOut_);	
                compilationErrorsOut= (compilationErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compilationErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectFromFileExW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,void* arg6,void* arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates an effect compiler from an ASCII effect description.</p>	
        /// </summary>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional <strong><c>null</c></strong>-terminated array of <strong><see cref="SharpDX.Direct3D9.Macro"/></strong> structures that describe preprocessor definitions. This value can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>Compile options identified by various flags (see <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags). The Direct3D 10 HLSL compiler is now the default. See Effect-Compiler Tool for details.</p> </dd></param>	
        /// <param name="compilerOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.EffectCompiler"/></strong> interface, containing the effect compiler. </p> </dd></param>	
        /// <param name="parseErrorsOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, containing any error messages that occurred during compilation. This parameter can be set to <strong><c>null</c></strong> to ignore error messages. </p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR.</p><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompilerFromFileW"/>. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromFileA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectCompilerFromFileW']/*"/>	
        /// <msdn-id>bb172765</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromFileW([In] const wchar_t* pSrcFile,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXEffectCompiler** ppCompiler,[In] ID3DXBuffer** ppParseErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectCompilerFromFileW</unmanaged-short>	
        public static void CreateEffectCompilerFromFileW(string srcFileRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, out SharpDX.Direct3D9.EffectCompiler compilerOut, out SharpDX.Direct3D.Blob parseErrorsOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr compilerOut_ = IntPtr.Zero;
                IntPtr parseErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectCompilerFromFileW_((void*)srcFileRef_, definesRef_, (void*)includeRef, flags, &compilerOut_, &parseErrorsOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                compilerOut= (compilerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.EffectCompiler(compilerOut_);	
                parseErrorsOut= (parseErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(parseErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectCompilerFromFileW_(void* arg0,void* arg1,void* arg2,int arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Creates an <strong><see cref="SharpDX.Direct3D9.EffectCompiler"/></strong> from an ASCII effect description.</p>	
        /// </summary>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="compilerOut">No documentation.</param>	
        /// <param name="parseErrorsOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR.</p><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectCompilerFromResourceW"/>. Otherwise, the function call resolves to D3DXCreateEffectCompilerFromResourceA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectCompilerFromResourceW']/*"/>	
        /// <msdn-id>bb172766</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectCompilerFromResourceW([In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXEffectCompiler** ppCompiler,[In] ID3DXBuffer** ppParseErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectCompilerFromResourceW</unmanaged-short>	
        public static void CreateEffectCompilerFromResourceW(System.IntPtr hSrcModule, string srcResourceRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, out SharpDX.Direct3D9.EffectCompiler compilerOut, out SharpDX.Direct3D.Blob parseErrorsOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr compilerOut_ = IntPtr.Zero;
                IntPtr parseErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectCompilerFromResourceW_((void*)hSrcModule, (void*)srcResourceRef_, definesRef_, (void*)includeRef, flags, &compilerOut_, &parseErrorsOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                compilerOut= (compilerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.EffectCompiler(compilerOut_);	
                parseErrorsOut= (parseErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(parseErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectCompilerFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectCompilerFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Create an effect from an ASCII or binary effect description.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to the device that will create the effect. See <strong><see cref="SharpDX.Direct3D9.Device"/></strong>.</p> </dd></param>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to the filename. This parameter supports both Unicode and ANSI strings. See Remarks.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>Optional <c>null</c>-terminated array of preprocessor macro definitions. See <strong><see cref="SharpDX.Direct3D9.Macro"/></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory. </p> </dd></param>	
        /// <param name="flags"><dd>  <p>If <em>pSrcFile</em> contains a text effect, flags can be a combination of <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags and <see cref="SharpDX.Direct3D9.FX"/> flags; otherwise, <em>pSrcFile</em> contains a binary effect and the only flags honored are <see cref="SharpDX.Direct3D9.FX"/> flags. The Direct3D 10 HLSL compiler is now the default. See Effect-Compiler Tool for details.</p> </dd></param>	
        /// <param name="poolRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.EffectPool"/></strong> object to use for shared parameters. If this value is <strong><c>null</c></strong>, no parameters will be shared.</p> </dd></param>	
        /// <param name="effectOut"><dd>  <p>Returns a reference to a buffer containing the compiled effect. See <strong><see cref="SharpDX.Direct3D9.Effect"/></strong>.</p> </dd></param>	
        /// <param name="compilationErrorsOut"><dd>  <p>Returns a reference to a buffer containing a listing of compile errors. See <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the LPCTSTR data type resolves to LPCSTR.</p><p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateEffectFromFileW"/>. Otherwise, the function call resolves to D3DXCreateEffectFromFileA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectFromFileW']/*"/>	
        /// <msdn-id>bb172768</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectFromFileW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXEffectPool* pPool,[In] ID3DXEffect** ppEffect,[In] ID3DXBuffer** ppCompilationErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectFromFileW</unmanaged-short>	
        public static void CreateEffectFromFileW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, SharpDX.Direct3D9.EffectPool poolRef, out SharpDX.Direct3D9.Effect effectOut, out SharpDX.Direct3D.Blob compilationErrorsOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr effectOut_ = IntPtr.Zero;
                IntPtr compilationErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectFromFileW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, definesRef_, (void*)includeRef, flags, (void*)((poolRef == null)?IntPtr.Zero:poolRef.NativePointer), &effectOut_, &compilationErrorsOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Effect(effectOut_);	
                compilationErrorsOut= (compilationErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compilationErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectFromFileW_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Create an effect pool. A pool is used to share parameters between effects.</p>	
        /// </summary>	
        /// <param name="poolOut"><dd>  <p>Returns a reference to the created pool.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>.</p><p>If the arguments are invalid, the method will return <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p><p>If the method fails, the return value will be E_FAIL.</p></returns>	
        /// <remarks>	
        /// <p>For effects within a pool, shared parameters with the same name share values. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectPool']/*"/>	
        /// <msdn-id>bb172772</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectPool([Out, Fast] ID3DXEffectPool** ppPool)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectPool</unmanaged-short>	
        public static void CreateEffectPool(SharpDX.Direct3D9.EffectPool poolOut) {
            unsafe {
                IntPtr poolOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateEffectPool_(&poolOut_);		
                ((SharpDX.Direct3D9.EffectPool)poolOut).NativePointer = poolOut_;
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectPool", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectPool_(void* arg0);

        
        /// <summary>	
        /// <p>Creates an effect from an ASCII or binary effect description. This function is an extended version of <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffect"/></strong> that allows an application to control which parameters are ignored by the effects system.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataLen">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="skipConstantsRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="poolRef">No documentation.</param>	
        /// <param name="effectOut">No documentation.</param>	
        /// <param name="compilationErrorsOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function is an extended version of <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateEffect"/></strong> that allows an application to specify which effect constants will be managed by the application. A constant that is managed by the application is ignored by the effects system. That is, the application is responsible for initializing the constant as well as saving and restoring its state whenever appropriate.</p><p>This function checks each constant in pSkipConstants to see that:</p><ul> <li>It is bound to a constant register.</li> <li>It is only used in HLSL shader code.</li> </ul><p> If a constant is named in the string that is not present in the effect, it is ignored.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateEffectEx']/*"/>	
        /// <msdn-id>bb172767</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateEffectEx([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataLen,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] const char* pSkipConstants,[In] unsigned int Flags,[In] ID3DXEffectPool* pPool,[In] ID3DXEffect** ppEffect,[In] ID3DXBuffer** ppCompilationErrors)</unmanaged>	
        /// <unmanaged-short>D3DXCreateEffectEx</unmanaged-short>	
        public static void CreateEffectEx(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataLen, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, string skipConstantsRef, int flags, SharpDX.Direct3D9.EffectPool poolRef, out SharpDX.Direct3D9.Effect effectOut, out SharpDX.Direct3D.Blob compilationErrorsOut) {
            unsafe {
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr skipConstantsRef_ = Utilities.StringToHGlobalAnsi(skipConstantsRef);
                IntPtr effectOut_ = IntPtr.Zero;
                IntPtr compilationErrorsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCreateEffectEx_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataLen, definesRef_, (void*)includeRef, (void*)skipConstantsRef_, flags, (void*)((poolRef == null)?IntPtr.Zero:poolRef.NativePointer), &effectOut_, &compilationErrorsOut_);		
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(skipConstantsRef_ );
                effectOut= (effectOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Effect(effectOut_);	
                compilationErrorsOut= (compilationErrorsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(compilationErrorsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateEffectEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateEffectEx_(void* arg0,void* arg1,int arg2,void* arg3,void* arg4,void* arg5,int arg6,void* arg7,void* arg8,void* arg9);

        
        /// <summary>	
        /// <p>Saves a mesh to a .x file.</p>	
        /// </summary>	
        /// <param name="filenameRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="meshRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the mesh to save to a .x file.</p> </dd></param>	
        /// <param name="adjacencyRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. This parameter may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="materialsRef"><dd>  <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures, containing material information to be saved in the .x file.</p> </dd></param>	
        /// <param name="effectInstancesRef"><dd>  <p>Pointer to an array of effect instances, one per attribute group in the mesh. This parameter may be <strong><c>null</c></strong>. An effect instance is a particular instance of state information used to initialize an effect. For more information, see <strong><see cref="SharpDX.Direct3D9.EffectInstance"/></strong>.</p> </dd></param>	
        /// <param name="numMaterials"><dd>  <p>Number of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures in the <em>pMaterials</em> array.</p> </dd></param>	
        /// <param name="format"><dd>  <p>A combination of file format and save options when saving an .x file. See D3DX X File Constants.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.SaveMeshToXW"/>. Otherwise, the function call resolves to D3DXSaveMeshToXA because ANSI strings are being used.</p><p>The default file format is binary; however, if a file is specified as both a binary and a text file, it will be saved as a text file. Regardless of the file format, you may also use the compressed format to reduce the file size. </p><p>The following is a typical code example of how to use this function. </p><pre> <see cref="SharpDX.Direct3D9.Mesh"/>*    m_pMesh;           // Mesh object to be saved to a .x file	
        /// <see cref="SharpDX.Direct3D9.ExtendedMaterial"/>* m_pMaterials;      // Array of material structs in the mesh	
        /// DWORD         m_dwNumMaterials;  // Number of material structs in the mesh DWORD dwFormat = <see cref="SharpDX.Direct3D9.XFileFormat.Binary"/>;  // Binary-format .x file (default)	
        /// // DWORD dwFormat = <see cref="SharpDX.Direct3D9.XFileFormat.Text"/>; // Text-format .x file // Load mesh into m_pMesh and determine values of m_pMaterials and 	
        /// // m_dwNumMaterials with calls to D3DXLoadMeshxxx or other D3DX functions // ... <see cref="SharpDX.Direct3D9.D3DX9.SaveMeshToXW"/>( L"outputxfilename.x", m_pMesh, <c>null</c>, m_pMaterials, <c>null</c>, m_dwNumMaterials, dwFormat );	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveMeshToXW']/*"/>	
        /// <msdn-id>bb205428</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveMeshToXW([In] const wchar_t* pFilename,[In] ID3DXMesh* pMesh,[In] const unsigned int* pAdjacency,[In] const D3DXMATERIAL* pMaterials,[In] const D3DXEFFECTINSTANCE* pEffectInstances,[In] unsigned int NumMaterials,[In] unsigned int Format)</unmanaged>	
        /// <unmanaged-short>D3DXSaveMeshToXW</unmanaged-short>	
        public static void SaveMeshToXW(string filenameRef, SharpDX.Direct3D9.Mesh meshRef, int adjacencyRef, ref SharpDX.Direct3D9.ExtendedMaterial materialsRef, SharpDX.Direct3D9.EffectInstance effectInstancesRef, int numMaterials, int format) {
            unsafe {
                IntPtr filenameRef_ = Utilities.StringToHGlobalUni(filenameRef);
                var materialsRef_ = new SharpDX.Direct3D9.ExtendedMaterial.__Native();
                materialsRef.__MarshalTo(ref materialsRef_);
                var effectInstancesRef_ = new SharpDX.Direct3D9.EffectInstance.__Native();
                effectInstancesRef.__MarshalTo(ref effectInstancesRef_);
                SharpDX.Result __result__;
                __result__= 
				D3DXSaveMeshToXW_((void*)filenameRef_, (void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &adjacencyRef, &materialsRef_, &effectInstancesRef_, numMaterials, format);		
                Marshal.FreeHGlobal(filenameRef_ );
                materialsRef.__MarshalFree(ref materialsRef_);
                effectInstancesRef.__MarshalFree(ref effectInstancesRef_);
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveMeshToXW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveMeshToXW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,int arg6);

        
        /// <summary>	
        /// <p>Creates an N-patch mesh from a triangle mesh.</p>	
        /// </summary>	
        /// <param name="meshSysMemRef"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface that represents the triangle mesh object.</p> </dd></param>	
        /// <param name="patchMeshRef"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.PatchMesh"/></strong> interface that represents the created patch mesh object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateNPatchMesh']/*"/>	
        /// <msdn-id>bb172782</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateNPatchMesh([In] ID3DXMesh* pMeshSysMem,[In] ID3DXPatchMesh** pPatchMesh)</unmanaged>	
        /// <unmanaged-short>D3DXCreateNPatchMesh</unmanaged-short>	
        public static void CreateNPatchMesh(SharpDX.Direct3D9.Mesh meshSysMemRef, out SharpDX.Direct3D9.PatchMesh patchMeshRef) {
            unsafe {
                IntPtr patchMeshRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateNPatchMesh_((void*)((meshSysMemRef == null)?IntPtr.Zero:meshSysMemRef.NativePointer), &patchMeshRef_);		
                patchMeshRef= (patchMeshRef_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.PatchMesh(patchMeshRef_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateNPatchMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateNPatchMesh_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Returns a declarator from a flexible vertex format (FVF) code.</p>	
        /// </summary>	
        /// <param name="fvf"><dd>  <p>Combination of <see cref="SharpDX.Direct3D9.VertexFormat"/> that describes the FVF from which to generate the returned declarator array.</p> </dd></param>	
        /// <param name="declaratorRef"><dd>  <p>An array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements describing the vertex format of the mesh vertices. The upper limit of this declarator array is <strong><see cref="SharpDX.Direct3D9.VertexFormatDeclaratorCount.Max"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: D3DXERR_INVALIDMESH.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXDeclaratorFromFVF']/*"/>	
        /// <msdn-id>bb172818</msdn-id>	
        /// <unmanaged>HRESULT D3DXDeclaratorFromFVF([In] D3DFVF FVF,[In, Buffer] D3DVERTEXELEMENT9* pDeclarator)</unmanaged>	
        /// <unmanaged-short>D3DXDeclaratorFromFVF</unmanaged-short>	
        public static SharpDX.Result DeclaratorFromFVF(SharpDX.Direct3D9.VertexFormat fvf, SharpDX.Direct3D9.VertexElement[] declaratorRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* declaratorRef_ = declaratorRef)
                    __result__= 
    				D3DXDeclaratorFromFVF_(unchecked((int)fvf), declaratorRef_);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXDeclaratorFromFVF", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXDeclaratorFromFVF_(int arg0,void* arg1);

        
        /// <summary>	
        /// <p> Compute tangent, binormal, and normal vectors for a mesh.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an input <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> mesh object.</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>Combination of one or more <strong><see cref="SharpDX.Direct3D9.TangentOptions"/></strong> flags.  </p> <p>Use <strong><c>null</c></strong> to specify the following options:</p> <ul> <li>Weight the normal vector length by the angle, in radians, subtended by the two edges leaving the vertex.</li> <li>Compute orthogonal Cartesian coordinates from the UV texture coordinates.</li> <li>Textures are not wrapped in either U or V directions</li> <li>Partial derivatives with respect to texture coordinates are normalized.</li> <li>Vertices are ordered in a counterclockwise direction around each triangle.</li> <li>Use per-vertex normal vectors already present in the input mesh.</li> <li>The results will be stored in the original input mesh. The function will fail if new vertices need to be created.</li> </ul> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function simply calls <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/></strong> with the following input parameters:</p><pre> <see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/>(pMesh, <see cref="SharpDX.Direct3D9.DeclarationUsage.TextureCoordinate"/>, 0,    <see cref="SharpDX.Direct3D9.DeclarationUsage.Binormal"/>, 0, <see cref="SharpDX.Direct3D9.DeclarationUsage.Tangent"/>, 0,  <see cref="SharpDX.Direct3D9.DeclarationUsage.Normal"/>, 0,  dwOptions | <see cref="SharpDX.Direct3D9.TangentOptions.GenerateInPlace"/>, <c>null</c>, 0.01f, 0.25f, 0.01f, <c>null</c>, <c>null</c>);	
        /// </pre><p>Singularities are handled as required by grouping edges and splitting vertices. If any vertices need to be split, the function will fail. The computed normal vector at each vertex is always normalized to have unit length.</p><p>The most robust solution for computing orthogonal Cartesian coordinates is to not set flags <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromU"/> and <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromV"/>, so that orthogonal coordinates are computed from both UV texture coordinates. However, in this case, if either U or V is zero, then the function will compute orthogonal coordinates using <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromV"/> or <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromU"/> respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeTangentFrame']/*"/>	
        /// <msdn-id>bb172744</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeTangentFrame([In] ID3DXMesh* pMesh,[In] unsigned int dwOptions)</unmanaged>	
        /// <unmanaged-short>D3DXComputeTangentFrame</unmanaged-short>	
        public static void ComputeTangentFrame(SharpDX.Direct3D9.Mesh meshRef, int dwOptions) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeTangentFrame_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), dwOptions);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangentFrame", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeTangentFrame_(void* arg0,int arg1);

        
        /// <summary>	
        /// <p>Generates an optimized face remapping for a triangle list.</p>	
        /// </summary>	
        /// <param name="bIndicesRef"><dd>  <p>Pointer to triangle list indices to use for ordering vertices.</p> </dd></param>	
        /// <param name="cFaces"><dd>  <p>Number of faces in the triangle list. For 16-bit meshes, this is limited to 2^16 - 1 (65535) or fewer faces.</p> </dd></param>	
        /// <param name="cVertices"><dd>  <p>Number of vertices referenced by the triangle list.</p> </dd></param>	
        /// <param name="b32BitIndices"><dd>  <p>Flag indicating index type: <strong>TRUE</strong> if indices are 32-bit (more than 65535 indices), <strong><see cref="SharpDX.Result.False"/></strong> if indices are 16-bit (65535 or fewer indices).</p> </dd></param>	
        /// <param name="faceRemapRef"><dd>  <p>Pointer to the original mesh face that was split to generate the current face.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function's optimization procedure is functionally equivalent to calling <strong><see cref="SharpDX.Direct3D9.Mesh.Optimize"/></strong> with the <see cref="SharpDX.Direct3D9.MeshOptimizeFlags.DeviceIndependent"/> flag, but this function makes more efficient use of vertex caches.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXOptimizeFaces']/*"/>	
        /// <msdn-id>bb205376</msdn-id>	
        /// <unmanaged>HRESULT D3DXOptimizeFaces([In] const void* pbIndices,[In] unsigned int cFaces,[In] unsigned int cVertices,[In] BOOL b32BitIndices,[In, Buffer] int* pFaceRemap)</unmanaged>	
        /// <unmanaged-short>D3DXOptimizeFaces</unmanaged-short>	
        public static SharpDX.Result OptimizeFaces(System.IntPtr bIndicesRef, int cFaces, int cVertices, SharpDX.Mathematics.Interop.RawBool b32BitIndices, int[] faceRemapRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* faceRemapRef_ = faceRemapRef)
                    __result__= 
    				D3DXOptimizeFaces_((void*)bIndicesRef, cFaces, cVertices, b32BitIndices, faceRemapRef_);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXOptimizeFaces", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXOptimizeFaces_(void* arg0,int arg1,int arg2,SharpDX.Mathematics.Interop.RawBool arg3,void* arg4);

        
        /// <summary>	
        /// <p>Welds together replicated vertices that have equal attributes. This method uses specified epsilon values for equality comparisons.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> object, the mesh from which to weld vertices.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Combination of one or more flags from <strong>D3DXWELDEPSILONSFLAGS</strong>.</p> </dd></param>	
        /// <param name="epsilonsRef"><dd>  <p>Pointer to a <strong>D3DXWeldEpsilons</strong> structure, specifying the epsilon values to be used for this method. Use <strong><c>null</c></strong> to initialize all structure members to a default value of 1.0e-6f.</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the source mesh. If the edge has no adjacent faces, the value is 0xffffffff. If this parameter is set to <strong><c>null</c></strong>, <strong><see cref="SharpDX.Direct3D9.BaseMesh.GenerateAdjacency"/></strong> will be called to create logical adjacency information.</p> </dd></param>	
        /// <param name="adjacencyOutRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the optimized mesh. If the edge has no adjacent faces, the value is 0xffffffff.</p> </dd></param>	
        /// <param name="faceRemapRef"><dd>  <p>An array of DWORDs, one per face, that identifies the original mesh face that corresponds to each face in the welded mesh.</p> </dd></param>	
        /// <param name="vertexRemapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function uses supplied adjacency information to determine the points that are replicated. Vertices are merged based on an epsilon comparison. Vertices with equal position must already have been calculated and represented by point-representative data.</p><p>This function combines logically-welded vertices that have similar components, such as normals or texture coordinates within pEpsilons.</p><p>The following example code calls this function with welding enabled. Vertices are compared using epsilon values for normal vector and vertex position. A reference is returned to a face remapping array (<em>pFaceRemap</em>).</p><pre> TCHAR            strMediaPath[512];       // X-file path 	
        /// LPD3DXBUFFER     pAdjacencyBuffer = <c>null</c>; // adjacency data buffer	
        /// LPD3DXBUFFER     pD3DXMtrlBuffer  = <c>null</c>; // material buffer	
        /// LPD3DXMESH       pMesh            = <c>null</c>; // mesh object	
        /// DWORD            m_dwNumMaterials;        // number of materials	
        /// <see cref="SharpDX.Direct3D9.WeldEpsilons"/> Epsilons;                // structure with epsilon values	
        /// DWORD            *pFaceRemap[65536];      // face remapping array	
        /// DWORD            i;                       // internal variable // Load the mesh from the specified file hr = <see cref="SharpDX.Direct3D9.D3DX9.LoadMeshFromXW"/> ( strMediaPath, <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/>, m_pd3dDevice, &amp;pAdjacencyBuffer, &amp;pD3DXMtrlBuffer, <c>null</c>, &amp;m_dwNumMaterials, &amp;pMesh ) ) if( FAILED( hr ) )  goto End;              // Go to error handling // Set epsilon values Epsilons.Normal = 0.001; Epsilons.Position = 0.1; // Weld the vertices for( i=0; i &lt; 65536; i++ ) {  pFaceRemap[i] = 0;  } hr = <see cref="SharpDX.Direct3D9.D3DX9.WeldVertices"/> ( pMesh, <see cref="SharpDX.Direct3D9.WeldFlags.WeldPartialMatches"/>, &amp;Epsilons, (DWORD*)pAdjacencyBuffer-&gt;GetBufferPointer(), (DWORD*)pAdjacencyBuffer-&gt;GetBufferPointer(), (DWORD*)pFaceRemap, <c>null</c> ) if( FAILED( hr ) )  goto End;              // Go to error handling	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXWeldVertices']/*"/>	
        /// <msdn-id>bb205562</msdn-id>	
        /// <unmanaged>HRESULT D3DXWeldVertices([In] ID3DXMesh* pMesh,[In] unsigned int Flags,[In] const D3DXWELDEPSILONS* pEpsilons,[In] const unsigned int* pAdjacencyIn,[In] unsigned int* pAdjacencyOut,[In] unsigned int* pFaceRemap,[In] ID3DXBuffer** ppVertexRemap)</unmanaged>	
        /// <unmanaged-short>D3DXWeldVertices</unmanaged-short>	
        public static void WeldVertices(SharpDX.Direct3D9.Mesh meshRef, int flags, ref SharpDX.Direct3D9.WeldEpsilons epsilonsRef, int adjacencyInRef, int adjacencyOutRef, int faceRemapRef, out SharpDX.Direct3D.Blob vertexRemapOut) {
            unsafe {
                var epsilonsRef_ = new SharpDX.Direct3D9.WeldEpsilons.__Native();
                epsilonsRef.__MarshalTo(ref epsilonsRef_);
                IntPtr vertexRemapOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXWeldVertices_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), flags, &epsilonsRef_, &adjacencyInRef, &adjacencyOutRef, &faceRemapRef, &vertexRemapOut_);		
                epsilonsRef.__MarshalFree(ref epsilonsRef_);
                vertexRemapOut= (vertexRemapOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXWeldVertices", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXWeldVertices_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Generates an output vertex declaration from the input declaration. The output declaration is intended for use by the mesh tessellation functions.</p>	
        /// </summary>	
        /// <param name="outputRef"><dd>  <p>Pointer to the output vertex declaration. See <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>.</p> </dd></param>	
        /// <param name="inputRef"><dd>  <p>Pointer to the input vertex declaration. See <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGenerateOutputDecl']/*"/>	
        /// <msdn-id>bb172861</msdn-id>	
        /// <unmanaged>HRESULT D3DXGenerateOutputDecl([In, Buffer] D3DVERTEXELEMENT9* pOutput,[In, Buffer] const D3DVERTEXELEMENT9* pInput)</unmanaged>	
        /// <unmanaged-short>D3DXGenerateOutputDecl</unmanaged-short>	
        public static SharpDX.Result GenerateOutputDecl(SharpDX.Direct3D9.VertexElement[] outputRef, SharpDX.Direct3D9.VertexElement[] inputRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* outputRef_ = outputRef)
                    fixed (void* inputRef_ = inputRef)
                        __result__= 
        				D3DXGenerateOutputDecl_(outputRef_, inputRef_);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGenerateOutputDecl", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGenerateOutputDecl_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Creates a buffer object.</p>	
        /// </summary>	
        /// <param name="numBytes"><dd>  <p>Size of the buffer to create, in bytes.</p> </dd></param>	
        /// <param name="bufferOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface, representing the created buffer object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateBuffer']/*"/>	
        /// <msdn-id>bb172753</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateBuffer([In] unsigned int NumBytes,[In] ID3DXBuffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>D3DXCreateBuffer</unmanaged-short>	
        public static void CreateBuffer(int numBytes, out SharpDX.Direct3D.Blob bufferOut) {
            unsafe {
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateBuffer_(numBytes, &bufferOut_);		
                bufferOut= (bufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(bufferOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateBuffer", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateBuffer_(int arg0,void* arg1);

        
        /// <summary>	
        /// <p>Loads a patch mesh from an <strong><see cref="SharpDX.Direct3D9.XFileData"/></strong> object.</p>	
        /// </summary>	
        /// <param name="xofObjMeshRef">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="materialsOut">No documentation.</param>	
        /// <param name="effectInstancesOut">No documentation.</param>	
        /// <param name="numMaterialsRef">No documentation.</param>	
        /// <param name="meshOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure.</p><p>The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadPatchMeshFromXof']/*"/>	
        /// <msdn-id>bb172896</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadPatchMeshFromXof([In] ID3DXFileData* pXofObjMesh,[In] unsigned int Options,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXBuffer** ppMaterials,[In] ID3DXBuffer** ppEffectInstances,[In] unsigned int* pNumMaterials,[In] ID3DXPatchMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXLoadPatchMeshFromXof</unmanaged-short>	
        public static void LoadPatchMeshFromXof(SharpDX.Direct3D9.XFileData xofObjMeshRef, int options, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D.Blob materialsOut, out SharpDX.Direct3D.Blob effectInstancesOut, int numMaterialsRef, out SharpDX.Direct3D9.PatchMesh meshOut) {
            unsafe {
                IntPtr materialsOut_ = IntPtr.Zero;
                IntPtr effectInstancesOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadPatchMeshFromXof_((void*)((xofObjMeshRef == null)?IntPtr.Zero:xofObjMeshRef.NativePointer), options, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &materialsOut_, &effectInstancesOut_, &numMaterialsRef, &meshOut_);		
                materialsOut= (materialsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(materialsOut_);	
                effectInstancesOut= (effectInstancesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectInstancesOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.PatchMesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadPatchMeshFromXof", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadPatchMeshFromXof_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Tessellates the given mesh using the N-patch tessellation scheme.</p>	
        /// </summary>	
        /// <param name="meshInRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the mesh to tessellate.</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the source mesh. This parameter may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="numSegs"><dd>  <p>Number of segments per edge to tessellate.</p> </dd></param>	
        /// <param name="quadraticInterpNormals"><dd>  <p>Set to <strong>TRUE</strong> to use quadratic interpolation for normals; set to <strong><see cref="SharpDX.Result.False"/></strong> for linear interpolation.</p> </dd></param>	
        /// <param name="meshOutOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the returned tessellated mesh.</p> </dd></param>	
        /// <param name="adjacencyOutOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. If the value of this parameter is not set to <strong><c>null</c></strong>, this buffer will contain an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. This parameter may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function tessellates by using the N-patch algorithm.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXTessellateNPatches']/*"/>	
        /// <msdn-id>bb205469</msdn-id>	
        /// <unmanaged>HRESULT D3DXTessellateNPatches([In] ID3DXMesh* pMeshIn,[In] const unsigned int* pAdjacencyIn,[In] float NumSegs,[In] BOOL QuadraticInterpNormals,[In] ID3DXMesh** ppMeshOut,[In] ID3DXBuffer** ppAdjacencyOut)</unmanaged>	
        /// <unmanaged-short>D3DXTessellateNPatches</unmanaged-short>	
        public static void TessellateNPatches(SharpDX.Direct3D9.Mesh meshInRef, int adjacencyInRef, float numSegs, SharpDX.Mathematics.Interop.RawBool quadraticInterpNormals, out SharpDX.Direct3D9.Mesh meshOutOut, out SharpDX.Direct3D.Blob adjacencyOutOut) {
            unsafe {
                IntPtr meshOutOut_ = IntPtr.Zero;
                IntPtr adjacencyOutOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXTessellateNPatches_((void*)((meshInRef == null)?IntPtr.Zero:meshInRef.NativePointer), &adjacencyInRef, numSegs, quadraticInterpNormals, &meshOutOut_, &adjacencyOutOut_);		
                meshOutOut= (meshOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOutOut_);	
                adjacencyOutOut= (adjacencyOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOutOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateNPatches", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXTessellateNPatches_(void* arg0,void* arg1,float arg2,SharpDX.Mathematics.Interop.RawBool arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Calculates per-triangle IMT's from a custom application-specified signal that varies over the surface of the mesh (generally at a higher frequency than vertex data). The signal is evaluated via a user-specified callback function.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>A reference to an input mesh (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>) which contains the object geometry for calculating the IMT.</p> </dd></param>	
        /// <param name="dwTextureIndex"><dd>  <p>Zero-based texture coordinate index that identifies which set of texture coordinates to use.</p> </dd></param>	
        /// <param name="uSignalDimension"><dd>  <p>The number of components in each data point in the signal.</p> </dd></param>	
        /// <param name="fMaxUVDistance"><dd>  <p>The maximum distance between vertices; the algorithm continues  subdividing until the distance between all vertices is less than or equal to fMaxUVDistance.</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>Texture wrap options. This is a combination of one or more <strong><see cref="SharpDX.Direct3D9.UVAtlasQuality"/> FLAGS</strong>.</p> </dd></param>	
        /// <param name="signalCallbackRef"><dd>  <p>A reference to a user-provided evaluator function, which will be used to compute the signal value at arbitrary U,V coordinates. The function follows the prototype of LPD3DXIMTSIGNALCALLBACK.</p> </dd></param>	
        /// <param name="userDataRef"><dd>  <p>A reference to a user-defined value which is passed to the signal callback function. Typically used by an application to pass a reference to a data structure that provides context information for the callback function.</p> </dd></param>	
        /// <param name="statusCallbackRef"><dd>  <p>A reference to a callback function to monitor IMT computation progress.</p> </dd></param>	
        /// <param name="userContextRef"><dd>  <p>A reference to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a reference to a data structure that provides context information for the callback function.</p> </dd></param>	
        /// <param name="iMTDataOut"><dd>  <p>A reference to the buffer (see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>) containing the returned IMT array. This array can be provided as input to the D3DX UVAtlas Functions to prioritize texture-space allocation in the texture parameterization.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>; otherwise, the value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This function requires that the input mesh contain a signal-to-mesh texture mapping (ie. texture coordinates). It allows the user to define a signal arbitrarily over the surface of the mesh.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeIMTFromSignal']/*"/>	
        /// <msdn-id>bb172739</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeIMTFromSignal([In] ID3DXMesh* pMesh,[In] unsigned int dwTextureIndex,[In] unsigned int uSignalDimension,[In] float fMaxUVDistance,[In] unsigned int dwOptions,[In] __function__stdcall* pSignalCallback,[In] void* pUserData,[In] __function__stdcall* pStatusCallback,[In] void* pUserContext,[In] ID3DXBuffer** ppIMTData)</unmanaged>	
        /// <unmanaged-short>D3DXComputeIMTFromSignal</unmanaged-short>	
        public static void ComputeIMTFromSignal(SharpDX.Direct3D9.Mesh meshRef, int dwTextureIndex, int uSignalDimension, float fMaxUVDistance, int dwOptions, SharpDX.FunctionCallback signalCallbackRef, System.IntPtr userDataRef, SharpDX.FunctionCallback statusCallbackRef, System.IntPtr userContextRef, out SharpDX.Direct3D.Blob iMTDataOut) {
            unsafe {
                IntPtr iMTDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeIMTFromSignal_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), dwTextureIndex, uSignalDimension, fMaxUVDistance, dwOptions, signalCallbackRef, (void*)userDataRef, statusCallbackRef, (void*)userContextRef, &iMTDataOut_);		
                iMTDataOut= (iMTDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(iMTDataOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromSignal", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeIMTFromSignal_(void* arg0,int arg1,int arg2,float arg3,int arg4,void* arg5,void* arg6,void* arg7,void* arg8,void* arg9);

        
        /// <summary>	
        /// <p>Validates a patch mesh, returning the number of degenerate vertices and patches.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.PatchMesh"/></strong> interface, representing the patch mesh to be tested.</p> </dd></param>	
        /// <param name="dwcDegenerateVertices"><dd>  <p>Returns the number of degenerate vertices in the patch mesh.</p> </dd></param>	
        /// <param name="dwcDegeneratePatches"><dd>  <p>Returns the number of degenerate patches in the patch mesh.</p> </dd></param>	
        /// <param name="errorsAndWarningsOut"><dd>  <p>Returns a reference to a buffer containing a string of errors and warnings that explain the problems found in the patch mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method validates the mesh by checking for invalid indices. Error information is available from the debugger output.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXValidPatchMesh']/*"/>	
        /// <msdn-id>bb205483</msdn-id>	
        /// <unmanaged>HRESULT D3DXValidPatchMesh([In] ID3DXPatchMesh* pMesh,[In] unsigned int* dwcDegenerateVertices,[In] unsigned int* dwcDegeneratePatches,[In] ID3DXBuffer** ppErrorsAndWarnings)</unmanaged>	
        /// <unmanaged-short>D3DXValidPatchMesh</unmanaged-short>	
        public static void ValidPatchMesh(SharpDX.Direct3D9.PatchMesh meshRef, int dwcDegenerateVertices, int dwcDegeneratePatches, out SharpDX.Direct3D.Blob errorsAndWarningsOut) {
            unsafe {
                IntPtr errorsAndWarningsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXValidPatchMesh_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &dwcDegenerateVertices, &dwcDegeneratePatches, &errorsAndWarningsOut_);		
                errorsAndWarningsOut= (errorsAndWarningsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorsAndWarningsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXValidPatchMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXValidPatchMesh_(void* arg0,void* arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Validates a mesh.</p>	
        /// </summary>	
        /// <param name="meshInRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the mesh to be tested.</p> </dd></param>	
        /// <param name="adjacencyRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be tested.</p> </dd></param>	
        /// <param name="errorsAndWarningsOut"><dd>  <p>Returns a buffer containing a string of errors and warnings, which explain the problems found in the mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: D3DXERR_INVALIDMESH, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method validates the mesh by checking for invalid indices. Error information is available from the debugger output.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXValidMesh']/*"/>	
        /// <msdn-id>bb205482</msdn-id>	
        /// <unmanaged>HRESULT D3DXValidMesh([In] ID3DXMesh* pMeshIn,[In] const unsigned int* pAdjacency,[In] ID3DXBuffer** ppErrorsAndWarnings)</unmanaged>	
        /// <unmanaged-short>D3DXValidMesh</unmanaged-short>	
        public static void ValidMesh(SharpDX.Direct3D9.Mesh meshInRef, int adjacencyRef, out SharpDX.Direct3D.Blob errorsAndWarningsOut) {
            unsafe {
                IntPtr errorsAndWarningsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXValidMesh_((void*)((meshInRef == null)?IntPtr.Zero:meshInRef.NativePointer), &adjacencyRef, &errorsAndWarningsOut_);		
                errorsAndWarningsOut= (errorsAndWarningsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorsAndWarningsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXValidMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXValidMesh_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Splits a mesh into meshes smaller than the specified size.</p>	
        /// </summary>	
        /// <param name="meshInRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the source mesh.</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be simplified.</p> </dd></param>	
        /// <param name="maxSize"><dd>  <p> Maximum number of vertices in the resulting mesh.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Option flags for the new meshes.</p> </dd></param>	
        /// <param name="meshesOutRef"><dd>  <p>Number of meshes returned.</p> </dd></param>	
        /// <param name="meshArrayOutOut"><dd>  <p>Buffer containing an array of <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interfaces for the new meshes. For a source mesh split into n meshes, <em>ppMeshArrayOut</em> is an array of n <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> references.</p> </dd></param>	
        /// <param name="adjacencyArrayOutOut"><dd>  <p>Buffer containing an array of adjacency arrays (DWORDs) for the new meshes. See <strong><see cref="SharpDX.Direct3D.Blob"/></strong>. This parameter is optional.</p> </dd></param>	
        /// <param name="faceRemapArrayOutOut"><dd>  <p>Buffer containing an array of face remap arrays (DWORDs) for the new meshes. See <strong><see cref="SharpDX.Direct3D.Blob"/></strong>. This parameter is optional.</p> </dd></param>	
        /// <param name="vertRemapArrayOutOut"><dd>  <p>Buffer containing an array of vertex remap arrays for the new meshes. See <strong><see cref="SharpDX.Direct3D.Blob"/></strong>. This parameter is optional.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>A common use of this function is to split a mesh with 32-bit indices (more than 65535 vertices) into more than one mesh, each of which has 16-bit indices.</p><p>The adjacency, vertex remap and face remap arrays are arrays are DWORDs where each array contains n DWORD references, followed by the DWORD data referenced by the references. For example, to obtain the face remap information for face 3 in mesh 2, the following code could be used, assuming the face remap data was returned in a variable named <em>ppFaceRemapArrayOut</em>.</p><pre> const DWORD **face_remaps =  static_cast&lt;DWORD **&gt;(ppFaceRemapArrayOut-&gt;GetBufferPointer());	
        /// const DWORD remap = face_remaps[2][3];	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSplitMesh']/*"/>	
        /// <msdn-id>bb205465</msdn-id>	
        /// <unmanaged>HRESULT D3DXSplitMesh([In] ID3DXMesh* pMeshIn,[In] const unsigned int* pAdjacencyIn,[In] const unsigned int MaxSize,[In] const unsigned int Options,[In] unsigned int* pMeshesOut,[In] ID3DXBuffer** ppMeshArrayOut,[In] ID3DXBuffer** ppAdjacencyArrayOut,[In] ID3DXBuffer** ppFaceRemapArrayOut,[In] ID3DXBuffer** ppVertRemapArrayOut)</unmanaged>	
        /// <unmanaged-short>D3DXSplitMesh</unmanaged-short>	
        public static void SplitMesh(SharpDX.Direct3D9.Mesh meshInRef, int adjacencyInRef, int maxSize, int options, int meshesOutRef, out SharpDX.Direct3D.Blob meshArrayOutOut, out SharpDX.Direct3D.Blob adjacencyArrayOutOut, out SharpDX.Direct3D.Blob faceRemapArrayOutOut, out SharpDX.Direct3D.Blob vertRemapArrayOutOut) {
            unsafe {
                IntPtr meshArrayOutOut_ = IntPtr.Zero;
                IntPtr adjacencyArrayOutOut_ = IntPtr.Zero;
                IntPtr faceRemapArrayOutOut_ = IntPtr.Zero;
                IntPtr vertRemapArrayOutOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXSplitMesh_((void*)((meshInRef == null)?IntPtr.Zero:meshInRef.NativePointer), &adjacencyInRef, maxSize, options, &meshesOutRef, &meshArrayOutOut_, &adjacencyArrayOutOut_, &faceRemapArrayOutOut_, &vertRemapArrayOutOut_);		
                meshArrayOutOut= (meshArrayOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(meshArrayOutOut_);	
                adjacencyArrayOutOut= (adjacencyArrayOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyArrayOutOut_);	
                faceRemapArrayOutOut= (faceRemapArrayOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(faceRemapArrayOutOut_);	
                vertRemapArrayOutOut= (vertRemapArrayOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertRemapArrayOutOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSplitMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSplitMesh_(void* arg0,void* arg1,int arg2,int arg3,void* arg4,void* arg5,void* arg6,void* arg7,void* arg8);

        
        /// <summary>	
        /// <p>Computes the tangent vectors for the texture coordinates given in the texture stage. Provided to support legacy applications. Use <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/></strong> for better results.</p>	
        /// </summary>	
        /// <param name="mesh">No documentation.</param>	
        /// <param name="texStage">No documentation.</param>	
        /// <param name="tangentIndex">No documentation.</param>	
        /// <param name="binormIndex">No documentation.</param>	
        /// <param name="wrap">No documentation.</param>	
        /// <param name="adjacencyRef">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If the mesh vertex declaration specifies tangent or binormal fields, <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangent"/></strong> will update any user-supplied tangent or binormal data. Alternatively, set TangentIndex to D3DX_DEFAULT to not update the user-supplied tangent data, or set BinormIndex to D3DX_DEFAULT to not update the user-supplied binormal data. TexStageIndex cannot be set to D3DX_DEFAULT.</p><p><strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangent"/></strong> depends on the mesh vertex declaration containing either the binormal field (BinormIndex), the tangent field (TangentIndex), or both. If both are missing, this function will fail.</p><p>This function simply calls <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/></strong> with the following input parameters:</p><pre> <see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/>( Mesh, <see cref="SharpDX.Direct3D9.DeclarationUsage.TextureCoordinate"/>, TexStageIndex, ( BinormIndex == D3DX_DEFAULT ) ? D3DX_DEFAULT : <see cref="SharpDX.Direct3D9.DeclarationUsage.Binormal"/>, // provides backward function compatibility BinormIndex, ( TangentIndex == D3DX_DEFAULT ) ? D3DX_DEFAULT : <see cref="SharpDX.Direct3D9.DeclarationUsage.Tangent"/>, TangentIndex, D3DX_DEFAULT, // do not store normals 0, ( Wrap ? <see cref="SharpDX.Direct3D9.TangentOptions.WrapUV"/> : 0 ) | <see cref="SharpDX.Direct3D9.TangentOptions.GenerateInPlace"/> | <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromU"/>, pAdjacency, -1.01f, -0.01f, -1.01f, <c>null</c>, <c>null</c>);	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeTangent']/*"/>	
        /// <msdn-id>bb172743</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeTangent([In] ID3DXMesh* Mesh,[In] unsigned int TexStage,[In] unsigned int TangentIndex,[In] unsigned int BinormIndex,[In] unsigned int Wrap,[In] const unsigned int* pAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXComputeTangent</unmanaged-short>	
        public static void ComputeTangent(SharpDX.Direct3D9.Mesh mesh, int texStage, int tangentIndex, int binormIndex, int wrap, int adjacencyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeTangent_((void*)((mesh == null)?IntPtr.Zero:mesh.NativePointer), texStage, tangentIndex, binormIndex, wrap, &adjacencyRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangent", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeTangent_(void* arg0,int arg1,int arg2,int arg3,int arg4,void* arg5);

        
        /// <summary>	
        /// <p>Determines if a ray intersects with a mesh.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.BaseMesh"/></strong> interface, representing the mesh to be tested.</p> </dd></param>	
        /// <param name="rayPosRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, specifying the point where the ray begins.</p> </dd></param>	
        /// <param name="rayDirRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, specifying the direction of the ray.</p> </dd></param>	
        /// <param name="hitRef"><dd>  <p>Pointer to a  <see cref="SharpDX.Mathematics.Interop.RawBool"/>. If the ray intersects a triangular face on the mesh, this value will be set to <strong>TRUE</strong>. Otherwise, this value is set to <strong><see cref="SharpDX.Result.False"/></strong>.</p> </dd></param>	
        /// <param name="faceIndexRef"><dd>  <p>Pointer to an index value of the face closest to the ray origin, if pHit is <strong>TRUE</strong>.</p> </dd></param>	
        /// <param name="uRef"><dd>  <p>Pointer to a barycentric hit coordinate, U.</p> </dd></param>	
        /// <param name="vRef"><dd>  <p>Pointer to a barycentric hit coordinate, V.</p> </dd></param>	
        /// <param name="distRef"><dd>  <p>Pointer to a ray intersection parameter distance.</p> </dd></param>	
        /// <param name="allHitsOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> object, containing an array of <strong>D3DXINTERSECTINFO</strong> structures.</p> </dd></param>	
        /// <param name="countOfHitsRef"><dd>  <p>Pointer to a DWORD that contains the number of entries in the ppAllHits array.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be: E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct3D9.D3DX9.Intersect"/></strong> function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1).</p><p>Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result, and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result.</p><p>Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates.</p><p>Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see Mathworld's Barycentric Coordinates Description.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXIntersect']/*"/>	
        /// <msdn-id>bb172882</msdn-id>	
        /// <unmanaged>HRESULT D3DXIntersect([In] ID3DXBaseMesh* pMesh,[In] const D3DXVECTOR3* pRayPos,[In] const D3DXVECTOR3* pRayDir,[In] BOOL* pHit,[In] unsigned int* pFaceIndex,[In] float* pU,[In] float* pV,[In] float* pDist,[In] ID3DXBuffer** ppAllHits,[In] unsigned int* pCountOfHits)</unmanaged>	
        /// <unmanaged-short>D3DXIntersect</unmanaged-short>	
        public static void Intersect(SharpDX.Direct3D9.BaseMesh meshRef, SharpDX.Mathematics.Interop.RawVector3 rayPosRef, SharpDX.Mathematics.Interop.RawVector3 rayDirRef, SharpDX.Mathematics.Interop.RawBool hitRef, int faceIndexRef, float uRef, float vRef, float distRef, out SharpDX.Direct3D.Blob allHitsOut, int countOfHitsRef) {
            unsafe {
                IntPtr allHitsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXIntersect_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &rayPosRef, &rayDirRef, &hitRef, &faceIndexRef, &uRef, &vRef, &distRef, &allHitsOut_, &countOfHitsRef);		
                allHitsOut= (allHitsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(allHitsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersect", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXIntersect_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7,void* arg8,void* arg9);

        
        /// <summary>	
        /// <p>Pack mesh partitioning data into an atlas.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an input mesh (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>) which contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates.</p> </dd></param>	
        /// <param name="uWidth"><dd>  <p>Texture width.</p> </dd></param>	
        /// <param name="uHeight"><dd>  <p>Texture height.</p> </dd></param>	
        /// <param name="fGutter"><dd>  <p>The minimum distance, in texels, between two charts on the atlas. The gutter is always scaled by the width; so, if a gutter of 2.5 is used on a 512x512 texture, then the minimum distance between two charts is 2.5 / 512.0 texels.</p> </dd></param>	
        /// <param name="dwTextureIndex"><dd>  <p>Zero-based texture coordinate index that identifies which set of texture coordinates to use.</p> </dd></param>	
        /// <param name="dwPartitionResultAdjacencyRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. It should be derived from the ppPartitionResultAdjacency returned from <strong><see cref="SharpDX.Direct3D9.D3DX9.UVAtlasPartition"/></strong>. This value cannot be <strong><c>null</c></strong>, because Pack needs to know where charts were cut in the partition step in order to find the edges of each chart.</p> </dd></param>	
        /// <param name="statusCallbackRef"><dd>  <p>A reference to a callback function (see LPD3DXUVATLASCB) that is useful for monitoring progress.</p> </dd></param>	
        /// <param name="fCallbackFrequency"><dd>  <p>Specify how often D3DX will call the callback; a reasonable default value is 0.0001f.</p> </dd></param>	
        /// <param name="userContextRef"><dd>  <p>A void reference to be passed back to the callback function.</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>This options parameter is currently reserved.</p> </dd></param>	
        /// <param name="facePartitioningRef"><dd>  <p>A reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> containing the array of the final face-partitioning. Each element contains one DWORD per face.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>; otherwise, the value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXUVAtlasPack']/*"/>	
        /// <msdn-id>bb205480</msdn-id>	
        /// <unmanaged>HRESULT D3DXUVAtlasPack([In] ID3DXMesh* pMesh,[In] unsigned int uWidth,[In] unsigned int uHeight,[In] float fGutter,[In] unsigned int dwTextureIndex,[In] const unsigned int* pdwPartitionResultAdjacency,[In] __function__stdcall* pStatusCallback,[In] float fCallbackFrequency,[In] void* pUserContext,[In] unsigned int dwOptions,[In] ID3DXBuffer* pFacePartitioning)</unmanaged>	
        /// <unmanaged-short>D3DXUVAtlasPack</unmanaged-short>	
        public static void UVAtlasPack(SharpDX.Direct3D9.Mesh meshRef, int uWidth, int uHeight, float fGutter, int dwTextureIndex, int dwPartitionResultAdjacencyRef, SharpDX.FunctionCallback statusCallbackRef, float fCallbackFrequency, System.IntPtr userContextRef, int dwOptions, SharpDX.Direct3D.Blob facePartitioningRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXUVAtlasPack_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), uWidth, uHeight, fGutter, dwTextureIndex, &dwPartitionResultAdjacencyRef, statusCallbackRef, fCallbackFrequency, (void*)userContextRef, dwOptions, (void*)((facePartitioningRef == null)?IntPtr.Zero:facePartitioningRef.NativePointer));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasPack", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXUVAtlasPack_(void* arg0,int arg1,int arg2,float arg3,int arg4,void* arg5,void* arg6,float arg7,void* arg8,int arg9,void* arg10);

        
        /// <summary>	
        /// <p>Loads a skin mesh from a DirectX .x file data object.</p>	
        /// </summary>	
        /// <param name="xofMeshRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.XFileData"/></strong> interface, representing the file data object to load.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Combination of one or more flags, from the <strong>D3DXMESH</strong> enumeration, specifying creation options for the mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object associated with the mesh.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When this method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh.</p> </dd></param>	
        /// <param name="materialsOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures.</p> </dd></param>	
        /// <param name="effectInstancesOut"><dd>  <p>Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <strong><see cref="SharpDX.Direct3D9.EffectInstance"/></strong>. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="matOutRef"><dd>  <p>Pointer to the number of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures in the  <em>ppMaterials</em> array, when the method returns.</p> </dd></param>	
        /// <param name="skinInfoOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.SkinInfo"/></strong> interface, which represents the skinning information. 									 </p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, which represents the loaded mesh. 									 </p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY</p></returns>	
        /// <remarks>	
        /// <p>This method takes a reference to an internal object in the .x file, enabling you to load the frame hierarchy.</p><p>For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure.</p><p>The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadSkinMeshFromXof']/*"/>	
        /// <msdn-id>bb172899</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadSkinMeshFromXof([In] ID3DXFileData* pxofMesh,[In] unsigned int Options,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXBuffer** ppAdjacency,[In] ID3DXBuffer** ppMaterials,[In] ID3DXBuffer** ppEffectInstances,[In] unsigned int* pMatOut,[In] ID3DXSkinInfo** ppSkinInfo,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXLoadSkinMeshFromXof</unmanaged-short>	
        public static void LoadSkinMeshFromXof(SharpDX.Direct3D9.XFileData xofMeshRef, int options, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D.Blob adjacencyOut, out SharpDX.Direct3D.Blob materialsOut, out SharpDX.Direct3D.Blob effectInstancesOut, int matOutRef, out SharpDX.Direct3D9.SkinInfo skinInfoOut, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr adjacencyOut_ = IntPtr.Zero;
                IntPtr materialsOut_ = IntPtr.Zero;
                IntPtr effectInstancesOut_ = IntPtr.Zero;
                IntPtr skinInfoOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadSkinMeshFromXof_((void*)((xofMeshRef == null)?IntPtr.Zero:xofMeshRef.NativePointer), options, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &adjacencyOut_, &materialsOut_, &effectInstancesOut_, &matOutRef, &skinInfoOut_, &meshOut_);		
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                materialsOut= (materialsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(materialsOut_);	
                effectInstancesOut= (effectInstancesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectInstancesOut_);	
                skinInfoOut= (skinInfoOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.SkinInfo(skinInfoOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSkinMeshFromXof", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadSkinMeshFromXof_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates a mesh object using a declarator.</p>	
        /// </summary>	
        /// <param name="numFaces"><dd>  <p>Number of faces for the mesh. The valid range for this number is greater than 0, and one less than the maximum DWORD (typically 65534), because the last index is reserved.</p> </dd></param>	
        /// <param name="numVertices"><dd>  <p>Number of vertices for the mesh. This parameter must be greater than 0.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Combination of one or more flags from the  <strong>D3DXMESH</strong> enumeration, specifying options for the mesh. </p> </dd></param>	
        /// <param name="declarationRef"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements, describing the vertex format for the returned mesh. This parameter must map directly to a flexible vertex format (FVF).</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object to be associated with the mesh.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the created mesh object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateMesh']/*"/>	
        /// <msdn-id>bb172780</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateMesh([In] unsigned int NumFaces,[In] unsigned int NumVertices,[In] unsigned int Options,[In] const D3DVERTEXELEMENT9* pDeclaration,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXCreateMesh</unmanaged-short>	
        public static void CreateMesh(int numFaces, int numVertices, int options, SharpDX.Direct3D9.VertexElement declarationRef, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateMesh_(numFaces, numVertices, options, &declarationRef, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &meshOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateMesh_(int arg0,int arg1,int arg2,void* arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Creates an empty skin mesh object using a flexible vertex format (FVF) code.</p>	
        /// </summary>	
        /// <param name="numVertices"><dd>  <p>Number of vertices for the skin mesh.</p> </dd></param>	
        /// <param name="fvf"><dd>  <p>Combination of <see cref="SharpDX.Direct3D9.VertexFormat"/> that describes the vertex format for the returned skin mesh.</p> </dd></param>	
        /// <param name="numBones"><dd>  <p>Number of bones for the skin mesh.</p> </dd></param>	
        /// <param name="skinInfoOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.SkinInfo"/></strong> interface, representing the created skin information object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Use <strong>SetBoneInfluence</strong> to populate the empty skin mesh object returned by this method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateSkinInfoFVF']/*"/>	
        /// <msdn-id>bb172794</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFVF([In] unsigned int NumVertices,[In] D3DFVF FVF,[In] unsigned int NumBones,[In] ID3DXSkinInfo** ppSkinInfo)</unmanaged>	
        /// <unmanaged-short>D3DXCreateSkinInfoFVF</unmanaged-short>	
        public static void CreateSkinInfoFVF(int numVertices, SharpDX.Direct3D9.VertexFormat fvf, int numBones, out SharpDX.Direct3D9.SkinInfo skinInfoOut) {
            unsafe {
                IntPtr skinInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateSkinInfoFVF_(numVertices, unchecked((int)fvf), numBones, &skinInfoOut_);		
                skinInfoOut= (skinInfoOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.SkinInfo(skinInfoOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfoFVF", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateSkinInfoFVF_(int arg0,int arg1,int arg2,void* arg3);

        
        /// <summary>	
        /// <p>Intersects the specified ray with the given mesh subset. This provides similar functionality to <strong><see cref="SharpDX.Direct3D9.D3DX9.Intersect"/></strong>.</p>	
        /// </summary>	
        /// <param name="meshRef">No documentation.</param>	
        /// <param name="attribId">No documentation.</param>	
        /// <param name="rayPosRef">No documentation.</param>	
        /// <param name="rayDirRef">No documentation.</param>	
        /// <param name="hitRef">No documentation.</param>	
        /// <param name="faceIndexRef">No documentation.</param>	
        /// <param name="uRef">No documentation.</param>	
        /// <param name="vRef">No documentation.</param>	
        /// <param name="distRef">No documentation.</param>	
        /// <param name="allHitsOut">No documentation.</param>	
        /// <param name="countOfHitsRef">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following value: E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The <strong><see cref="SharpDX.Direct3D9.D3DX9.IntersectSubset"/></strong> function provides a way to understand points in and around a triangle, independent of where the triangle is actually located. This function returns the resulting point by using the following equation: V1 + U(V2 - V1) + V(V3 - V1).</p><p>Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result.</p><p>Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates.</p><p>Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see Mathworld's Barycentric Coordinates Description.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXIntersectSubset']/*"/>	
        /// <msdn-id>bb172884</msdn-id>	
        /// <unmanaged>HRESULT D3DXIntersectSubset([In] ID3DXBaseMesh* pMesh,[In] unsigned int AttribId,[In] const D3DXVECTOR3* pRayPos,[In] const D3DXVECTOR3* pRayDir,[In] BOOL* pHit,[In] unsigned int* pFaceIndex,[In] float* pU,[In] float* pV,[In] float* pDist,[In] ID3DXBuffer** ppAllHits,[In] unsigned int* pCountOfHits)</unmanaged>	
        /// <unmanaged-short>D3DXIntersectSubset</unmanaged-short>	
        public static void IntersectSubset(SharpDX.Direct3D9.BaseMesh meshRef, int attribId, SharpDX.Mathematics.Interop.RawVector3 rayPosRef, SharpDX.Mathematics.Interop.RawVector3 rayDirRef, SharpDX.Mathematics.Interop.RawBool hitRef, int faceIndexRef, float uRef, float vRef, float distRef, out SharpDX.Direct3D.Blob allHitsOut, int countOfHitsRef) {
            unsafe {
                IntPtr allHitsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXIntersectSubset_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), attribId, &rayPosRef, &rayDirRef, &hitRef, &faceIndexRef, &uRef, &vRef, &distRef, &allHitsOut_, &countOfHitsRef);		
                allHitsOut= (allHitsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(allHitsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersectSubset", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXIntersectSubset_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7,void* arg8,void* arg9,void* arg10);

        
        /// <summary>	
        /// <p>Returns the size of a vertex for a flexible vertex format (FVF).</p>	
        /// </summary>	
        /// <param name="fvf"><dd>  <p>FVF to be queried. A combination of <see cref="SharpDX.Direct3D9.VertexFormat"/>.</p> </dd></param>	
        /// <returns><p>The FVF vertex size, in bytes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetFVFVertexSize']/*"/>	
        /// <msdn-id>bb172866</msdn-id>	
        /// <unmanaged>unsigned int D3DXGetFVFVertexSize([In] D3DFVF FVF)</unmanaged>	
        /// <unmanaged-short>D3DXGetFVFVertexSize</unmanaged-short>	
        public static int GetFVFVertexSize(SharpDX.Direct3D9.VertexFormat fvf) {
            unsafe {
                int __result__;
                __result__= 
				D3DXGetFVFVertexSize_(unchecked((int)fvf));		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetFVFVertexSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetFVFVertexSize_(int arg0);

        
        /// <summary>	
        /// <p>Returns the number of elements in the vertex declaration.</p>	
        /// </summary>	
        /// <param name="declRef"><dd>  <p>A reference to the vertex declaration. See <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>.</p> </dd></param>	
        /// <returns><p>The number of elements in the vertex declaration.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetDeclLength']/*"/>	
        /// <msdn-id>bb172863</msdn-id>	
        /// <unmanaged>unsigned int D3DXGetDeclLength([In, Buffer] const D3DVERTEXELEMENT9* pDecl)</unmanaged>	
        /// <unmanaged-short>D3DXGetDeclLength</unmanaged-short>	
        public static int GetDeclLength(SharpDX.Direct3D9.VertexElement[] declRef) {
            unsafe {
                int __result__;
                fixed (void* declRef_ = declRef)
                    __result__= 
    				D3DXGetDeclLength_(declRef_);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetDeclLength", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetDeclLength_(void* arg0);

        
        /// <summary>	
        /// <p>Cleans a mesh, preparing it for simplification.</p>	
        /// </summary>	
        /// <param name="cleanType"><dd>  <p>Vertex operations to perform in preparation for mesh cleaning. See <strong><see cref="SharpDX.Direct3D9.CleanType"/></strong>.</p> </dd></param>	
        /// <param name="meshInRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the mesh to be cleaned.</p> </dd></param>	
        /// <param name="adjacencyInRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh to be cleaned.</p> </dd></param>	
        /// <param name="meshOutOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the returned cleaned mesh. The same mesh is returned that was passed in if no cleaning was necessary.</p> </dd></param>	
        /// <param name="adjacencyOutRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the output mesh.</p> </dd></param>	
        /// <param name="errorsAndWarningsOut"><dd>  <p>Returns a buffer containing a string of errors and warnings, which explain the problems found in the mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function cleans a mesh using the cleaning method and options specified in the CleanType parameter. See the <strong><see cref="SharpDX.Direct3D9.CleanType"/></strong> enumeration for a description of the available options.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCleanMesh']/*"/>	
        /// <msdn-id>bb172719</msdn-id>	
        /// <unmanaged>HRESULT D3DXCleanMesh([In] D3DXCLEANTYPE CleanType,[In] ID3DXMesh* pMeshIn,[In] const unsigned int* pAdjacencyIn,[In] ID3DXMesh** ppMeshOut,[In] unsigned int* pAdjacencyOut,[In] ID3DXBuffer** ppErrorsAndWarnings)</unmanaged>	
        /// <unmanaged-short>D3DXCleanMesh</unmanaged-short>	
        public static void CleanMesh(SharpDX.Direct3D9.CleanType cleanType, SharpDX.Direct3D9.Mesh meshInRef, int adjacencyInRef, out SharpDX.Direct3D9.Mesh meshOutOut, int adjacencyOutRef, out SharpDX.Direct3D.Blob errorsAndWarningsOut) {
            unsafe {
                IntPtr meshOutOut_ = IntPtr.Zero;
                IntPtr errorsAndWarningsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCleanMesh_(unchecked((int)cleanType), (void*)((meshInRef == null)?IntPtr.Zero:meshInRef.NativePointer), &adjacencyInRef, &meshOutOut_, &adjacencyOutRef, &errorsAndWarningsOut_);		
                meshOutOut= (meshOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOutOut_);	
                errorsAndWarningsOut= (errorsAndWarningsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorsAndWarningsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCleanMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCleanMesh_(int arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Computes the intersection of a ray and a triangle.</p>	
        /// </summary>	
        /// <param name="arg0Ref"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, describing the first triangle vertex position.</p> </dd></param>	
        /// <param name="arg1Ref"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, describing the second triangle vertex position.</p> </dd></param>	
        /// <param name="arg2Ref"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, describing the third triangle vertex position.</p> </dd></param>	
        /// <param name="rayPosRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, specifying the point where the ray begins.</p> </dd></param>	
        /// <param name="rayDirRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, specifying the direction of the ray.</p> </dd></param>	
        /// <param name="uRef"><dd>  <p>Barycentric hit coordinates, U.</p> </dd></param>	
        /// <param name="vRef"><dd>  <p>Barycentric hit coordinates, V.</p> </dd></param>	
        /// <param name="distRef"><dd>  <p>Ray-intersection parameter distance.</p> </dd></param>	
        /// <returns><p>Returns <strong>TRUE</strong> if the ray intersects the area of the triangle. Otherwise, returns <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>Any point in the plane V1V2V3 can be represented by the barycentric coordinate (U,V). The parameter U controls how much V2 gets weighted into the result, and the parameter V controls how much V3 gets weighted into the result. Lastly, the value of [1 - (U + V)] controls how much V1 gets weighted into the result.</p><p>Barycentric coordinates are a form of general coordinates. In this context, using barycentric coordinates represents a change in coordinate systems. What holds true for Cartesian coordinates holds true for barycentric coordinates.</p><p>Barycentric coordinates define a point inside a triangle in terms of the triangle's vertices.  For a more in-depth description of barycentric coordinates, see Mathworld's Barycentric Coordinates Description.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXIntersectTri']/*"/>	
        /// <msdn-id>bb204928</msdn-id>	
        /// <unmanaged>BOOL D3DXIntersectTri([In] const D3DXVECTOR3* p0,[In] const D3DXVECTOR3* p1,[In] const D3DXVECTOR3* p2,[In] const D3DXVECTOR3* pRayPos,[In] const D3DXVECTOR3* pRayDir,[In] float* pU,[In] float* pV,[In] float* pDist)</unmanaged>	
        /// <unmanaged-short>D3DXIntersectTri</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool IntersectTri(SharpDX.Mathematics.Interop.RawVector3 arg0Ref, SharpDX.Mathematics.Interop.RawVector3 arg1Ref, SharpDX.Mathematics.Interop.RawVector3 arg2Ref, SharpDX.Mathematics.Interop.RawVector3 rayPosRef, SharpDX.Mathematics.Interop.RawVector3 rayDirRef, float uRef, float vRef, float distRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				D3DXIntersectTri_(&arg0Ref, &arg1Ref, &arg2Ref, &rayPosRef, &rayDirRef, &uRef, &vRef, &distRef);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXIntersectTri", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D3DXIntersectTri_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Converts the specified mesh subset into a single triangle strip.</p>	
        /// </summary>	
        /// <param name="meshIn"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.BaseMesh"/></strong> interface, representing the mesh to convert to a strip.</p> </dd></param>	
        /// <param name="attribId"><dd>  <p>Attribute ID of the mesh subset to convert to strips.</p> </dd></param>	
        /// <param name="iBOptions"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration, specifying options for creating the index buffer. Cannot be <see cref="SharpDX.Direct3D9.MeshFlags.Use32Bit"/>. The index buffer will be created with 32-bit or 16-bit indices, depending on the format of the index buffer of the mesh specified by the <em>MeshIn</em> parameter.</p> </dd></param>	
        /// <param name="indexBufferOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface, representing the index buffer containing the strip.</p> </dd></param>	
        /// <param name="numIndicesRef"><dd>  <p>Number of indices in the buffer returned in the <em>ppIndexBuffer</em> parameter.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Before running this function, call <strong>Optimize</strong> or <strong><see cref="SharpDX.Direct3D9.D3DX9.OptimizeFaces"/></strong>, with the <see cref="SharpDX.Direct3D9.MeshOptimizeFlags.AttributeSort"/> flag set.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXConvertMeshSubsetToSingleStrip']/*"/>	
        /// <msdn-id>bb172749</msdn-id>	
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToSingleStrip([In] ID3DXBaseMesh* MeshIn,[In] unsigned int AttribId,[In] unsigned int IBOptions,[In] IDirect3DIndexBuffer9** ppIndexBuffer,[In] unsigned int* pNumIndices)</unmanaged>	
        /// <unmanaged-short>D3DXConvertMeshSubsetToSingleStrip</unmanaged-short>	
        public static void ConvertMeshSubsetToSingleStrip(SharpDX.Direct3D9.BaseMesh meshIn, int attribId, int iBOptions, out SharpDX.Direct3D9.IndexBuffer indexBufferOut, int numIndicesRef) {
            unsafe {
                IntPtr indexBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXConvertMeshSubsetToSingleStrip_((void*)((meshIn == null)?IntPtr.Zero:meshIn.NativePointer), attribId, iBOptions, &indexBufferOut_, &numIndicesRef);		
                indexBufferOut= (indexBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.IndexBuffer(indexBufferOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXConvertMeshSubsetToSingleStrip", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXConvertMeshSubsetToSingleStrip_(void* arg0,int arg1,int arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Creates an empty skin mesh object using a declarator.</p>	
        /// </summary>	
        /// <param name="numVertices"><dd>  <p>Number of vertices for the skin mesh.</p> </dd></param>	
        /// <param name="declarationRef"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements, describing the vertex format for the returned mesh.</p> </dd></param>	
        /// <param name="numBones"><dd>  <p>Number of bones for the skin mesh.</p> </dd></param>	
        /// <param name="skinInfoOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.SkinInfo"/></strong> interface, representing the created skin mesh object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be: E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Use <strong>SetBoneInfluence</strong> to populate the empty skin mesh object returned by this method.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateSkinInfo']/*"/>	
        /// <msdn-id>bb172792</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateSkinInfo([In] unsigned int NumVertices,[In] const D3DVERTEXELEMENT9* pDeclaration,[In] unsigned int NumBones,[In] ID3DXSkinInfo** ppSkinInfo)</unmanaged>	
        /// <unmanaged-short>D3DXCreateSkinInfo</unmanaged-short>	
        public static void CreateSkinInfo(int numVertices, SharpDX.Direct3D9.VertexElement declarationRef, int numBones, out SharpDX.Direct3D9.SkinInfo skinInfoOut) {
            unsafe {
                IntPtr skinInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateSkinInfo_(numVertices, &declarationRef, numBones, &skinInfoOut_);		
                skinInfoOut= (skinInfoOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.SkinInfo(skinInfoOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfo", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateSkinInfo_(int arg0,void* arg1,int arg2,void* arg3);

        
        /// <summary>	
        /// <p>Returns the size of a vertex from the vertex declaration.</p>	
        /// </summary>	
        /// <param name="declRef"><dd>  <p>A reference to the vertex declaration. See <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>.</p> </dd></param>	
        /// <param name="stream"><dd>  <p>The zero-based stream index.</p> </dd></param>	
        /// <returns><p>The vertex declaration size, in bytes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetDeclVertexSize']/*"/>	
        /// <msdn-id>bb172864</msdn-id>	
        /// <unmanaged>unsigned int D3DXGetDeclVertexSize([In, Buffer] const D3DVERTEXELEMENT9* pDecl,[In] unsigned int Stream)</unmanaged>	
        /// <unmanaged-short>D3DXGetDeclVertexSize</unmanaged-short>	
        public static int GetDeclVertexSize(SharpDX.Direct3D9.VertexElement[] declRef, int stream) {
            unsafe {
                int __result__;
                fixed (void* declRef_ = declRef)
                    __result__= 
    				D3DXGetDeclVertexSize_(declRef_, stream);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetDeclVertexSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetDeclVertexSize_(void* arg0,int arg1);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="meshRef">No documentation.</param>	
        /// <param name="adjacencyRef">No documentation.</param>	
        /// <param name="vertexAttributeWeightsRef">No documentation.</param>	
        /// <param name="vertexWeightsRef">No documentation.</param>	
        /// <param name="minValue">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <param name="pMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGeneratePMesh']/*"/>	
        /// <unmanaged>HRESULT D3DXGeneratePMesh([In] ID3DXMesh* pMesh,[In] const unsigned int* pAdjacency,[In] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[In] const float* pVertexWeights,[In] unsigned int MinValue,[In] unsigned int Options,[In] ID3DXPMesh** ppPMesh)</unmanaged>	
        /// <unmanaged-short>D3DXGeneratePMesh</unmanaged-short>	
        public static void GeneratePMesh(SharpDX.Direct3D9.Mesh meshRef, int adjacencyRef, ref SharpDX.Direct3D9.AttributeWeights vertexAttributeWeightsRef, float vertexWeightsRef, int minValue, int options, out SharpDX.Direct3D9.ProgressiveMesh pMeshOut) {
            unsafe {
                var vertexAttributeWeightsRef_ = new SharpDX.Direct3D9.AttributeWeights.__Native();
                vertexAttributeWeightsRef.__MarshalTo(ref vertexAttributeWeightsRef_);
                IntPtr pMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXGeneratePMesh_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &adjacencyRef, &vertexAttributeWeightsRef_, &vertexWeightsRef, minValue, options, &pMeshOut_);		
                vertexAttributeWeightsRef.__MarshalFree(ref vertexAttributeWeightsRef_);
                pMeshOut= (pMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ProgressiveMesh(pMeshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGeneratePMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGeneratePMesh_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,int arg5,void* arg6);

        
        /// <summary>	
        /// <p>Tessellates a rectangular higher-order surface patch into a triangle mesh.</p>	
        /// </summary>	
        /// <param name="vBRef"><dd>  <p>Vertex buffer containing the patch data.</p> </dd></param>	
        /// <param name="numSegsRef"><dd>  <p>Pointer to an array of four floating-point values that identify the number of segments into which each edge of the rectangle patch should be divided when tessellated. See <strong><see cref="SharpDX.Direct3D9.RectanglePatchInfo"/></strong>.</p> </dd></param>	
        /// <param name="dwInDeclRef"><dd>  <p>Vertex declaration structure that defines the vertex data. See <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>.</p> </dd></param>	
        /// <param name="rectPatchInfoRef"><dd>  <p>Describes a rectangular patch. See <strong><see cref="SharpDX.Direct3D9.RectanglePatchInfo"/></strong>.</p> </dd></param>	
        /// <param name="meshRef"><dd>  <p>Pointer to the created mesh. See <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Use <strong><see cref="SharpDX.Direct3D9.D3DX9.RectPatchSize"/></strong> to get the number of output vertices and indices that the tessellation function needs.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXTessellateRectPatch']/*"/>	
        /// <msdn-id>bb205470</msdn-id>	
        /// <unmanaged>HRESULT D3DXTessellateRectPatch([In] IDirect3DVertexBuffer9* pVB,[In] const float* pNumSegs,[In] const D3DVERTEXELEMENT9* pdwInDecl,[In] const D3DRECTPATCH_INFO* pRectPatchInfo,[In] ID3DXMesh* pMesh)</unmanaged>	
        /// <unmanaged-short>D3DXTessellateRectPatch</unmanaged-short>	
        public static void TessellateRectPatch(SharpDX.Direct3D9.VertexBuffer vBRef, float numSegsRef, SharpDX.Direct3D9.VertexElement dwInDeclRef, ref SharpDX.Direct3D9.RectanglePatchInfo rectPatchInfoRef, SharpDX.Direct3D9.Mesh meshRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* rectPatchInfoRef_ = &rectPatchInfoRef)
                    __result__= 
    				D3DXTessellateRectPatch_((void*)((vBRef == null)?IntPtr.Zero:vBRef.NativePointer), &numSegsRef, &dwInDeclRef, rectPatchInfoRef_, (void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateRectPatch", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXTessellateRectPatch_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Returns a flexible vertex format (FVF) code from a declarator.</p>	
        /// </summary>	
        /// <param name="declaratorRef"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements, describing the FVF code.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a  DWORD value, representing the returned combination of <see cref="SharpDX.Direct3D9.VertexFormat"/> that describes the vertex format returned from the declarator.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This function will fail for any declarator that does not map directly to an FVF.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFVFFromDeclarator']/*"/>	
        /// <msdn-id>bb172854</msdn-id>	
        /// <unmanaged>HRESULT D3DXFVFFromDeclarator([In, Buffer] const D3DVERTEXELEMENT9* pDeclarator,[Out] D3DFVF* pFVF)</unmanaged>	
        /// <unmanaged-short>D3DXFVFFromDeclarator</unmanaged-short>	
        public static SharpDX.Direct3D9.VertexFormat FVFFromDeclarator(SharpDX.Direct3D9.VertexElement[] declaratorRef) {
            unsafe {
                SharpDX.Direct3D9.VertexFormat fVFRef;
                SharpDX.Result __result__;
                fixed (void* declaratorRef_ = declaratorRef)
                    __result__= 
    				D3DXFVFFromDeclarator_(declaratorRef_, &fVFRef);		
                __result__.CheckError();
                return fVFRef;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFVFFromDeclarator", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFVFFromDeclarator_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Computes a coordinate-axis oriented bounding box.</p>	
        /// </summary>	
        /// <param name="firstPositionRef"><dd>  <p>Pointer to the first position.</p> </dd></param>	
        /// <param name="numVertices"><dd>  <p>Number of vertices.</p> </dd></param>	
        /// <param name="dwStride"><dd>  <p>Count or number of bytes between vertices.</p> </dd></param>	
        /// <param name="minRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, describing the returned lower-left corner of the bounding box.</p> </dd></param>	
        /// <param name="maxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, describing the returned upper-right corner of the bounding box.</p> <p></p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeBoundingBox']/*"/>	
        /// <msdn-id>bb204920</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeBoundingBox([In] const D3DXVECTOR3* pFirstPosition,[In] unsigned int NumVertices,[In] unsigned int dwStride,[In] D3DXVECTOR3* pMin,[In] D3DXVECTOR3* pMax)</unmanaged>	
        /// <unmanaged-short>D3DXComputeBoundingBox</unmanaged-short>	
        public static void ComputeBoundingBox(SharpDX.Mathematics.Interop.RawVector3 firstPositionRef, int numVertices, int dwStride, SharpDX.Mathematics.Interop.RawVector3 minRef, SharpDX.Mathematics.Interop.RawVector3 maxRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeBoundingBox_(&firstPositionRef, numVertices, dwStride, &minRef, &maxRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeBoundingBox", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeBoundingBox_(void* arg0,int arg1,int arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Creates a skin mesh from another mesh.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.BaseMesh"/></strong> object, the mesh from which to create the skin mesh.</p> </dd></param>	
        /// <param name="numBones"><dd>  <p>The length of the array attached to the BoneId. See <strong><see cref="SharpDX.Direct3D9.BoneCombination"/></strong>.</p> </dd></param>	
        /// <param name="boneCombinationTableRef"><dd>  <p>Pointer to an array of bone combinations. See <strong><see cref="SharpDX.Direct3D9.BoneCombination"/></strong>.</p> </dd></param>	
        /// <param name="skinInfoOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.SkinInfo"/></strong> interface representing the created skin mesh object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following: E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateSkinInfoFromBlendedMesh']/*"/>	
        /// <msdn-id>bb172793</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateSkinInfoFromBlendedMesh([In] ID3DXBaseMesh* pMesh,[In] unsigned int NumBones,[In] const D3DXBONECOMBINATION* pBoneCombinationTable,[In] ID3DXSkinInfo** ppSkinInfo)</unmanaged>	
        /// <unmanaged-short>D3DXCreateSkinInfoFromBlendedMesh</unmanaged-short>	
        public static void CreateSkinInfoFromBlendedMesh(SharpDX.Direct3D9.BaseMesh meshRef, int numBones, SharpDX.Direct3D9.BoneCombination boneCombinationTableRef, out SharpDX.Direct3D9.SkinInfo skinInfoOut) {
            unsafe {
                var boneCombinationTableRef_ = new SharpDX.Direct3D9.BoneCombination.__Native();
                boneCombinationTableRef.__MarshalTo(ref boneCombinationTableRef_);
                IntPtr skinInfoOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateSkinInfoFromBlendedMesh_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), numBones, &boneCombinationTableRef_, &skinInfoOut_);		
                boneCombinationTableRef.__MarshalFree(ref boneCombinationTableRef_);
                skinInfoOut= (skinInfoOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.SkinInfo(skinInfoOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSkinInfoFromBlendedMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateSkinInfoFromBlendedMesh_(void* arg0,int arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Performs tangent frame computations on a mesh. Tangent, binormal, and optionally normal vectors are generated. Singularities are handled as required by grouping edges and splitting vertices.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an input <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> mesh object.</p> </dd></param>	
        /// <param name="dwTextureInSemantic"><dd>  <p>Specifies the texture coordinate input semantic. If D3DX_DEFAULT, the function assumes that there are no texture coordinates, and the function will fail unless normal vector calculation is specified.</p> </dd></param>	
        /// <param name="dwTextureInIndex"><dd>  <p>If a mesh has multiple texture coordinates, specifies the texture coordinate to use for the tangent frame computations. If zero, the mesh has only a single texture coordinate.</p> </dd></param>	
        /// <param name="dwUPartialOutSemantic"><dd>  <p>Specifies the output semantic for the type, typically <see cref="SharpDX.Direct3D9.DeclarationUsage.Tangent"/>, that describes where the partial derivative with respect to the U texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored.</p> </dd></param>	
        /// <param name="dwUPartialOutIndex"><dd>  <p>Specifies the semantic index at which to store the partial derivative with respect to the U texture coordinate.</p> </dd></param>	
        /// <param name="dwVPartialOutSemantic"><dd>  <p>Specifies the <strong><see cref="SharpDX.Direct3D9.DeclarationUsage"/></strong> type, typically <see cref="SharpDX.Direct3D9.DeclarationUsage.Binormal"/>, that describes where the partial derivative with respect to the V texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored.</p> </dd></param>	
        /// <param name="dwVPartialOutIndex"><dd>  <p>Specifies the semantic index at which to store the partial derivative with respect to the V texture coordinate.</p> </dd></param>	
        /// <param name="dwNormalOutSemantic"><dd>  <p>Specifies the output normal semantic, typically <see cref="SharpDX.Direct3D9.DeclarationUsage.Normal"/>, that describes where the normal vector at each vertex will be stored. If D3DX_DEFAULT, then this normal vector will not be stored.</p> </dd></param>	
        /// <param name="dwNormalOutIndex"><dd>  <p>Specifies the semantic index at which to store the normal vector at each vertex.</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>Combination of one or more <strong><see cref="SharpDX.Direct3D9.TangentOptions"/></strong> flags that specify tangent frame computation options. If <strong><c>null</c></strong>, the following options will be specified:</p> <table> <tr><th>Description</th><th> <strong><see cref="SharpDX.Direct3D9.TangentOptions"/></strong> Flag Value</th></tr> <tr><td>Weight the normal vector length by the angle, in radians, subtended by the two edges leaving the vertex.</td><td>&amp; !( <see cref="SharpDX.Direct3D9.TangentOptions.WeightByArea"/> | <see cref="SharpDX.Direct3D9.TangentOptions.WeightEqual"/> )</td></tr> <tr><td>Compute orthogonal Cartesian coordinates from texture coordinates (u, v). See Remarks.</td><td>&amp; !( <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromU"/> | <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromV"/> )</td></tr> <tr><td>Textures are not wrapped in either u or v directions</td><td>&amp; !( <see cref="SharpDX.Direct3D9.TangentOptions.WrapUV"/> )</td></tr> <tr><td>Partial derivatives with respect to texture coordinates are normalized.</td><td>&amp; !( <see cref="SharpDX.Direct3D9.TangentOptions.DontNormalizePartials"/> )</td></tr> <tr><td>Vertices are ordered in a counterclockwise direction around each triangle.</td><td>&amp; !( <see cref="SharpDX.Direct3D9.TangentOptions.WindCW"/> )</td></tr> <tr><td>Use per-vertex normal vectors already present in the input mesh.</td><td>&amp; !( <see cref="SharpDX.Direct3D9.TangentOptions.CalculateNormals"/> )</td></tr> </table> <p>?</p> <p>If <see cref="SharpDX.Direct3D9.TangentOptions.GenerateInPlace"/> is not set, the input mesh is cloned. The original mesh must therefore have sufficient space to store the computed normal vector and partial derivative data.</p> </dd></param>	
        /// <param name="dwAdjacencyRef"><dd>  <p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <strong>GetNumFaces</strong> * sizeof(DWORD).</p> </dd></param>	
        /// <param name="fPartialEdgeThreshold"><dd>  <p>Specifies the maximum cosine of the angle at which two partial derivatives are deemed to be incompatible with each other. If the dot product of the direction of the two partial derivatives in adjacent triangles is less than or equal to this threshold, then the vertices shared between these triangles will be split.</p> </dd></param>	
        /// <param name="fSingularPointThreshold"><dd>  <p>Specifies the maximum magnitude of a partial derivative at which a vertex will be deemed singular. As multiple triangles are incident on a point that have nearby tangent frames, but altogether cancel each other out (such as at the top of a sphere), the magnitude of the partial derivative will decrease. If the magnitude is less than or equal to this threshold, then the vertex will be split for every triangle that contains it.</p> </dd></param>	
        /// <param name="fNormalEdgeThreshold"><dd>  <p>Similar to fPartialEdgeThreshold, specifies the maximum cosine of the angle between two normals that is a threshold beyond which vertices shared between triangles will be split. If the dot product of the two normals is less than the threshold, the shared vertices will be split, forming a hard edge between neighboring triangles. If the dot product is more than the threshold, neighboring triangles will have their normals interpolated.</p> </dd></param>	
        /// <param name="meshOutOut"><dd>  <p>Address of a reference to an output <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> mesh object that receives the computed tangent, binormal, and normal vector data.</p> </dd></param>	
        /// <param name="vertexMappingOut"><dd>  <p>Address of a reference to an output <strong><see cref="SharpDX.Direct3D.Blob"/></strong> buffer object that receives a mapping of new vertices computed by this method to the original vertices. The buffer is an array of DWORDs, with the array size defined as the number of vertices in ppMeshOut.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>A simplified version of this function is available as <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrame"/></strong>.</p><p>The computed normal vector at each vertex is always normalized to have unit length.</p><p>The most robust solution for computing orthogonal Cartesian coordinates is to not set flags <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromU"/> and <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromV"/>, so that orthogonal coordinates are computed from both texture coordinates u and v. However, in this case, if either u or v is zero, then the function will compute orthogonal coordinates using <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromV"/> or <see cref="SharpDX.Direct3D9.TangentOptions.OrthogonalizeFromU"/>, respectively.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeTangentFrameEx']/*"/>	
        /// <msdn-id>bb172745</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeTangentFrameEx([In] ID3DXMesh* pMesh,[In] unsigned int dwTextureInSemantic,[In] unsigned int dwTextureInIndex,[In] unsigned int dwUPartialOutSemantic,[In] unsigned int dwUPartialOutIndex,[In] unsigned int dwVPartialOutSemantic,[In] unsigned int dwVPartialOutIndex,[In] unsigned int dwNormalOutSemantic,[In] unsigned int dwNormalOutIndex,[In] unsigned int dwOptions,[In] const unsigned int* pdwAdjacency,[In] float fPartialEdgeThreshold,[In] float fSingularPointThreshold,[In] float fNormalEdgeThreshold,[In] ID3DXMesh** ppMeshOut,[In] ID3DXBuffer** ppVertexMapping)</unmanaged>	
        /// <unmanaged-short>D3DXComputeTangentFrameEx</unmanaged-short>	
        public static void ComputeTangentFrameEx(SharpDX.Direct3D9.Mesh meshRef, int dwTextureInSemantic, int dwTextureInIndex, int dwUPartialOutSemantic, int dwUPartialOutIndex, int dwVPartialOutSemantic, int dwVPartialOutIndex, int dwNormalOutSemantic, int dwNormalOutIndex, int dwOptions, int dwAdjacencyRef, float fPartialEdgeThreshold, float fSingularPointThreshold, float fNormalEdgeThreshold, out SharpDX.Direct3D9.Mesh meshOutOut, out SharpDX.Direct3D.Blob vertexMappingOut) {
            unsafe {
                IntPtr meshOutOut_ = IntPtr.Zero;
                IntPtr vertexMappingOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeTangentFrameEx_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), dwTextureInSemantic, dwTextureInIndex, dwUPartialOutSemantic, dwUPartialOutIndex, dwVPartialOutSemantic, dwVPartialOutIndex, dwNormalOutSemantic, dwNormalOutIndex, dwOptions, &dwAdjacencyRef, fPartialEdgeThreshold, fSingularPointThreshold, fNormalEdgeThreshold, &meshOutOut_, &vertexMappingOut_);		
                meshOutOut= (meshOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOutOut_);	
                vertexMappingOut= (vertexMappingOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexMappingOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeTangentFrameEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeTangentFrameEx_(void* arg0,int arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,void* arg10,float arg11,float arg12,float arg13,void* arg14,void* arg15);

        
        /// <summary>	
        /// <p>Determines if a ray intersects the volume of a sphere's bounding box.</p>	
        /// </summary>	
        /// <param name="centerRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, specifying the center coordinate of the sphere.</p> </dd></param>	
        /// <param name="radius"><dd>  <p>Radius of the sphere.</p> </dd></param>	
        /// <param name="rayPositionRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, specifying the origin coordinate of the ray.</p> </dd></param>	
        /// <param name="rayDirectionRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, specifying the direction of the ray. This vector should not be (0,0,0) but does not need to be normalized.</p> </dd></param>	
        /// <returns><p>Returns <strong>TRUE</strong> if the ray intersects the volume of the sphere's bounding box. Otherwise, returns <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.D3DX9.SphereBoundProbe"/></strong> determines if the ray intersects the volume of the sphere's bounding box, not just the surface of the sphere.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSphereBoundProbe']/*"/>	
        /// <msdn-id>bb204995</msdn-id>	
        /// <unmanaged>BOOL D3DXSphereBoundProbe([In] const D3DXVECTOR3* pCenter,[In] float Radius,[In] const D3DXVECTOR3* pRayPosition,[In] const D3DXVECTOR3* pRayDirection)</unmanaged>	
        /// <unmanaged-short>D3DXSphereBoundProbe</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool SphereBoundProbe(SharpDX.Mathematics.Interop.RawVector3 centerRef, float radius, SharpDX.Mathematics.Interop.RawVector3 rayPositionRef, SharpDX.Mathematics.Interop.RawVector3 rayDirectionRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				D3DXSphereBoundProbe_(&centerRef, radius, &rayPositionRef, &rayDirectionRef);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSphereBoundProbe", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D3DXSphereBoundProbe_(void* arg0,float arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Create a UV atlas for a mesh.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an input mesh (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>) which contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates.</p> </dd></param>	
        /// <param name="uMaxChartNumber"><dd>  <p>The maximum number of charts to partition the mesh into. See remarks about the partitioning modes. Use 0 to tell D3DX that the atlas should be parameterized based on stretch.</p> </dd></param>	
        /// <param name="fMaxStretch"><dd>  <p>The amount of stretching allowed. 0 means no stretching is allowed, 1 means any amount of stretching can be used.</p> </dd></param>	
        /// <param name="uWidth"><dd>  <p>Texture width.</p> </dd></param>	
        /// <param name="uHeight"><dd>  <p>Texture height.</p> </dd></param>	
        /// <param name="fGutter"><dd>  <p>The minimum distance, in texels, between two charts on the atlas. The gutter is always scaled by the width; so, if a gutter of 2.5 is used on a 512x512 texture, then the minimum distance between two charts is 2.5 / 512.0 texels.</p> </dd></param>	
        /// <param name="dwTextureIndex"><dd>  <p>Zero-based texture coordinate index that identifies which set of texture coordinates to use.</p> </dd></param>	
        /// <param name="dwAdjacencyRef"><dd>  <p>A reference to an array of adjacency data. with 3 DWORDs per face, indicating which triangles are adjacent to each other (see <strong><see cref="SharpDX.Direct3D9.BaseMesh.GenerateAdjacency"/></strong>).</p> </dd></param>	
        /// <param name="dwFalseEdgeAdjacencyRef"><dd>  <p>An array with 3 DWORDS per face. Each face indicates if an edge is false or not. A non-false edge is indicated by -1, a false edge is indicated by any other value. This enables the parameterization of a mesh of quads where the edges down the middle of each quad will not be cut.</p> </dd></param>	
        /// <param name="fIMTArrayRef"><dd>  <p>A reference to an array of integrated metric tensors that describes how to stretch a triangle (see IntegratedMetricTensor).</p> </dd></param>	
        /// <param name="statusCallbackRef"><dd>  <p>A reference to a callback function (see LPD3DXUVATLASCB) that is useful for monitoring progress.</p> </dd></param>	
        /// <param name="fCallbackFrequency"><dd>  <p>Specify how often D3DX will call the callback; a reasonable default value is 0.0001f.</p> </dd></param>	
        /// <param name="userContextRef"><dd>  <p>Pointer to a user-defined value which is passed to the callback function; typically used by an application to pass a reference to a data structure that provides context information for the callback function.</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>Specify the quality of the charts generated. See <strong>D3DXUVATLAS</strong>.</p> </dd></param>	
        /// <param name="meshOutOut"><dd>  <p>Pointer to the created mesh with the atlas (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>).</p> </dd></param>	
        /// <param name="facePartitioningOut"><dd>  <p>A reference to an array of the final face-partitioning data. Each element contains one DWORD per face (see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>).</p> </dd></param>	
        /// <param name="vertexRemapArrayOut"><dd>  <p>A reference to an array of remapped vertices. Each array element identifies the original vertex that each final vertex came from (if the vertex was split during remapping). Each array element contains one DWORD per vertex.</p> </dd></param>	
        /// <param name="fMaxStretchOutRef"><dd>  <p>A reference to the maximum stretch value generated by the atlas algorithm. The range is between 0.0 and 1.0.</p> </dd></param>	
        /// <param name="uNumChartsOutRef"><dd>  <p>A reference to the number of charts created by the atlas algorithm. If dwMaxChartNumber is too low, this parameter will return the minimum number of charts required to create an atlas.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>; otherwise, the value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><see cref="SharpDX.Direct3D9.D3DX9.UVAtlasCreate"/> can partition mesh geometry two ways:</p><ul> <li>Based on the number of charts</li> <li>Based on the maximum allowed stretch. If the maximum allowed stretch is 0, each triangle will likely be in its own chart.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXUVAtlasCreate']/*"/>	
        /// <msdn-id>bb205479</msdn-id>	
        /// <unmanaged>HRESULT D3DXUVAtlasCreate([In] ID3DXMesh* pMesh,[In] unsigned int uMaxChartNumber,[In] float fMaxStretch,[In] unsigned int uWidth,[In] unsigned int uHeight,[In] float fGutter,[In] unsigned int dwTextureIndex,[In] const unsigned int* pdwAdjacency,[In] const unsigned int* pdwFalseEdgeAdjacency,[In] const float* pfIMTArray,[In] __function__stdcall* pStatusCallback,[In] float fCallbackFrequency,[In] void* pUserContext,[In] unsigned int dwOptions,[In] ID3DXMesh** ppMeshOut,[In] ID3DXBuffer** ppFacePartitioning,[In] ID3DXBuffer** ppVertexRemapArray,[In] float* pfMaxStretchOut,[In] unsigned int* puNumChartsOut)</unmanaged>	
        /// <unmanaged-short>D3DXUVAtlasCreate</unmanaged-short>	
        public static void UVAtlasCreate(SharpDX.Direct3D9.Mesh meshRef, int uMaxChartNumber, float fMaxStretch, int uWidth, int uHeight, float fGutter, int dwTextureIndex, int dwAdjacencyRef, int dwFalseEdgeAdjacencyRef, float fIMTArrayRef, SharpDX.FunctionCallback statusCallbackRef, float fCallbackFrequency, System.IntPtr userContextRef, int dwOptions, out SharpDX.Direct3D9.Mesh meshOutOut, out SharpDX.Direct3D.Blob facePartitioningOut, out SharpDX.Direct3D.Blob vertexRemapArrayOut, float fMaxStretchOutRef, int uNumChartsOutRef) {
            unsafe {
                IntPtr meshOutOut_ = IntPtr.Zero;
                IntPtr facePartitioningOut_ = IntPtr.Zero;
                IntPtr vertexRemapArrayOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXUVAtlasCreate_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), uMaxChartNumber, fMaxStretch, uWidth, uHeight, fGutter, dwTextureIndex, &dwAdjacencyRef, &dwFalseEdgeAdjacencyRef, &fIMTArrayRef, statusCallbackRef, fCallbackFrequency, (void*)userContextRef, dwOptions, &meshOutOut_, &facePartitioningOut_, &vertexRemapArrayOut_, &fMaxStretchOutRef, &uNumChartsOutRef);		
                meshOutOut= (meshOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOutOut_);	
                facePartitioningOut= (facePartitioningOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(facePartitioningOut_);	
                vertexRemapArrayOut= (vertexRemapArrayOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapArrayOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasCreate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXUVAtlasCreate_(void* arg0,int arg1,float arg2,int arg3,int arg4,float arg5,int arg6,void* arg7,void* arg8,void* arg9,void* arg10,float arg11,void* arg12,int arg13,void* arg14,void* arg15,void* arg16,void* arg17,void* arg18);

        
        /// <summary>	
        /// <p>Create a UV atlas for a mesh.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an input mesh (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>) that contains the object geometry for calculating the atlas. At a minimum, the mesh must contain position data and 2D texture coordinates.</p> </dd></param>	
        /// <param name="uMaxChartNumber"><dd>  <p>The maximum number of charts to partition the mesh into. See remarks about the partitioning modes. Use 0 to tell D3DX that the atlas should be parameterized based on stretch.</p> </dd></param>	
        /// <param name="fMaxStretch"><dd>  <p>The amount of stretching allowed. 0 means no stretching is allowed, 1 means any amount of stretching can be used.</p> </dd></param>	
        /// <param name="dwTextureIndex"><dd>  <p>Zero-based texture coordinate index that identifies which set of texture coordinates to use.</p> </dd></param>	
        /// <param name="dwAdjacencyRef"><dd>  <p>A reference to an array of adjacency data with 3 DWORDs per face, indicating which triangles are adjacent to each other (see <strong><see cref="SharpDX.Direct3D9.BaseMesh.GenerateAdjacency"/></strong>).</p> </dd></param>	
        /// <param name="dwFalseEdgeAdjacencyRef"><dd>  <p>An array with 3 DWORDS per face. Each face indicates if an edge is false or not. A non-false edge is indicated by -1, a false edge is indicated by any other value. This enables the parameterization of a mesh of quads where the edges down the middle of each quad will not be cut.</p> </dd></param>	
        /// <param name="fIMTArrayRef"><dd>  <p>A reference to an array of integrated metric tensors that describes how to stretch a triangle (see IntegratedMetricTensor).</p> </dd></param>	
        /// <param name="statusCallbackRef"><dd>  <p>A reference to a callback function (see LPD3DXUVATLASCB) that is useful for monitoring progress.</p> </dd></param>	
        /// <param name="fCallbackFrequency"><dd>  <p>Specify how often D3DX will call the callback; a reasonable default value is 0.0001f.</p> </dd></param>	
        /// <param name="userContextRef"><dd>  <p>Pointer to a user-defined value that is passed to the callback function; typically used by an application to pass a reference to a data structure that provides context information for the callback function.</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>Specify the quality of the charts generated by combining one or more <strong>D3DXUVATLAS</strong> flags.</p> </dd></param>	
        /// <param name="meshOutOut"><dd>  <p>Pointer to the created mesh with the atlas (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>).</p> </dd></param>	
        /// <param name="facePartitioningOut"><dd>  <p>A reference to an array of the final face-partitioning data. Each element contains one DWORD per face (see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>).</p> </dd></param>	
        /// <param name="vertexRemapArrayOut"><dd>  <p>A reference to an array of remapped vertices. Each array element identifies the original vertex each final vertex came from (if the vertex was split during remapping). Each array element contains one DWORD per vertex.</p> </dd></param>	
        /// <param name="partitionResultAdjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. This buffer will contain an array of three DWORDs per face that specify the three neighbors for each face in the output mesh. This parameter must not be <strong><c>null</c></strong>, because the subsequent call to <see cref="SharpDX.Direct3D9.D3DX9.UVAtlasPack"/>() requires it.</p> </dd></param>	
        /// <param name="fMaxStretchOutRef"><dd>  <p>A reference to the maximum stretch value generated by the atlas algorithm. The range is between 0.0 and 1.0.</p> </dd></param>	
        /// <param name="uNumChartsOutRef"><dd>  <p>A reference to the number of charts created by the atlas algorithm. If dwMaxChartNumber is too low, this parameter will return the minimum number of charts required to create an atlas.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>; otherwise, the value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p><see cref="SharpDX.Direct3D9.D3DX9.UVAtlasPartition"/> is similar to <strong><see cref="SharpDX.Direct3D9.D3DX9.UVAtlasCreate"/></strong>, except that <see cref="SharpDX.Direct3D9.D3DX9.UVAtlasPartition"/> does not performing the final packing step.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXUVAtlasPartition']/*"/>	
        /// <msdn-id>bb205481</msdn-id>	
        /// <unmanaged>HRESULT D3DXUVAtlasPartition([In] ID3DXMesh* pMesh,[In] unsigned int uMaxChartNumber,[In] float fMaxStretch,[In] unsigned int dwTextureIndex,[In] const unsigned int* pdwAdjacency,[In] const unsigned int* pdwFalseEdgeAdjacency,[In] const float* pfIMTArray,[In] __function__stdcall* pStatusCallback,[In] float fCallbackFrequency,[In] void* pUserContext,[In] unsigned int dwOptions,[In] ID3DXMesh** ppMeshOut,[In] ID3DXBuffer** ppFacePartitioning,[In] ID3DXBuffer** ppVertexRemapArray,[In] ID3DXBuffer** ppPartitionResultAdjacency,[In] float* pfMaxStretchOut,[In] unsigned int* puNumChartsOut)</unmanaged>	
        /// <unmanaged-short>D3DXUVAtlasPartition</unmanaged-short>	
        public static void UVAtlasPartition(SharpDX.Direct3D9.Mesh meshRef, int uMaxChartNumber, float fMaxStretch, int dwTextureIndex, int dwAdjacencyRef, int dwFalseEdgeAdjacencyRef, float fIMTArrayRef, SharpDX.FunctionCallback statusCallbackRef, float fCallbackFrequency, System.IntPtr userContextRef, int dwOptions, out SharpDX.Direct3D9.Mesh meshOutOut, out SharpDX.Direct3D.Blob facePartitioningOut, out SharpDX.Direct3D.Blob vertexRemapArrayOut, out SharpDX.Direct3D.Blob partitionResultAdjacencyOut, float fMaxStretchOutRef, int uNumChartsOutRef) {
            unsafe {
                IntPtr meshOutOut_ = IntPtr.Zero;
                IntPtr facePartitioningOut_ = IntPtr.Zero;
                IntPtr vertexRemapArrayOut_ = IntPtr.Zero;
                IntPtr partitionResultAdjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXUVAtlasPartition_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), uMaxChartNumber, fMaxStretch, dwTextureIndex, &dwAdjacencyRef, &dwFalseEdgeAdjacencyRef, &fIMTArrayRef, statusCallbackRef, fCallbackFrequency, (void*)userContextRef, dwOptions, &meshOutOut_, &facePartitioningOut_, &vertexRemapArrayOut_, &partitionResultAdjacencyOut_, &fMaxStretchOutRef, &uNumChartsOutRef);		
                meshOutOut= (meshOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOutOut_);	
                facePartitioningOut= (facePartitioningOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(facePartitioningOut_);	
                vertexRemapArrayOut= (vertexRemapArrayOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(vertexRemapArrayOut_);	
                partitionResultAdjacencyOut= (partitionResultAdjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(partitionResultAdjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXUVAtlasPartition", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXUVAtlasPartition_(void* arg0,int arg1,float arg2,int arg3,void* arg4,void* arg5,void* arg6,void* arg7,float arg8,void* arg9,int arg10,void* arg11,void* arg12,void* arg13,void* arg14,void* arg15,void* arg16);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="streamRef">No documentation.</param>	
        /// <param name="options">No documentation.</param>	
        /// <param name="d3DDeviceRef">No documentation.</param>	
        /// <param name="materialsOut">No documentation.</param>	
        /// <param name="effectInstancesOut">No documentation.</param>	
        /// <param name="numMaterialsRef">No documentation.</param>	
        /// <param name="pMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreatePMeshFromStream']/*"/>	
        /// <unmanaged>HRESULT D3DXCreatePMeshFromStream([In] IStream* pStream,[In] unsigned int Options,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXBuffer** ppMaterials,[In] ID3DXBuffer** ppEffectInstances,[In] unsigned int* pNumMaterials,[In] ID3DXPMesh** ppPMesh)</unmanaged>	
        /// <unmanaged-short>D3DXCreatePMeshFromStream</unmanaged-short>	
        public static void CreatePMeshFromStream(System.IntPtr streamRef, int options, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D.Blob materialsOut, out SharpDX.Direct3D.Blob effectInstancesOut, int numMaterialsRef, out SharpDX.Direct3D9.ProgressiveMesh pMeshOut) {
            unsafe {
                IntPtr materialsOut_ = IntPtr.Zero;
                IntPtr effectInstancesOut_ = IntPtr.Zero;
                IntPtr pMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreatePMeshFromStream_((void*)streamRef, options, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &materialsOut_, &effectInstancesOut_, &numMaterialsRef, &pMeshOut_);		
                materialsOut= (materialsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(materialsOut_);	
                effectInstancesOut= (effectInstancesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectInstancesOut_);	
                pMeshOut= (pMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ProgressiveMesh(pMeshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePMeshFromStream", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreatePMeshFromStream_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Calculates per-triangle IMT's from a texture mapped onto a mesh, to be used optionally as input to the D3DX UVAtlas Functions.</p>	
        /// </summary>	
        /// <param name="meshRef">No documentation.</param>	
        /// <param name="textureRef">No documentation.</param>	
        /// <param name="dwTextureIndex">No documentation.</param>	
        /// <param name="dwOptions">No documentation.</param>	
        /// <param name="statusCallbackRef">No documentation.</param>	
        /// <param name="userContextRef">No documentation.</param>	
        /// <param name="iMTDataOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>; otherwise, the value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Given a texture that maps over the surface of the mesh, the algorithm computes the IMT for each face. This will cause triangles containing lower-frequency signal data to take up less space in the final texture atlas when parameterized with the UVAtlas functions. The texture is assumed to be interpolated over the mesh bilinearly.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeIMTFromTexture']/*"/>	
        /// <msdn-id>bb172740</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeIMTFromTexture([In] ID3DXMesh* pMesh,[In] IDirect3DTexture9* pTexture,[In] unsigned int dwTextureIndex,[In] unsigned int dwOptions,[In] __function__stdcall* pStatusCallback,[In] void* pUserContext,[In] ID3DXBuffer** ppIMTData)</unmanaged>	
        /// <unmanaged-short>D3DXComputeIMTFromTexture</unmanaged-short>	
        public static void ComputeIMTFromTexture(SharpDX.Direct3D9.Mesh meshRef, SharpDX.Direct3D9.Texture textureRef, int dwTextureIndex, int dwOptions, SharpDX.FunctionCallback statusCallbackRef, System.IntPtr userContextRef, out SharpDX.Direct3D.Blob iMTDataOut) {
            unsafe {
                IntPtr iMTDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeIMTFromTexture_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), (void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer), dwTextureIndex, dwOptions, statusCallbackRef, (void*)userContextRef, &iMTDataOut_);		
                iMTDataOut= (iMTDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(iMTDataOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeIMTFromTexture_(void* arg0,void* arg1,int arg2,int arg3,void* arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="meshRef">No documentation.</param>	
        /// <param name="adjacencyRef">No documentation.</param>	
        /// <param name="vertexAttributeWeightsRef">No documentation.</param>	
        /// <param name="vertexWeightsRef">No documentation.</param>	
        /// <param name="sMeshOut">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateSPMesh']/*"/>	
        /// <unmanaged>HRESULT D3DXCreateSPMesh([In] ID3DXMesh* pMesh,[In] const unsigned int* pAdjacency,[In] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[In] const float* pVertexWeights,[In] ID3DXSPMesh** ppSMesh)</unmanaged>	
        /// <unmanaged-short>D3DXCreateSPMesh</unmanaged-short>	
        public static void CreateSPMesh(SharpDX.Direct3D9.Mesh meshRef, int adjacencyRef, ref SharpDX.Direct3D9.AttributeWeights vertexAttributeWeightsRef, float vertexWeightsRef, out SharpDX.Direct3D9.SimplificationMesh sMeshOut) {
            unsafe {
                var vertexAttributeWeightsRef_ = new SharpDX.Direct3D9.AttributeWeights.__Native();
                vertexAttributeWeightsRef.__MarshalTo(ref vertexAttributeWeightsRef_);
                IntPtr sMeshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateSPMesh_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &adjacencyRef, &vertexAttributeWeightsRef_, &vertexWeightsRef, &sMeshOut_);		
                vertexAttributeWeightsRef.__MarshalFree(ref vertexAttributeWeightsRef_);
                sMeshOut= (sMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.SimplificationMesh(sMeshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSPMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateSPMesh_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Concatenates a group of meshes into one common mesh. This method can optionally apply a matrix transformation to each input mesh and its texture coordinates.</p>	
        /// </summary>	
        /// <param name="meshesOut"><dd>  <p>Array of input mesh references (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>). The number of elements in the array is NumMeshes.</p> </dd></param>	
        /// <param name="numMeshes"><dd>  <p>Number of input meshes to concatenate.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Mesh creation options; this is a combination of one or more <strong>D3DXMESH</strong> flags. The mesh creation options are equivalent to the options parameter required by <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateMesh"/></strong>.</p> </dd></param>	
        /// <param name="geomXFormsRef"><dd>  <p>Optional array of geometry transforms. The number of elements in the array is NumMeshes; each element is a transformation matrix (see <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>). May be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="textureXFormsRef"><dd>  <p>Optional array of texture transforms. The number of elements in the array is NumMeshes; each element is a transformation matrix (see <strong><see cref="SharpDX.Mathematics.Interop.RawMatrix"/></strong>). This parameter may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="declRef"><dd>  <p>Optional reference to a vertex declaration (see <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>). This parameter may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Device"/></strong> device that is used to create the new mesh.</p> </dd></param>	
        /// <param name="meshOutOut"><dd>  <p>Address of a reference to the mesh created (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>).</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of these: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>If no vertex declaration is given as part of the Options mesh creation parameter, the method will generate a union of all of the vertex declarations of the submeshes, promoting channels and types if necessary. The method will create an attribute table from attribute tables of the input meshes. To ensure creation of an attribute table, call <strong>Optimize</strong> with Flags set to <see cref="SharpDX.Direct3D9.MeshOptimizeFlags.Compact"/> and <see cref="SharpDX.Direct3D9.MeshOptimizeFlags.AttributeSort"/> (see <strong>D3DXMESHOPT</strong>).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXConcatenateMeshes']/*"/>	
        /// <msdn-id>bb172746</msdn-id>	
        /// <unmanaged>HRESULT D3DXConcatenateMeshes([In] ID3DXMesh** ppMeshes,[In] unsigned int NumMeshes,[In] unsigned int Options,[In] const D3DXMATRIX* pGeomXForms,[In] const D3DXMATRIX* pTextureXForms,[In, Buffer] const D3DVERTEXELEMENT9* pDecl,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXMesh** ppMeshOut)</unmanaged>	
        /// <unmanaged-short>D3DXConcatenateMeshes</unmanaged-short>	
        public static void ConcatenateMeshes(out SharpDX.Direct3D9.Mesh meshesOut, int numMeshes, int options, ref SharpDX.Mathematics.Interop.RawMatrix geomXFormsRef, ref SharpDX.Mathematics.Interop.RawMatrix textureXFormsRef, SharpDX.Direct3D9.VertexElement[] declRef, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.Mesh meshOutOut) {
            unsafe {
                IntPtr meshesOut_ = IntPtr.Zero;
                IntPtr meshOutOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* geomXFormsRef_ = &geomXFormsRef)
                    fixed (void* textureXFormsRef_ = &textureXFormsRef)
                        fixed (void* declRef_ = declRef)
                            __result__= 
            				D3DXConcatenateMeshes_(&meshesOut_, numMeshes, options, geomXFormsRef_, textureXFormsRef_, declRef_, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &meshOutOut_);		
                meshesOut= (meshesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshesOut_);	
                meshOutOut= (meshOutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOutOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXConcatenateMeshes", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXConcatenateMeshes_(void* arg0,int arg1,int arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Determines whether a ray intersects the volume of a box's bounding box.</p>	
        /// </summary>	
        /// <param name="minRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong>, describing the lower-left corner of the bounding box. See Remarks.</p> </dd></param>	
        /// <param name="maxRef"><dd>  <p>Pointer to a  <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, describing the upper-right corner of the bounding box. See Remarks.</p> </dd></param>	
        /// <param name="rayPositionRef"><dd>  <p>Pointer to a <see cref="SharpDX.Mathematics.Interop.RawVector3"/> structure, specifying the origin coordinate of the ray.</p> </dd></param>	
        /// <param name="rayDirectionRef"><dd>  <p>Pointer to a <see cref="SharpDX.Mathematics.Interop.RawVector3"/> structure, specifying the direction of the ray. This vector should not be (0,0,0) but does not need to be normalized.</p> </dd></param>	
        /// <returns><p>Returns <strong>TRUE</strong> if the ray intersects the volume of the box's bounding box. Otherwise, returns <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p><strong><see cref="SharpDX.Direct3D9.D3DX9.BoxBoundProbe"/></strong> determines if the ray intersects the volume of the box's bounding box, not just the surface of the box.</p><p>The values passed to <strong><see cref="SharpDX.Direct3D9.D3DX9.BoxBoundProbe"/></strong> are xmin, xmax, ymin, ymax, zmin, and zmax. Thus, the following defines the corners of the bounding box.</p><pre> xmax, ymax, zmax	
        /// xmax, ymax, zmin	
        /// xmax, ymin, zmax	
        /// xmax, ymin, zmin	
        /// xmin, ymax, zmax	
        /// xmin, ymax, zmin	
        /// xmin, ymin, zmax	
        /// xmin, ymin, zmin	
        /// </pre><p>The depth of the bounding box in the z direction is zmax - zmin, in the y direction is ymax - ymin, and in the x direction is xmax - xmin. For example, with the following minimum and maximum vectors, min (-1, -1, -1) and max (1, 1, 1), the bounding box is defined in the following manner.</p><pre> 1,  1,  1 1,  1, -1 1, -1,  1 1, -1, -1	
        /// -1,  1,  1	
        /// -1,  1, -1	
        /// -1, -1,  1	
        /// -1, -1, -l	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXBoxBoundProbe']/*"/>	
        /// <msdn-id>bb204916</msdn-id>	
        /// <unmanaged>BOOL D3DXBoxBoundProbe([In] const D3DXVECTOR3* pMin,[In] const D3DXVECTOR3* pMax,[In] const D3DXVECTOR3* pRayPosition,[In] const D3DXVECTOR3* pRayDirection)</unmanaged>	
        /// <unmanaged-short>D3DXBoxBoundProbe</unmanaged-short>	
        public static SharpDX.Mathematics.Interop.RawBool BoxBoundProbe(SharpDX.Mathematics.Interop.RawVector3 minRef, SharpDX.Mathematics.Interop.RawVector3 maxRef, SharpDX.Mathematics.Interop.RawVector3 rayPositionRef, SharpDX.Mathematics.Interop.RawVector3 rayDirectionRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				D3DXBoxBoundProbe_(&minRef, &maxRef, &rayPositionRef, &rayDirectionRef);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXBoxBoundProbe", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern SharpDX.Mathematics.Interop.RawBool D3DXBoxBoundProbe_(void* arg0,void* arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Loads a mesh from a resource.</p>	
        /// </summary>	
        /// <param name="module"><dd>  <p>Handle to the module where the resource is located, or <strong><c>null</c></strong> for the module associated with the image the operating system used to create the current process. See remarks.</p> </dd></param>	
        /// <param name="name"><dd>  <p>Pointer to a string that specifies the resource to create the mesh from. See remarks.</p> </dd></param>	
        /// <param name="type"><dd>  <p>Pointer to a string that specifies the resource type. See remarks.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration that specify creation options for the mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object associated with the mesh.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh.</p> </dd></param>	
        /// <param name="materialsOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When this method returns, this parameter is filled with an array of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures, containing information saved in the DirectX file.</p> </dd></param>	
        /// <param name="effectInstancesOut"><dd>  <p>Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <strong><see cref="SharpDX.Direct3D9.EffectInstance"/></strong>. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="numMaterialsRef"><dd>  <p>Pointer to the number of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures in the <em>ppMaterials</em> array, when the method returns.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the loaded mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>See <strong>FindResource</strong> to find out more about the Module, Name and Type parameters.</p><p>All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh.</p><p>For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure.</p><p>The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadMeshFromXResource']/*"/>	
        /// <msdn-id>bb172893</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadMeshFromXResource([In] HINSTANCE Module,[In] const char* Name,[In] const char* Type,[In] unsigned int Options,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXBuffer** ppAdjacency,[In] ID3DXBuffer** ppMaterials,[In] ID3DXBuffer** ppEffectInstances,[In] unsigned int* pNumMaterials,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXLoadMeshFromXResource</unmanaged-short>	
        public static void LoadMeshFromXResource(System.IntPtr module, string name, string type, int options, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D.Blob adjacencyOut, out SharpDX.Direct3D.Blob materialsOut, out SharpDX.Direct3D.Blob effectInstancesOut, int numMaterialsRef, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                IntPtr type_ = Utilities.StringToHGlobalAnsi(type);
                IntPtr adjacencyOut_ = IntPtr.Zero;
                IntPtr materialsOut_ = IntPtr.Zero;
                IntPtr effectInstancesOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadMeshFromXResource_((void*)module, (void*)name_, (void*)type_, options, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &adjacencyOut_, &materialsOut_, &effectInstancesOut_, &numMaterialsRef, &meshOut_);		
                Marshal.FreeHGlobal(name_ );
                Marshal.FreeHGlobal(type_ );
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                materialsOut= (materialsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(materialsOut_);	
                effectInstancesOut= (effectInstancesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectInstancesOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXResource", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadMeshFromXResource_(void* arg0,void* arg1,void* arg2,int arg3,void* arg4,void* arg5,void* arg6,void* arg7,void* arg8,void* arg9);

        
        /// <summary>	
        /// <p>Generates a simplified mesh using the provided weights that come as close as possible to the given MinValue.</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the source mesh.</p> </dd></param>	
        /// <param name="adjacencyRef"><dd>  <p>Pointer to an array of three  DWORDs per face that specify the three neighbors for each face in the mesh to be simplified.</p> </dd></param>	
        /// <param name="vertexAttributeWeightsRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.AttributeWeights"/></strong> structure, containing the weight for each vertex component. If this parameter is set to <strong><c>null</c></strong>, a default structure is used. See Remarks.</p> </dd></param>	
        /// <param name="vertexWeightsRef"><dd>  <p>Pointer to an array of vertex weights. If this parameter is set to <strong><c>null</c></strong>, all vertex weights are set to 1.0.</p> </dd></param>	
        /// <param name="minValue"><dd>  <p>Number of vertices or faces, depending on the flag set in the  <em>Options</em> parameter, by which to simplify the source mesh.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Specifies simplification options for the mesh. One of the flags in <strong>D3DXMESHSIMP</strong> can be set.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the returned simplification mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function generates a mesh that has <em>MinValue</em> vertices or faces.</p><p>If the simplification process cannot reduce the mesh to <em>MinValue</em>, the call still succeeds because <em>MinValue</em> is a desired minimum, not an absolute minimum.</p><p>If <em>pVertexAttributeWeights</em> is set to <strong><c>null</c></strong>, the following values are assigned to the default <strong><see cref="SharpDX.Direct3D9.AttributeWeights"/></strong> structure.</p><pre> <see cref="SharpDX.Direct3D9.AttributeWeights"/> AttributeWeights; AttributeWeights.Position  = 1.0;	
        /// AttributeWeights.Boundary =  1.0;	
        /// AttributeWeights.Normal   =  1.0;	
        /// AttributeWeights.Diffuse  =  0.0;	
        /// AttributeWeights.Specular =  0.0;	
        /// AttributeWeights.Tex[8]   =  {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};	
        /// </pre><p>This default structure is what most applications should use because it considers only geometric and normal adjustment. Only in special cases will the other member fields need to be modified. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSimplifyMesh']/*"/>	
        /// <msdn-id>bb205463</msdn-id>	
        /// <unmanaged>HRESULT D3DXSimplifyMesh([In] ID3DXMesh* pMesh,[In] const unsigned int* pAdjacency,[In] const D3DXATTRIBUTEWEIGHTS* pVertexAttributeWeights,[In] const float* pVertexWeights,[In] unsigned int MinValue,[In] unsigned int Options,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXSimplifyMesh</unmanaged-short>	
        public static void SimplifyMesh(SharpDX.Direct3D9.Mesh meshRef, int adjacencyRef, ref SharpDX.Direct3D9.AttributeWeights vertexAttributeWeightsRef, float vertexWeightsRef, int minValue, int options, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                var vertexAttributeWeightsRef_ = new SharpDX.Direct3D9.AttributeWeights.__Native();
                vertexAttributeWeightsRef.__MarshalTo(ref vertexAttributeWeightsRef_);
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXSimplifyMesh_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &adjacencyRef, &vertexAttributeWeightsRef_, &vertexWeightsRef, minValue, options, &meshOut_);		
                vertexAttributeWeightsRef.__MarshalFree(ref vertexAttributeWeightsRef_);
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSimplifyMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSimplifyMesh_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,int arg5,void* arg6);

        
        /// <summary>	
        /// <p>Creates a mesh object using a flexible vertex format (FVF) code.</p>	
        /// </summary>	
        /// <param name="numFaces"><dd>  <p>Number of faces for the mesh. The valid range for this number is greater than 0, and one less than the max DWORD value, typically 232 - 1, because the last index is reserved.</p> </dd></param>	
        /// <param name="numVertices"><dd>  <p>Number of vertices for the mesh. This parameter must be greater than 0.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Combination of one or more flags from the  <strong>D3DXMESH</strong> enumeration, specifying creation options for the mesh. </p> </dd></param>	
        /// <param name="fvf"><dd>  <p>Combination of <see cref="SharpDX.Direct3D9.VertexFormat"/> that describes the vertex format for the returned mesh. This function does not support <see cref="SharpDX.Direct3D9.VertexFormat.PositionRhw"/>.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object to be associated with the mesh.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the created mesh object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateMeshFVF']/*"/>	
        /// <msdn-id>bb172781</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateMeshFVF([In] unsigned int NumFaces,[In] unsigned int NumVertices,[In] unsigned int Options,[In] D3DFVF FVF,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXCreateMeshFVF</unmanaged-short>	
        public static void CreateMeshFVF(int numFaces, int numVertices, int options, SharpDX.Direct3D9.VertexFormat fvf, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateMeshFVF_(numFaces, numVertices, options, unchecked((int)fvf), (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &meshOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateMeshFVF", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateMeshFVF_(int arg0,int arg1,int arg2,int arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Calculate per-triangle IMT's from from per-vertex data. This function allows you to calculate the IMT based off of any value in a mesh (color, normal, etc).</p>	
        /// </summary>	
        /// <param name="meshRef"><dd>  <p>A reference to an input mesh (see <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>) which contains the object geometry for calculating the IMT.</p> </dd></param>	
        /// <param name="fVertexSignalRef"><dd>  <p>A reference to an array of per-vertex data from which IMT will be computed. The array size is  uSignalStride * v, where v is the number of vertices in the mesh.</p> </dd></param>	
        /// <param name="uSignalDimension"><dd>  <p>The number of floats per vertex.</p> </dd></param>	
        /// <param name="uSignalStride"><dd>  <p>The number of bytes per vertex in the array. This must be a multiple of sizeof(float)</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>Texture wrap options. This is a combination of one or more <strong><see cref="SharpDX.Direct3D9.UVAtlasQuality"/> FLAGS</strong>.</p> </dd></param>	
        /// <param name="statusCallbackRef"><dd>  <p>A reference to a callback function to monitor IMT computation progress.</p> </dd></param>	
        /// <param name="userContextRef"><dd>  <p>A reference to a user-defined variable which is passed to the status callback function. Typically used by an application to pass a reference to a data structure that provides context information for the callback function.</p> </dd></param>	
        /// <param name="iMTDataOut"><dd>  <p>A reference to the buffer (see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>) containing the returned IMT array. This array can be provided as input to the D3DX UVAtlas Functions to prioritize texture-space allocation in the texture parameterization.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>; otherwise, the value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeIMTFromPerVertexSignal']/*"/>	
        /// <msdn-id>bb172738</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerVertexSignal([In] ID3DXMesh* pMesh,[In] const float* pfVertexSignal,[In] unsigned int uSignalDimension,[In] unsigned int uSignalStride,[In] unsigned int dwOptions,[In] __function__stdcall* pStatusCallback,[In] void* pUserContext,[In] ID3DXBuffer** ppIMTData)</unmanaged>	
        /// <unmanaged-short>D3DXComputeIMTFromPerVertexSignal</unmanaged-short>	
        public static void ComputeIMTFromPerVertexSignal(SharpDX.Direct3D9.Mesh meshRef, float fVertexSignalRef, int uSignalDimension, int uSignalStride, int dwOptions, SharpDX.FunctionCallback statusCallbackRef, System.IntPtr userContextRef, out SharpDX.Direct3D.Blob iMTDataOut) {
            unsafe {
                IntPtr iMTDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeIMTFromPerVertexSignal_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &fVertexSignalRef, uSignalDimension, uSignalStride, dwOptions, statusCallbackRef, (void*)userContextRef, &iMTDataOut_);		
                iMTDataOut= (iMTDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(iMTDataOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromPerVertexSignal", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeIMTFromPerVertexSignal_(void* arg0,void* arg1,int arg2,int arg3,int arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Generates an optimized vertex remapping for a triangle list. This function is commonly used after applying the face remapping generated by <strong><see cref="SharpDX.Direct3D9.D3DX9.OptimizeFaces"/></strong>.</p>	
        /// </summary>	
        /// <param name="bIndicesRef">No documentation.</param>	
        /// <param name="cFaces">No documentation.</param>	
        /// <param name="cVertices">No documentation.</param>	
        /// <param name="b32BitIndices">No documentation.</param>	
        /// <param name="vertexRemapRef">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>By default, a mesh uses 16 bit indices when it is created unless the application specifies otherwise. To check whether an existing mesh uses 16-bit or 32-bit indices, call <strong><see cref="SharpDX.Direct3D9.BaseMesh.GetOptions"/></strong> and check for the <see cref="SharpDX.Direct3D9.MeshFlags.Use32Bit"/> flag.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXOptimizeVertices']/*"/>	
        /// <msdn-id>bb205377</msdn-id>	
        /// <unmanaged>HRESULT D3DXOptimizeVertices([In] const void* pbIndices,[In] unsigned int cFaces,[In] unsigned int cVertices,[In] BOOL b32BitIndices,[In, Buffer] int* pVertexRemap)</unmanaged>	
        /// <unmanaged-short>D3DXOptimizeVertices</unmanaged-short>	
        public static SharpDX.Result OptimizeVertices(System.IntPtr bIndicesRef, int cFaces, int cVertices, SharpDX.Mathematics.Interop.RawBool b32BitIndices, int[] vertexRemapRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* vertexRemapRef_ = vertexRemapRef)
                    __result__= 
    				D3DXOptimizeVertices_((void*)bIndicesRef, cFaces, cVertices, b32BitIndices, vertexRemapRef_);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXOptimizeVertices", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXOptimizeVertices_(void* arg0,int arg1,int arg2,SharpDX.Mathematics.Interop.RawBool arg3,void* arg4);

        
        /// <summary>	
        /// <p>Loads a mesh from a DirectX .x file.</p>	
        /// </summary>	
        /// <param name="xofMeshRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration, which specifies creation options for the mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object associated with the mesh.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Pointer to a buffer that contains adjacency data.  The adjacency data contains an array of three DWORDs per face that specify the three neighbors for each face in the mesh. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="materialsOut"><dd>  <p>Pointer to a buffer containing materials data. The buffer contains an array of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures, containing information from the DirectX file. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="effectInstancesOut"><dd>  <p>Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <strong><see cref="SharpDX.Direct3D9.EffectInstance"/></strong>. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="numMaterialsRef"><dd>  <p>Pointer to the number of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures in the  <em>ppMaterials</em> array, when the method returns.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the loaded mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.LoadMeshFromXW"/>. Otherwise, the function call resolves to D3DXLoadMeshFromXA because ANSI strings are being used.</p><p>All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh.</p><p>For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure.</p><p>The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadMeshFromXof']/*"/>	
        /// <msdn-id>bb172890</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadMeshFromXof([In] ID3DXFileData* pxofMesh,[In] unsigned int Options,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXBuffer** ppAdjacency,[In] ID3DXBuffer** ppMaterials,[In] ID3DXBuffer** ppEffectInstances,[In] unsigned int* pNumMaterials,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXLoadMeshFromXof</unmanaged-short>	
        public static void LoadMeshFromXof(SharpDX.Direct3D9.XFileData xofMeshRef, int options, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D.Blob adjacencyOut, out SharpDX.Direct3D.Blob materialsOut, out SharpDX.Direct3D.Blob effectInstancesOut, int numMaterialsRef, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr adjacencyOut_ = IntPtr.Zero;
                IntPtr materialsOut_ = IntPtr.Zero;
                IntPtr effectInstancesOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadMeshFromXof_((void*)((xofMeshRef == null)?IntPtr.Zero:xofMeshRef.NativePointer), options, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &adjacencyOut_, &materialsOut_, &effectInstancesOut_, &numMaterialsRef, &meshOut_);		
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                materialsOut= (materialsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(materialsOut_);	
                effectInstancesOut= (effectInstancesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectInstancesOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXof", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadMeshFromXof_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Creates a mesh from a control-patch mesh.</p>	
        /// </summary>	
        /// <param name="infoRef"><dd>  <p>Patch information structure. For more information, see <strong><see cref="SharpDX.Direct3D9.PatchInfo"/></strong>.</p> </dd></param>	
        /// <param name="dwNumPatches"><dd>  <p>Number of patches.</p> </dd></param>	
        /// <param name="dwNumVertices"><dd>  <p>Number of control vertices in the patch.</p> </dd></param>	
        /// <param name="dwOptions"><dd>  <p>Unused. Reserved for later use.</p> </dd></param>	
        /// <param name="declRef"><dd>  <p>Array of <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong> elements, describing the vertex format for the returned mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer the device that creates the patch mesh. See <strong><see cref="SharpDX.Direct3D9.Device"/></strong>.</p> </dd></param>	
        /// <param name="patchMeshRef"><dd>  <p>Pointer to the <strong><see cref="SharpDX.Direct3D9.PatchMesh"/></strong> object that is created.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This method takes an input patch mesh and converts it to a tessellated mesh. Patch meshes use 16-bit index buffers. Therefore, indices to <strong>LockIndexBuffer</strong> are 16 bits.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreatePatchMesh']/*"/>	
        /// <msdn-id>bb172783</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreatePatchMesh([In] const D3DXPATCHINFO* pInfo,[In] unsigned int dwNumPatches,[In] unsigned int dwNumVertices,[In] unsigned int dwOptions,[In, Buffer] const D3DVERTEXELEMENT9* pDecl,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXPatchMesh** pPatchMesh)</unmanaged>	
        /// <unmanaged-short>D3DXCreatePatchMesh</unmanaged-short>	
        public static void CreatePatchMesh(SharpDX.Direct3D9.PatchInfo infoRef, int dwNumPatches, int dwNumVertices, int dwOptions, SharpDX.Direct3D9.VertexElement[] declRef, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D9.PatchMesh patchMeshRef) {
            unsafe {
                IntPtr patchMeshRef_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* declRef_ = declRef)
                    __result__= 
    				D3DXCreatePatchMesh_(&infoRef, dwNumPatches, dwNumVertices, dwOptions, declRef_, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &patchMeshRef_);		
                patchMeshRef= (patchMeshRef_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.PatchMesh(patchMeshRef_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePatchMesh", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreatePatchMesh_(void* arg0,int arg1,int arg2,int arg3,void* arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Gets the size of the rectangle patch.</p>	
        /// </summary>	
        /// <param name="fNumSegsRef"><dd>  <p>Number of segments per edge to tessellate.</p> </dd></param>	
        /// <param name="dwTrianglesRef"><dd>  <p>Pointer to a DWORD that contains the number of triangles in the patch.</p> </dd></param>	
        /// <param name="dwVerticesRef"><dd>  <p>Pointer to a DWORD that contains the number of vertices in the patch.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXRectPatchSize']/*"/>	
        /// <msdn-id>bb205423</msdn-id>	
        /// <unmanaged>HRESULT D3DXRectPatchSize([In] const float* pfNumSegs,[Out] unsigned int* pdwTriangles,[Out] unsigned int* pdwVertices)</unmanaged>	
        /// <unmanaged-short>D3DXRectPatchSize</unmanaged-short>	
        public static SharpDX.Result RectPatchSize(float fNumSegsRef, out int dwTrianglesRef, out int dwVerticesRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dwTrianglesRef_ = &dwTrianglesRef)
                    fixed (void* dwVerticesRef_ = &dwVerticesRef)
                        __result__= 
        				D3DXRectPatchSize_(&fNumSegsRef, dwTrianglesRef_, dwVerticesRef_);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXRectPatchSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXRectPatchSize_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Tessellates a triangular higher-order surface patch into a triangle mesh.</p>	
        /// </summary>	
        /// <param name="vBRef"><dd>  <p>Vertex buffer containing the patch data.</p> </dd></param>	
        /// <param name="numSegsRef"><dd>  <p>Pointer to an array of three floating-point values that identify the number of segments into which each edge of the triangle patch should be divided when tessellated. See <strong><see cref="SharpDX.Direct3D9.TrianglePatchInfo"/></strong>.</p> </dd></param>	
        /// <param name="inDeclRef"><dd>  <p>Vertex declaration structure that defines the vertex data. See <strong><see cref="SharpDX.Direct3D9.VertexElement"/></strong>.</p> </dd></param>	
        /// <param name="triPatchInfoRef"><dd>  <p>Describes a triangle patch. See <strong><see cref="SharpDX.Direct3D9.TrianglePatchInfo"/></strong>.</p> </dd></param>	
        /// <param name="meshRef"><dd>  <p>Pointer to the created mesh. See <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Use <strong><see cref="SharpDX.Direct3D9.D3DX9.TriPatchSize"/></strong> to get the number of output vertices and indices that the tessellation function needs.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXTessellateTriPatch']/*"/>	
        /// <msdn-id>bb205471</msdn-id>	
        /// <unmanaged>HRESULT D3DXTessellateTriPatch([In] IDirect3DVertexBuffer9* pVB,[In] const float* pNumSegs,[In] const D3DVERTEXELEMENT9* pInDecl,[In] const D3DTRIPATCH_INFO* pTriPatchInfo,[In] ID3DXMesh* pMesh)</unmanaged>	
        /// <unmanaged-short>D3DXTessellateTriPatch</unmanaged-short>	
        public static void TessellateTriPatch(SharpDX.Direct3D9.VertexBuffer vBRef, float numSegsRef, SharpDX.Direct3D9.VertexElement inDeclRef, SharpDX.Direct3D9.TrianglePatchInfo triPatchInfoRef, SharpDX.Direct3D9.Mesh meshRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXTessellateTriPatch_((void*)((vBRef == null)?IntPtr.Zero:vBRef.NativePointer), &numSegsRef, &inDeclRef, &triPatchInfoRef, (void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXTessellateTriPatch", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXTessellateTriPatch_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Computes a bounding sphere for the mesh.</p>	
        /// </summary>	
        /// <param name="firstPositionRef"><dd>  <p>Pointer to first position.</p> </dd></param>	
        /// <param name="numVertices"><dd>  <p>Number of vertices.</p> </dd></param>	
        /// <param name="dwStride"><dd>  <p>Number of bytes between position vectors.  Use <strong>GetNumBytesPerVertex</strong>, <strong><see cref="SharpDX.Direct3D9.D3DX9.GetFVFVertexSize"/></strong>, or <strong><see cref="SharpDX.Direct3D9.D3DX9.GetDeclVertexSize"/></strong> to get the vertex stride.</p> </dd></param>	
        /// <param name="centerRef"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawVector3"/></strong> structure, defining the coordinate center of the returned bounding sphere.</p> </dd></param>	
        /// <param name="radiusRef"><dd>  <p>Radius of the returned bounding sphere.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeBoundingSphere']/*"/>	
        /// <msdn-id>bb172736</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeBoundingSphere([In] const D3DXVECTOR3* pFirstPosition,[In] unsigned int NumVertices,[In] unsigned int dwStride,[In] D3DXVECTOR3* pCenter,[In] float* pRadius)</unmanaged>	
        /// <unmanaged-short>D3DXComputeBoundingSphere</unmanaged-short>	
        public static void ComputeBoundingSphere(SharpDX.Mathematics.Interop.RawVector3 firstPositionRef, int numVertices, int dwStride, SharpDX.Mathematics.Interop.RawVector3 centerRef, float radiusRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeBoundingSphere_(&firstPositionRef, numVertices, dwStride, &centerRef, &radiusRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeBoundingSphere", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeBoundingSphere_(void* arg0,int arg1,int arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Loads a mesh from a DirectX .x file.</p>	
        /// </summary>	
        /// <param name="filenameRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration, which specifies creation options for the mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object associated with the mesh.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Pointer to a buffer that contains adjacency data.  The adjacency data contains an array of three DWORDs per face that specify the three neighbors for each face in the mesh. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="materialsOut"><dd>  <p>Pointer to a buffer containing materials data. The buffer contains an array of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures, containing information from the DirectX file. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="effectInstancesOut"><dd>  <p>Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <strong><see cref="SharpDX.Direct3D9.EffectInstance"/></strong>. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="numMaterialsRef"><dd>  <p>Pointer to the number of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures in the  <em>ppMaterials</em> array, when the method returns.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the loaded mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.LoadMeshFromXW"/>. Otherwise, the function call resolves to D3DXLoadMeshFromXA because ANSI strings are being used.</p><p>All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh.</p><p>For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure.</p><p>The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadMeshFromXW']/*"/>	
        /// <msdn-id>bb172890</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadMeshFromXW([In] const wchar_t* pFilename,[In] unsigned int Options,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXBuffer** ppAdjacency,[In] ID3DXBuffer** ppMaterials,[In] ID3DXBuffer** ppEffectInstances,[In] unsigned int* pNumMaterials,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXLoadMeshFromXW</unmanaged-short>	
        public static void LoadMeshFromXW(string filenameRef, int options, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D.Blob adjacencyOut, out SharpDX.Direct3D.Blob materialsOut, out SharpDX.Direct3D.Blob effectInstancesOut, int numMaterialsRef, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr filenameRef_ = Utilities.StringToHGlobalUni(filenameRef);
                IntPtr adjacencyOut_ = IntPtr.Zero;
                IntPtr materialsOut_ = IntPtr.Zero;
                IntPtr effectInstancesOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadMeshFromXW_((void*)filenameRef_, options, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &adjacencyOut_, &materialsOut_, &effectInstancesOut_, &numMaterialsRef, &meshOut_);		
                Marshal.FreeHGlobal(filenameRef_ );
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                materialsOut= (materialsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(materialsOut_);	
                effectInstancesOut= (effectInstancesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectInstancesOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadMeshFromXW_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Loads a mesh from memory.</p>	
        /// </summary>	
        /// <param name="memory"><dd>  <p>Pointer to the memory buffer which contains the mesh data.</p> </dd></param>	
        /// <param name="sizeOfMemory"><dd>  <p>Size of the file in memory, in bytes.</p> </dd></param>	
        /// <param name="options"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration, specifying creation options for the mesh.</p> </dd></param>	
        /// <param name="d3DDeviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, the device object associated with the mesh.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh.</p> </dd></param>	
        /// <param name="materialsOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When this method returns, this parameter is filled with an array of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures, containing information saved in the DirectX file.</p> </dd></param>	
        /// <param name="effectInstancesOut"><dd>  <p>Pointer to a buffer containing an array of effect instances, one per attribute group in the returned mesh. An effect instance is a particular instance of state information used to initialize an effect. See <strong><see cref="SharpDX.Direct3D9.EffectInstance"/></strong>. For more information about accessing the buffer, see <strong><see cref="SharpDX.Direct3D.Blob"/></strong>.</p> </dd></param>	
        /// <param name="numMaterialsRef"><dd>  <p>Pointer to the number of <strong><see cref="SharpDX.Direct3D9.ExtendedMaterial"/></strong> structures in the <em>ppMaterials</em> array, when the method returns.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface, representing the loaded mesh.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>All the meshes in the file will be collapsed into one output mesh. If the file contains a frame hierarchy, all the transformations will be applied to the mesh.</p><p>For mesh files that do not contain effect instance information, default effect instances will be generated from the material information in the .x file. A default effect instance will have default values that correspond to the members of the <strong><see cref="SharpDX.Direct3D9.Material"/></strong> structure.</p><p>The default texture name is also filled in, but is handled differently. The name will be Texture0@Name, which corresponds to an effect variable by the name of "Texture0" with an annotation called "Name." This will contain the string file name for the texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadMeshFromXInMemory']/*"/>	
        /// <msdn-id>bb172891</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadMeshFromXInMemory([In] const void* Memory,[In] unsigned int SizeOfMemory,[In] unsigned int Options,[In] IDirect3DDevice9* pD3DDevice,[In] ID3DXBuffer** ppAdjacency,[In] ID3DXBuffer** ppMaterials,[In] ID3DXBuffer** ppEffectInstances,[In] unsigned int* pNumMaterials,[In] ID3DXMesh** ppMesh)</unmanaged>	
        /// <unmanaged-short>D3DXLoadMeshFromXInMemory</unmanaged-short>	
        public static void LoadMeshFromXInMemory(System.IntPtr memory, int sizeOfMemory, int options, SharpDX.Direct3D9.Device d3DDeviceRef, out SharpDX.Direct3D.Blob adjacencyOut, out SharpDX.Direct3D.Blob materialsOut, out SharpDX.Direct3D.Blob effectInstancesOut, int numMaterialsRef, out SharpDX.Direct3D9.Mesh meshOut) {
            unsafe {
                IntPtr adjacencyOut_ = IntPtr.Zero;
                IntPtr materialsOut_ = IntPtr.Zero;
                IntPtr effectInstancesOut_ = IntPtr.Zero;
                IntPtr meshOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXLoadMeshFromXInMemory_((void*)memory, sizeOfMemory, options, (void*)((d3DDeviceRef == null)?IntPtr.Zero:d3DDeviceRef.NativePointer), &adjacencyOut_, &materialsOut_, &effectInstancesOut_, &numMaterialsRef, &meshOut_);		
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                materialsOut= (materialsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(materialsOut_);	
                effectInstancesOut= (effectInstancesOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(effectInstancesOut_);	
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadMeshFromXInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadMeshFromXInMemory_(void* arg0,int arg1,int arg2,void* arg3,void* arg4,void* arg5,void* arg6,void* arg7,void* arg8);

        
        /// <summary>	
        /// <p>Convert the specified mesh subset into a series of strips.</p>	
        /// </summary>	
        /// <param name="meshIn"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.BaseMesh"/></strong> interface, representing the mesh to convert to a strip.</p> </dd></param>	
        /// <param name="attribId"><dd>  <p>Attribute ID of the mesh subset to convert to strips.</p> </dd></param>	
        /// <param name="iBOptions"><dd>  <p>Combination of one or more flags from the <strong>D3DXMESH</strong> enumeration, specifying options for creating the index buffer. Cannot be <see cref="SharpDX.Direct3D9.MeshFlags.Use32Bit"/>. The index buffer will be created with 32-bit or 16-bit indices depending on the format of the index buffer of the mesh specified by the <em>MeshIn</em> parameter.</p> </dd></param>	
        /// <param name="indexBufferOut"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.IndexBuffer"/></strong> interface, representing index buffer containing the strip.</p> </dd></param>	
        /// <param name="numIndicesRef"><dd>  <p>Number of indices in the buffer returned in the <em>ppIndexBuffer</em> parameter.</p> </dd></param>	
        /// <param name="stripLengthsOut"><dd>  <p>Buffer containing an array of one DWORD per strip, which specifies the number of triangles in the that strip.</p> </dd></param>	
        /// <param name="numStripsRef"><dd>  <p>Number of individual strips in the index buffer and corresponding strip length array.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Before running this function, call <strong>Optimize</strong> or <strong><see cref="SharpDX.Direct3D9.D3DX9.OptimizeFaces"/></strong>, with the <see cref="SharpDX.Direct3D9.MeshOptimizeFlags.AttributeSort"/> flag set.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXConvertMeshSubsetToStrips']/*"/>	
        /// <msdn-id>bb172750</msdn-id>	
        /// <unmanaged>HRESULT D3DXConvertMeshSubsetToStrips([In] ID3DXBaseMesh* MeshIn,[In] unsigned int AttribId,[In] unsigned int IBOptions,[In] IDirect3DIndexBuffer9** ppIndexBuffer,[In] unsigned int* pNumIndices,[In] ID3DXBuffer** ppStripLengths,[In] unsigned int* pNumStrips)</unmanaged>	
        /// <unmanaged-short>D3DXConvertMeshSubsetToStrips</unmanaged-short>	
        public static void ConvertMeshSubsetToStrips(SharpDX.Direct3D9.BaseMesh meshIn, int attribId, int iBOptions, out SharpDX.Direct3D9.IndexBuffer indexBufferOut, int numIndicesRef, out SharpDX.Direct3D.Blob stripLengthsOut, int numStripsRef) {
            unsafe {
                IntPtr indexBufferOut_ = IntPtr.Zero;
                IntPtr stripLengthsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXConvertMeshSubsetToStrips_((void*)((meshIn == null)?IntPtr.Zero:meshIn.NativePointer), attribId, iBOptions, &indexBufferOut_, &numIndicesRef, &stripLengthsOut_, &numStripsRef);		
                indexBufferOut= (indexBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.IndexBuffer(indexBufferOut_);	
                stripLengthsOut= (stripLengthsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(stripLengthsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXConvertMeshSubsetToStrips", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXConvertMeshSubsetToStrips_(void* arg0,int arg1,int arg2,void* arg3,void* arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Calculate per-triangle IMT's from per-texel data. This function is similar to <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeIMTFromTexture"/></strong>, but it uses a float array to pass in the data, and it can calculate higher dimensional values than 4.</p>	
        /// </summary>	
        /// <param name="meshRef">No documentation.</param>	
        /// <param name="dwTextureIndex">No documentation.</param>	
        /// <param name="fTexelSignalRef">No documentation.</param>	
        /// <param name="uWidth">No documentation.</param>	
        /// <param name="uHeight">No documentation.</param>	
        /// <param name="uSignalDimension">No documentation.</param>	
        /// <param name="uComponents">No documentation.</param>	
        /// <param name="dwOptions">No documentation.</param>	
        /// <param name="statusCallbackRef">No documentation.</param>	
        /// <param name="userContextRef">No documentation.</param>	
        /// <param name="iMTDataOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>; otherwise, the value is <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeIMTFromPerTexelSignal']/*"/>	
        /// <msdn-id>bb172737</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeIMTFromPerTexelSignal([In] ID3DXMesh* pMesh,[In] unsigned int dwTextureIndex,[In] float* pfTexelSignal,[In] unsigned int uWidth,[In] unsigned int uHeight,[In] unsigned int uSignalDimension,[In] unsigned int uComponents,[In] unsigned int dwOptions,[In] __function__stdcall* pStatusCallback,[In] void* pUserContext,[In] ID3DXBuffer** ppIMTData)</unmanaged>	
        /// <unmanaged-short>D3DXComputeIMTFromPerTexelSignal</unmanaged-short>	
        public static void ComputeIMTFromPerTexelSignal(SharpDX.Direct3D9.Mesh meshRef, int dwTextureIndex, float fTexelSignalRef, int uWidth, int uHeight, int uSignalDimension, int uComponents, int dwOptions, SharpDX.FunctionCallback statusCallbackRef, System.IntPtr userContextRef, out SharpDX.Direct3D.Blob iMTDataOut) {
            unsafe {
                IntPtr iMTDataOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeIMTFromPerTexelSignal_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), dwTextureIndex, &fTexelSignalRef, uWidth, uHeight, uSignalDimension, uComponents, dwOptions, statusCallbackRef, (void*)userContextRef, &iMTDataOut_);		
                iMTDataOut= (iMTDataOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(iMTDataOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeIMTFromPerTexelSignal", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeIMTFromPerTexelSignal_(void* arg0,int arg1,void* arg2,int arg3,int arg4,int arg5,int arg6,int arg7,void* arg8,void* arg9,void* arg10);

        
        /// <summary>	
        /// <p>Gets the size of the triangle patch.</p>	
        /// </summary>	
        /// <param name="fNumSegsRef"><dd>  <p>Number of segments per edge to tessellate.</p> </dd></param>	
        /// <param name="dwTrianglesRef"><dd>  <p>Pointer to a DWORD that contains the number of triangles in the patch.</p> </dd></param>	
        /// <param name="dwVerticesRef"><dd>  <p>Pointer to a DWORD that contains the number of vertices in the triangle patch.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXTriPatchSize']/*"/>	
        /// <msdn-id>bb205476</msdn-id>	
        /// <unmanaged>HRESULT D3DXTriPatchSize([In] const float* pfNumSegs,[Out] unsigned int* pdwTriangles,[Out] unsigned int* pdwVertices)</unmanaged>	
        /// <unmanaged-short>D3DXTriPatchSize</unmanaged-short>	
        public static SharpDX.Result TriPatchSize(float fNumSegsRef, out int dwTrianglesRef, out int dwVerticesRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dwTrianglesRef_ = &dwTrianglesRef)
                    fixed (void* dwVerticesRef_ = &dwVerticesRef)
                        __result__= 
        				D3DXTriPatchSize_(&fNumSegsRef, dwTrianglesRef_, dwVerticesRef_);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXTriPatchSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXTriPatchSize_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Computes unit normals for each vertex in a mesh. Provided to support legacy applications. Use <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/></strong> for better results.</p>	
        /// </summary>	
        /// <param name="meshRef">No documentation.</param>	
        /// <param name="adjacencyRef">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The input mesh must have the <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flag specified in its flexible vertex format (FVF).</p><p>A normal for a vertex is generated by averaging the normals of all faces that share that vertex.</p><p>If adjacency is provided, replicated vertices are ignored and "smoothed" over. If adjacency is not provided, replicated vertices will have normals averaged in from only the faces explicitly referencing them.</p><p>This function simply calls <strong><see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/></strong> with the following input parameters:</p><pre> <see cref="SharpDX.Direct3D9.D3DX9.ComputeTangentFrameEx"/>( pMesh, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.DeclarationUsage.Normal"/>, 0, <see cref="SharpDX.Direct3D9.TangentOptions.GenerateInPlace"/> | <see cref="SharpDX.Direct3D9.TangentOptions.CalculateNormals"/>, pAdjacency, -1.01f, -0.01f, -1.01f, <c>null</c>, <c>null</c>);	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeNormals']/*"/>	
        /// <msdn-id>bb172742</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeNormals([In] ID3DXBaseMesh* pMesh,[In] const unsigned int* pAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXComputeNormals</unmanaged-short>	
        public static void ComputeNormals(SharpDX.Direct3D9.BaseMesh meshRef, int adjacencyRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXComputeNormals_((void*)((meshRef == null)?IntPtr.Zero:meshRef.NativePointer), &adjacencyRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeNormals", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeNormals_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Disassemble a shader.</p><p><strong>Note</strong>??Instead of using this legacy function, we recommend that you use the <strong><see cref="SharpDX.D3DCompiler.D3D.Disassemble"/></strong> API.</p>	
        /// </summary>	
        /// <param name="shaderRef">No documentation.</param>	
        /// <param name="enableColorCode">No documentation.</param>	
        /// <param name="commentsRef">No documentation.</param>	
        /// <param name="disassemblyOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXDisassembleShader']/*"/>	
        /// <msdn-id>bb172820</msdn-id>	
        /// <unmanaged>HRESULT D3DXDisassembleShader([In] const void* pShader,[In] BOOL EnableColorCode,[In] const char* pComments,[In] ID3DXBuffer** ppDisassembly)</unmanaged>	
        /// <unmanaged-short>D3DXDisassembleShader</unmanaged-short>	
        public static void DisassembleShader(System.IntPtr shaderRef, SharpDX.Mathematics.Interop.RawBool enableColorCode, string commentsRef, out SharpDX.Direct3D.Blob disassemblyOut) {
            unsafe {
                IntPtr commentsRef_ = Utilities.StringToHGlobalAnsi(commentsRef);
                IntPtr disassemblyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXDisassembleShader_((void*)shaderRef, enableColorCode, (void*)commentsRef_, &disassemblyOut_);		
                Marshal.FreeHGlobal(commentsRef_ );
                disassemblyOut= (disassemblyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(disassemblyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXDisassembleShader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXDisassembleShader_(void* arg0,SharpDX.Mathematics.Interop.RawBool arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Preprocesses a shader without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. </p><p><strong>Note</strong>??Instead of using this legacy function, we recommend that you use the <strong><see cref="SharpDX.D3DCompiler.D3D.Preprocess"/></strong> API.</p>	
        /// </summary>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="shaderTextOut">No documentation.</param>	
        /// <param name="errorMsgsOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXPreprocessShader']/*"/>	
        /// <msdn-id>bb205398</msdn-id>	
        /// <unmanaged>HRESULT D3DXPreprocessShader([In] const void* pSrcData,[In] unsigned int SrcDataSize,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] ID3DXBuffer** ppShaderText,[In] ID3DXBuffer** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DXPreprocessShader</unmanaged-short>	
        public static void PreprocessShader(System.IntPtr srcDataRef, int srcDataSize, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, out SharpDX.Direct3D.Blob shaderTextOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr shaderTextOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXPreprocessShader_((void*)srcDataRef, srcDataSize, definesRef_, (void*)includeRef, &shaderTextOut_, &errorMsgsOut_);		
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                shaderTextOut= (shaderTextOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderTextOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXPreprocessShader_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Compile a shader file.</p><p><strong>Note</strong>??Instead of using this legacy function, we recommend that you compile offline by using the Fxc.exe command-line compiler or use the <strong><see cref="SharpDX.D3DCompiler.D3D.Compile"/></strong> API.</p>	
        /// </summary>	
        /// <param name="srcFileRef">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="functionNameRef">No documentation.</param>	
        /// <param name="profileRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="shaderOut">No documentation.</param>	
        /// <param name="errorMsgsOut">No documentation.</param>	
        /// <param name="constantTableOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_NOTIMPL, E_OUTOFMEMORY. </p><p>E_NOTIMPL is returned if you're using 1.1 shaders (vs_1_1and ps_1_1).</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCompileShaderFromFileW']/*"/>	
        /// <msdn-id>bb172732</msdn-id>	
        /// <unmanaged>HRESULT D3DXCompileShaderFromFileW([In] const wchar_t* pSrcFile,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] const char* pFunctionName,[In] const char* pProfile,[In] unsigned int Flags,[In] ID3DXBuffer** ppShader,[In] ID3DXBuffer** ppErrorMsgs,[In] ID3DXConstantTable** ppConstantTable)</unmanaged>	
        /// <unmanaged-short>D3DXCompileShaderFromFileW</unmanaged-short>	
        public static void CompileShaderFromFileW(string srcFileRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, string functionNameRef, string profileRef, int flags, out SharpDX.Direct3D.Blob shaderOut, out SharpDX.Direct3D.Blob errorMsgsOut, out SharpDX.Direct3D9.ConstantTable constantTableOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr functionNameRef_ = Utilities.StringToHGlobalAnsi(functionNameRef);
                IntPtr profileRef_ = Utilities.StringToHGlobalAnsi(profileRef);
                IntPtr shaderOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                IntPtr constantTableOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCompileShaderFromFileW_((void*)srcFileRef_, definesRef_, (void*)includeRef, (void*)functionNameRef_, (void*)profileRef_, flags, &shaderOut_, &errorMsgsOut_, &constantTableOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(functionNameRef_ );
                Marshal.FreeHGlobal(profileRef_ );
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                constantTableOut= (constantTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ConstantTable(constantTableOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCompileShaderFromFileW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,void* arg6,void* arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates a texture shader object from the compiled shader.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the function DWORD stream.</p> </dd></param>	
        /// <param name="textureShaderOut"><dd>  <p>Returns an <strong><see cref="SharpDX.Direct3D9.TextureShader"/></strong> object which can be used to procedurally fill the contents of a texture using the <strong><see cref="SharpDX.Direct3D9.D3DX9.FillTextureTX"/></strong> functions.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextureShader']/*"/>	
        /// <msdn-id>bb172808</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextureShader([In] const unsigned int* pFunction,[In] ID3DXTextureShader** ppTextureShader)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextureShader</unmanaged-short>	
        public static void CreateTextureShader(int functionRef, out SharpDX.Direct3D9.TextureShader textureShaderOut) {
            unsafe {
                IntPtr textureShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTextureShader_(&functionRef, &textureShaderOut_);		
                textureShaderOut= (textureShaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.TextureShader(textureShaderOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureShader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextureShader_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Get the semantics for all shader output elements.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the shader function DWORD stream.</p> </dd></param>	
        /// <param name="semanticsRef"><dd>  <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.ShaderSemantic"/></strong> structures.  The function will fill this array with the semantics for each output element referenced by the shader.  This array is assumed to contain at least MAXD3DDECLLENGTH elements. However, calling <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderOutputSemantics"/></strong> with pSemantics = <strong><c>null</c></strong> will return the number of elements  needed for pCount.</p> </dd></param>	
        /// <param name="countRef"><dd>  <p>Returns the number of elements in pSemantics.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetShaderOutputSemantics']/*"/>	
        /// <msdn-id>bb172873</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetShaderOutputSemantics([In] const void* pFunction,[In, Out, Buffer] D3DXSEMANTIC* pSemantics,[InOut] unsigned int* pCount)</unmanaged>	
        /// <unmanaged-short>D3DXGetShaderOutputSemantics</unmanaged-short>	
        public static void GetShaderOutputSemantics(System.IntPtr functionRef, SharpDX.Direct3D9.ShaderSemantic[] semanticsRef, ref int countRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* semanticsRef_ = semanticsRef)
                    fixed (void* countRef_ = &countRef)
                        __result__= 
        				D3DXGetShaderOutputSemantics_((void*)functionRef, semanticsRef_, countRef_);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderOutputSemantics", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetShaderOutputSemantics_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Gets the semantics for the shader inputs. Use this method to determine the input vertex format.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the shader function DWORD stream.</p> </dd></param>	
        /// <param name="semanticsRef"><dd>  <p>Pointer to an array of <strong><see cref="SharpDX.Direct3D9.ShaderSemantic"/></strong> structures.  The function will fill this array with the semantics for each input element referenced by the shader. This array is assumed to contain at least MAXD3DDECLLENGTH elements. However, calling <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderInputSemantics"/></strong> with pSemantics = <strong><c>null</c></strong> will return the number of elements  needed for pCount.</p> </dd></param>	
        /// <param name="countRef"><dd>  <p>Returns the number of elements in pSemantics.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Use <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderInputSemantics"/></strong> to return a list of input semantics required by the shader. This is the way to find out what the input vertex format is for a high-level shader language (HLSL) shader. If the shader has additional inputs that your vertex declaration is missing, you could create an extra vertex stream that has a stride of 0 that has the missing components with default values. For instance, this technique could be used to provide default vertex color for models that do not specify it.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetShaderInputSemantics']/*"/>	
        /// <msdn-id>bb172872</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetShaderInputSemantics([In] const void* pFunction,[In, Out, Buffer] D3DXSEMANTIC* pSemantics,[InOut] unsigned int* pCount)</unmanaged>	
        /// <unmanaged-short>D3DXGetShaderInputSemantics</unmanaged-short>	
        public static void GetShaderInputSemantics(System.IntPtr functionRef, SharpDX.Direct3D9.ShaderSemantic[] semanticsRef, ref int countRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* semanticsRef_ = semanticsRef)
                    fixed (void* countRef_ = &countRef)
                        __result__= 
        				D3DXGetShaderInputSemantics_((void*)functionRef, semanticsRef_, countRef_);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderInputSemantics", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetShaderInputSemantics_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Returns the name of the highest high-level shader language (HLSL) profile supported by a given device.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to the device. See <strong><see cref="SharpDX.Direct3D9.Device"/></strong>.</p> </dd></param>	
        /// <returns><p>The HLSL profile name.</p><p>If the device does not support pixel shaders then the function returns <strong><c>null</c></strong>.</p></returns>	
        /// <remarks>	
        /// <p>A shader profile specifies the assembly shader version to use and the capabilities available to the HLSL compiler when compiling a shader.  The following table lists the pixel shader profiles that are supported.</p><table> <tr><th>Shader Profile</th><th>Description</th></tr> <tr><td>ps_1_1</td><td>Compile to ps_1_1 version.</td></tr> <tr><td>ps_1_2</td><td>Compile to ps_1_2 version.</td></tr> <tr><td>ps_1_3</td><td>Compile to ps_1_3 version.</td></tr> <tr><td>ps_1_4</td><td>Compile to ps_1_4 version.</td></tr> <tr><td>ps_2_0</td><td>Compile to ps_2_0 version.</td></tr> <tr><td>ps_2_a</td><td>Same as the ps_2_0 profile, with the following additional capabilities available for the compiler to target: <ul> <li>Number of Temporary Registers (r#) is greater than or equal to 22.</li> <li>Arbitrary source swizzle.</li> <li>Gradient instructions: dsx, dsy.</li> <li>Predication.</li> <li>No dependent texture read limit.</li> <li>No limit for the number of texture instructions.</li> </ul> </td></tr> <tr><td>ps_2_b</td><td>Same as the ps_2_0 profile, with the following additional capabilities available for the compiler to target: <ul> <li>Number of Temporary Registers (r#) is greater than or equal to 32.</li> <li>No limit for the number of texture instructions.</li> </ul> </td></tr> <tr><td>ps_3_0</td><td>Compile to ps_3_0 version.</td></tr> </table><p>?</p><p>For more information about the differences between shader versions, see Pixel Shader Differences.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetPixelShaderProfile']/*"/>	
        /// <msdn-id>bb172870</msdn-id>	
        /// <unmanaged>const char* D3DXGetPixelShaderProfile([In] IDirect3DDevice9* pDevice)</unmanaged>	
        /// <unmanaged-short>D3DXGetPixelShaderProfile</unmanaged-short>	
        public static string GetPixelShaderProfile(SharpDX.Direct3D9.Device deviceRef) {
            unsafe {
                string __result__;
                __result__= 
				Marshal.PtrToStringAnsi(D3DXGetPixelShaderProfile_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer)));		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetPixelShaderProfile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern System.IntPtr D3DXGetPixelShaderProfile_(void* arg0);

        
        /// <summary>	
        /// <p>Searches through a shader for a particular comment. The comment is identified by a four-character code (FOURCC) in the first DWORD of the comment.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the shader function DWORD stream.</p> </dd></param>	
        /// <param name="fourCC"><dd>  <p>FOURCC code that identifies the comment block. See FourCC Formats.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>Returns a reference to the comment data (not including the comment token and FOURCC code). This value can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="sizeInBytesRef"><dd>  <p>Returns the size of the comment data in bytes. This value can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the comment is not found, and no other error has occurred, S_FALSE is returned.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFindShaderComment']/*"/>	
        /// <msdn-id>bb172838</msdn-id>	
        /// <unmanaged>HRESULT D3DXFindShaderComment([In] const void* pFunction,[In] unsigned int FourCC,[Out] const void** ppData,[Out] unsigned int* pSizeInBytes)</unmanaged>	
        /// <unmanaged-short>D3DXFindShaderComment</unmanaged-short>	
        public static void FindShaderComment(System.IntPtr functionRef, int fourCC, out System.IntPtr dataOut, out int sizeInBytesRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataOut_ = &dataOut)
                    fixed (void* sizeInBytesRef_ = &sizeInBytesRef)
                        __result__= 
        				D3DXFindShaderComment_((void*)functionRef, fourCC, dataOut_, sizeInBytesRef_);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFindShaderComment", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFindShaderComment_(void* arg0,int arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Assemble a shader.</p>	
        /// </summary>	
        /// <param name="hSrcModule"><dd>  <p>Handle to a module containing the effect description. If this parameter is <strong><c>null</c></strong>, the current module will be used.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional <strong><c>null</c></strong> terminated array of <strong><see cref="SharpDX.Direct3D9.Macro"/></strong> structures. This value may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags for details.</p> </dd></param>	
        /// <param name="shaderOut"><dd>  <p>Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.  </p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.AssembleShaderFromResourceW"/>. Otherwise, the function call resolves to D3DXAssembleShaderFromResourceA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXAssembleShaderFromResourceW']/*"/>	
        /// <msdn-id>bb172709</msdn-id>	
        /// <unmanaged>HRESULT D3DXAssembleShaderFromResourceW([In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXBuffer** ppShader,[In] ID3DXBuffer** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DXAssembleShaderFromResourceW</unmanaged-short>	
        public static void AssembleShaderFromResourceW(System.IntPtr hSrcModule, string srcResourceRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, out SharpDX.Direct3D.Blob shaderOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr shaderOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXAssembleShaderFromResourceW_((void*)hSrcModule, (void*)srcResourceRef_, definesRef_, (void*)includeRef, flags, &shaderOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXAssembleShaderFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Assemble a shader.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>Pointer to a memory buffer that contains the shader data.</p> </dd></param>	
        /// <param name="srcDataLen"><dd>  <p>Length of the effect data, in bytes.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional <strong><c>null</c></strong> terminated array of <strong><see cref="SharpDX.Direct3D9.Macro"/></strong> structures. This value may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags for details.</p> </dd></param>	
        /// <param name="shaderOut"><dd>  <p>Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.</p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXAssembleShader']/*"/>	
        /// <msdn-id>bb172707</msdn-id>	
        /// <unmanaged>HRESULT D3DXAssembleShader([In] const void* pSrcData,[In] unsigned int SrcDataLen,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXBuffer** ppShader,[In] ID3DXBuffer** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DXAssembleShader</unmanaged-short>	
        public static void AssembleShader(System.IntPtr srcDataRef, int srcDataLen, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, out SharpDX.Direct3D.Blob shaderOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr shaderOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXAssembleShader_((void*)srcDataRef, srcDataLen, definesRef_, (void*)includeRef, flags, &shaderOut_, &errorMsgsOut_);		
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXAssembleShader_(void* arg0,int arg1,void* arg2,void* arg3,int arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Compile a shader file.</p><p><strong>Note</strong>??Instead of using this legacy function, we recommend that you compile offline by using the Fxc.exe command-line compiler or use the <strong><see cref="SharpDX.D3DCompiler.D3D.Compile"/></strong> API.</p>	
        /// </summary>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataLen">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="functionNameRef">No documentation.</param>	
        /// <param name="profileRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="shaderOut">No documentation.</param>	
        /// <param name="errorMsgsOut">No documentation.</param>	
        /// <param name="constantTableOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCompileShader']/*"/>	
        /// <msdn-id>bb172731</msdn-id>	
        /// <unmanaged>HRESULT D3DXCompileShader([In] const void* pSrcData,[In] unsigned int SrcDataLen,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] const char* pFunctionName,[In] const char* pProfile,[In] unsigned int Flags,[In] ID3DXBuffer** ppShader,[In] ID3DXBuffer** ppErrorMsgs,[In] ID3DXConstantTable** ppConstantTable)</unmanaged>	
        /// <unmanaged-short>D3DXCompileShader</unmanaged-short>	
        public static void CompileShader(System.IntPtr srcDataRef, int srcDataLen, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, string functionNameRef, string profileRef, int flags, out SharpDX.Direct3D.Blob shaderOut, out SharpDX.Direct3D.Blob errorMsgsOut, out SharpDX.Direct3D9.ConstantTable constantTableOut) {
            unsafe {
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr functionNameRef_ = Utilities.StringToHGlobalAnsi(functionNameRef);
                IntPtr profileRef_ = Utilities.StringToHGlobalAnsi(profileRef);
                IntPtr shaderOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                IntPtr constantTableOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCompileShader_((void*)srcDataRef, srcDataLen, definesRef_, (void*)includeRef, (void*)functionNameRef_, (void*)profileRef_, flags, &shaderOut_, &errorMsgsOut_, &constantTableOut_);		
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(functionNameRef_ );
                Marshal.FreeHGlobal(profileRef_ );
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                constantTableOut= (constantTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ConstantTable(constantTableOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShader", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCompileShader_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4,void* arg5,int arg6,void* arg7,void* arg8,void* arg9);

        
        /// <summary>	
        /// <p>Get the sampler names referenced in a shader.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the shader function DWORD stream.</p> </dd></param>	
        /// <param name="samplersRef"><dd>  <p>Pointer to an array of LPCSTRs. The function will fill this array with references to the sampler names contained within <em>pFunction</em>. The maximum array size is the maximum number of sampler registers (16 for vs_3_0 and ps_3_0).</p> <p>To find the number of samplers used, check <em>pCount</em> after calling <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderSamplers"/></strong> with pSamplers = <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="countRef"><dd>  <p>Returns the number of samplers referenced by the shader.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetShaderSamplers']/*"/>	
        /// <msdn-id>bb172874</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetShaderSamplers([In] const void* pFunction,[In, Out, Buffer] const void** pSamplers,[InOut] unsigned int* pCount)</unmanaged>	
        /// <unmanaged-short>D3DXGetShaderSamplers</unmanaged-short>	
        public static void GetShaderSamplers(System.IntPtr functionRef, System.IntPtr samplersRef, ref int countRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* countRef_ = &countRef)
                    __result__= 
    				D3DXGetShaderSamplers_((void*)functionRef, (void*)samplersRef, countRef_);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderSamplers", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetShaderSamplers_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Gets the shader-constant table embedded inside a shader.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the function DWORD stream.</p> </dd></param>	
        /// <returns><dd>  <p>Returns the constant table interface (see <strong><see cref="SharpDX.Direct3D9.ConstantTable"/></strong>) that manages the constant table.</p> </dd></returns>	
        /// <remarks>	
        /// <p>A constant table is generated by <strong><see cref="SharpDX.Direct3D9.D3DX9.CompileShader"/></strong> and embedded in the shader body. If you need additional virtual address space, see <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderConstantTableEx"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetShaderConstantTable']/*"/>	
        /// <msdn-id>bb172871</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetShaderConstantTable([In] const void* pFunction,[Out] ID3DXConstantTable** ppConstantTable)</unmanaged>	
        /// <unmanaged-short>D3DXGetShaderConstantTable</unmanaged-short>	
        public static SharpDX.Direct3D9.ConstantTable GetShaderConstantTable(System.IntPtr functionRef) {
            unsafe {
                SharpDX.Direct3D9.ConstantTable constantTableOut;
                IntPtr constantTableOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXGetShaderConstantTable_((void*)functionRef, &constantTableOut_);		
                constantTableOut= (constantTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ConstantTable(constantTableOut_);	
                __result__.CheckError();
                return constantTableOut;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderConstantTable", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetShaderConstantTable_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Assemble a shader.</p>	
        /// </summary>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="definesRef"><dd>  <p>An optional <strong><c>null</c></strong> terminated array of <strong><see cref="SharpDX.Direct3D9.Macro"/></strong> structures. This value may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="includeRef"><dd>  <p>Optional interface reference, <strong><see cref="SharpDX.Direct3D9.Include"/></strong>, to use for handling #include directives. If this value is <strong><c>null</c></strong>, #includes will either be honored when compiling from a file or will cause an error when compiled from a resource or memory.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Compile options identified by various flags. The Direct3D 10 HLSL compiler is now the default. See <see cref="SharpDX.Direct3D9.ShaderFlags"/> Flags for details.</p> </dd></param>	
        /// <param name="shaderOut"><dd>  <p>Returns a buffer containing the created shader.  This buffer contains the compiled shader code, as well as any embedded debug and symbol table information.  </p> </dd></param>	
        /// <param name="errorMsgsOut"><dd>  <p>Returns a buffer containing a listing of errors and warnings that were encountered during the compile.  These are the same messages the debugger displays when running in debug mode. This value may be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.AssembleShaderFromFileW"/>. Otherwise, the function call resolves to D3DXAssembleShaderFromFileA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXAssembleShaderFromFileW']/*"/>	
        /// <msdn-id>bb172708</msdn-id>	
        /// <unmanaged>HRESULT D3DXAssembleShaderFromFileW([In] const wchar_t* pSrcFile,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] unsigned int Flags,[In] ID3DXBuffer** ppShader,[In] ID3DXBuffer** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DXAssembleShaderFromFileW</unmanaged-short>	
        public static void AssembleShaderFromFileW(string srcFileRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, int flags, out SharpDX.Direct3D.Blob shaderOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr shaderOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXAssembleShaderFromFileW_((void*)srcFileRef_, definesRef_, (void*)includeRef, flags, &shaderOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXAssembleShaderFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXAssembleShaderFromFileW_(void* arg0,void* arg1,void* arg2,int arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Gets the shader-constant table embedded inside a shader.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the function DWORD stream.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>Use the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to access up to 4 GB of virtual address space (instead of the default of 2 GB). If you do not need the additional virtual address space, use <strong><see cref="SharpDX.Direct3D9.D3DX9.GetShaderConstantTable"/></strong>.</p> </dd></param>	
        /// <param name="constantTableOut"><dd>  <p>Returns the constant table interface (see <strong><see cref="SharpDX.Direct3D9.ConstantTable"/></strong>) that manages the constant table.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>A constant table is generated by <strong><see cref="SharpDX.Direct3D9.D3DX9.CompileShader"/></strong> and embedded in the shader body.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetShaderConstantTableEx']/*"/>	
        /// <msdn-id>bb943959</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetShaderConstantTableEx([In] const void* pFunction,[In] unsigned int Flags,[In] ID3DXConstantTable** ppConstantTable)</unmanaged>	
        /// <unmanaged-short>D3DXGetShaderConstantTableEx</unmanaged-short>	
        public static void GetShaderConstantTableEx(System.IntPtr functionRef, int flags, out SharpDX.Direct3D9.ConstantTable constantTableOut) {
            unsafe {
                IntPtr constantTableOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXGetShaderConstantTableEx_((void*)functionRef, flags, &constantTableOut_);		
                constantTableOut= (constantTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ConstantTable(constantTableOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderConstantTableEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetShaderConstantTableEx_(void* arg0,int arg1,void* arg2);

        
        /// <summary>	
        /// <p>Returns the name of the highest high-level shader language (HLSL) profile supported by a given device.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to the device. See <strong><see cref="SharpDX.Direct3D9.Device"/></strong>.</p> </dd></param>	
        /// <returns><p>The HLSL profile name.</p><p>If the device does not support vertex shaders then the function returns <strong><c>null</c></strong>.</p></returns>	
        /// <remarks>	
        /// <p>A shader profile specifies the assembly shader version to use and the capabilities available to the HLSL compiler when compiling a shader.  The following table lists the vertex shader profiles that are supported.</p><table> <tr><th>Shader Profile</th><th>Description</th></tr> <tr><td>vs_1_1</td><td>Compile to vs_1_1 version.</td></tr> <tr><td>vs_2_0</td><td>Compile to vs_2_0 version.</td></tr> <tr><td>vs_2_a</td><td>Same as the vs_2_0 profile, with the following additional capabilities available for the compiler to target: <ul> <li>Number of Temporary Registers (r#) is greater than or equal to 13.</li> <li>Dynamic flow control instruction.</li> <li>Predication.</li> </ul> </td></tr> <tr><td>vs_3_0</td><td>Compile to vs_3_0 version.</td></tr> </table><p>?</p><p>For more information about the differences between shader versions, see Vertex Shader Differences.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetVertexShaderProfile']/*"/>	
        /// <msdn-id>bb172877</msdn-id>	
        /// <unmanaged>const char* D3DXGetVertexShaderProfile([In] IDirect3DDevice9* pDevice)</unmanaged>	
        /// <unmanaged-short>D3DXGetVertexShaderProfile</unmanaged-short>	
        public static string GetVertexShaderProfile(SharpDX.Direct3D9.Device deviceRef) {
            unsafe {
                string __result__;
                __result__= 
				Marshal.PtrToStringAnsi(D3DXGetVertexShaderProfile_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer)));		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetVertexShaderProfile", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern System.IntPtr D3DXGetVertexShaderProfile_(void* arg0);

        
        /// <summary>	
        /// <p>Preprocesses a shader resource without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation. </p><p><strong>Note</strong>??Instead of using this legacy function, we recommend that you use the <strong><see cref="SharpDX.D3DCompiler.D3D.Preprocess"/></strong> API.</p>	
        /// </summary>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="shaderTextOut">No documentation.</param>	
        /// <param name="errorMsgsOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXPreprocessShaderFromResourceW']/*"/>	
        /// <msdn-id>bb205400</msdn-id>	
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromResourceW([In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] ID3DXBuffer** ppShaderText,[In] ID3DXBuffer** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DXPreprocessShaderFromResourceW</unmanaged-short>	
        public static void PreprocessShaderFromResourceW(System.IntPtr hSrcModule, string srcResourceRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, out SharpDX.Direct3D.Blob shaderTextOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr shaderTextOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXPreprocessShaderFromResourceW_((void*)hSrcModule, (void*)srcResourceRef_, definesRef_, (void*)includeRef, &shaderTextOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                shaderTextOut= (shaderTextOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderTextOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXPreprocessShaderFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Compile a shader file.</p><p><strong>Note</strong>??Instead of using this legacy function, we recommend that you compile offline by using the Fxc.exe command-line compiler or use the <strong><see cref="SharpDX.D3DCompiler.D3D.Compile"/></strong> API.</p>	
        /// </summary>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="functionNameRef">No documentation.</param>	
        /// <param name="profileRef">No documentation.</param>	
        /// <param name="flags">No documentation.</param>	
        /// <param name="shaderOut">No documentation.</param>	
        /// <param name="errorMsgsOut">No documentation.</param>	
        /// <param name="constantTableOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCompileShaderFromResourceW']/*"/>	
        /// <msdn-id>bb172733</msdn-id>	
        /// <unmanaged>HRESULT D3DXCompileShaderFromResourceW([In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] const char* pFunctionName,[In] const char* pProfile,[In] unsigned int Flags,[In] ID3DXBuffer** ppShader,[In] ID3DXBuffer** ppErrorMsgs,[In] ID3DXConstantTable** ppConstantTable)</unmanaged>	
        /// <unmanaged-short>D3DXCompileShaderFromResourceW</unmanaged-short>	
        public static void CompileShaderFromResourceW(System.IntPtr hSrcModule, string srcResourceRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, string functionNameRef, string profileRef, int flags, out SharpDX.Direct3D.Blob shaderOut, out SharpDX.Direct3D.Blob errorMsgsOut, out SharpDX.Direct3D9.ConstantTable constantTableOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr functionNameRef_ = Utilities.StringToHGlobalAnsi(functionNameRef);
                IntPtr profileRef_ = Utilities.StringToHGlobalAnsi(profileRef);
                IntPtr shaderOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                IntPtr constantTableOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXCompileShaderFromResourceW_((void*)hSrcModule, (void*)srcResourceRef_, definesRef_, (void*)includeRef, (void*)functionNameRef_, (void*)profileRef_, flags, &shaderOut_, &errorMsgsOut_, &constantTableOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                Marshal.FreeHGlobal(functionNameRef_ );
                Marshal.FreeHGlobal(profileRef_ );
                shaderOut= (shaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                constantTableOut= (constantTableOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.ConstantTable(constantTableOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCompileShaderFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCompileShaderFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,int arg6,void* arg7,void* arg8,void* arg9);

        
        /// <summary>	
        /// <p>Preprocesses a shader file without performing compilation. This resolves all #defines and #includes, providing a self-contained shader for subsequent compilation.</p><p><strong>Note</strong>??Instead of using this legacy function, we recommend that you use the <strong><see cref="SharpDX.D3DCompiler.D3D.Preprocess"/></strong> API.</p>	
        /// </summary>	
        /// <param name="srcFileRef">No documentation.</param>	
        /// <param name="definesRef">No documentation.</param>	
        /// <param name="includeRef">No documentation.</param>	
        /// <param name="shaderTextOut">No documentation.</param>	
        /// <param name="errorMsgsOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXPreprocessShaderFromFileW']/*"/>	
        /// <msdn-id>bb205399</msdn-id>	
        /// <unmanaged>HRESULT D3DXPreprocessShaderFromFileW([In] const wchar_t* pSrcFile,[In, Buffer, Optional] const D3DXMACRO* pDefines,[In] ID3DXInclude* pInclude,[In] ID3DXBuffer** ppShaderText,[In] ID3DXBuffer** ppErrorMsgs)</unmanaged>	
        /// <unmanaged-short>D3DXPreprocessShaderFromFileW</unmanaged-short>	
        public static void PreprocessShaderFromFileW(string srcFileRef, SharpDX.Direct3D9.Macro[] definesRef, System.IntPtr includeRef, out SharpDX.Direct3D.Blob shaderTextOut, out SharpDX.Direct3D.Blob errorMsgsOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Direct3D9.Macro.__Native[] definesRef__ = (definesRef == null)? null : new SharpDX.Direct3D9.Macro.__Native[definesRef.Length];
				if (definesRef != null)
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalTo(ref definesRef__[i]);				
                IntPtr shaderTextOut_ = IntPtr.Zero;
                IntPtr errorMsgsOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* definesRef_ = definesRef__)
                    __result__= 
    				D3DXPreprocessShaderFromFileW_((void*)srcFileRef_, definesRef_, (void*)includeRef, &shaderTextOut_, &errorMsgsOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                if (definesRef != null )															
                for (int i = 0; i < definesRef.Length; i++)
                    definesRef[i].__MarshalFree(ref definesRef__[i]);
                shaderTextOut= (shaderTextOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(shaderTextOut_);	
                errorMsgsOut= (errorMsgsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(errorMsgsOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXPreprocessShaderFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXPreprocessShaderFromFileW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Returns the size of the shader byte code, in bytes.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the function DWORD stream.</p> </dd></param>	
        /// <returns><p>Returns the size of the shader byte code, in bytes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetShaderSize']/*"/>	
        /// <msdn-id>bb172875</msdn-id>	
        /// <unmanaged>unsigned int D3DXGetShaderSize([In] const void* pFunction)</unmanaged>	
        /// <unmanaged-short>D3DXGetShaderSize</unmanaged-short>	
        public static int GetShaderSize(System.IntPtr functionRef) {
            unsafe {
                int __result__;
                __result__= 
				D3DXGetShaderSize_((void*)functionRef);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderSize", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetShaderSize_(void* arg0);

        
        /// <summary>	
        /// <p>Returns the shader version of the compiled shader.</p>	
        /// </summary>	
        /// <param name="functionRef"><dd>  <p>Pointer to the function DWORD stream.</p> </dd></param>	
        /// <returns><p>Returns the shader version of the given shader, or zero if the shader  function is <strong><c>null</c></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetShaderVersion']/*"/>	
        /// <msdn-id>bb172876</msdn-id>	
        /// <unmanaged>unsigned int D3DXGetShaderVersion([In] const void* pFunction)</unmanaged>	
        /// <unmanaged-short>D3DXGetShaderVersion</unmanaged-short>	
        public static int GetShaderVersion(System.IntPtr functionRef) {
            unsafe {
                int __result__;
                __result__= 
				D3DXGetShaderVersion_((void*)functionRef);		
                return __result__;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetShaderVersion", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetShaderVersion_(void* arg0);

        
        /// <summary>	
        /// <p>Uses a left-handed coordinate system to create a mesh containing a cylinder.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the created cylinder mesh.</p> </dd></param>	
        /// <param name="radius1"><dd>  <p>Radius at the negative Z end. Value should be greater than or equal to 0.0f.</p> </dd></param>	
        /// <param name="radius2"><dd>  <p>Radius at the positive Z end. Value should be greater than or equal to 0.0f.</p> </dd></param>	
        /// <param name="length"><dd>  <p>Length of the cylinder along the z-axis.</p> </dd></param>	
        /// <param name="slices"><dd>  <p>Number of slices about the main axis.</p> </dd></param>	
        /// <param name="stacks"><dd>  <p>Number of stacks along the main axis.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to the output shape, an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. <strong><c>null</c></strong> can be specified.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The created cylinder is centered at the origin, and its axis is aligned with the z-axis.</p><p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flexible vertex format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCylinder']/*"/>	
        /// <msdn-id>bb172762</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCylinder([In] IDirect3DDevice9* pDevice,[In] float Radius1,[In] float Radius2,[In] float Length,[In] unsigned int Slices,[In] unsigned int Stacks,[In] ID3DXMesh** ppMesh,[In] ID3DXBuffer** ppAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCylinder</unmanaged-short>	
        public static void CreateCylinder(SharpDX.Direct3D9.Device deviceRef, float radius1, float radius2, float length, int slices, int stacks, out SharpDX.Direct3D9.Mesh meshOut, out SharpDX.Direct3D.Blob adjacencyOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                IntPtr adjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateCylinder_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), radius1, radius2, length, slices, stacks, &meshOut_, &adjacencyOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCylinder", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCylinder_(void* arg0,float arg1,float arg2,float arg3,int arg4,int arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Uses a left-handed coordinate system to create a mesh containing a torus.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the created torus mesh.</p> </dd></param>	
        /// <param name="innerRadius"><dd>  <p>Inner-radius of the torus. Value should be greater than or equal to 0.0f.</p> </dd></param>	
        /// <param name="outerRadius"><dd>  <p>Outer-radius of the torus. Value should be greater than or equal to 0.0f.</p> </dd></param>	
        /// <param name="sides"><dd>  <p>Number of sides in a cross-section. Value must be greater than or equal to 3.</p> </dd></param>	
        /// <param name="rings"><dd>  <p>Number of rings making up the torus. Value must be greater than or equal to 3.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to the output shape, an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. <strong><c>null</c></strong> can be specified.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The created torus is centered at the origin, and its axis is aligned with the z-axis. The inner radius of the torus is the radius of the cross-section (the minor radius), and the outer radius of the torus is the radius of the central hole. </p><p>This function returns a mesh that can be used later for drawing or manipulation by the application.</p><p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flexible vertex format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTorus']/*"/>	
        /// <msdn-id>bb172809</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTorus([In] IDirect3DDevice9* pDevice,[In] float InnerRadius,[In] float OuterRadius,[In] unsigned int Sides,[In] unsigned int Rings,[In] ID3DXMesh** ppMesh,[In] ID3DXBuffer** ppAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTorus</unmanaged-short>	
        public static void CreateTorus(SharpDX.Direct3D9.Device deviceRef, float innerRadius, float outerRadius, int sides, int rings, out SharpDX.Direct3D9.Mesh meshOut, out SharpDX.Direct3D.Blob adjacencyOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                IntPtr adjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTorus_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), innerRadius, outerRadius, sides, rings, &meshOut_, &adjacencyOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTorus", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTorus_(void* arg0,float arg1,float arg2,int arg3,int arg4,void* arg5,void* arg6);

        
        /// <summary>	
        /// <p>Uses a left-handed coordinate system to create a mesh containing a sphere.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the created sphere mesh.</p> </dd></param>	
        /// <param name="radius"><dd>  <p>Radius of the sphere. This value should be greater than or equal to 0.0f.</p> </dd></param>	
        /// <param name="slices"><dd>  <p>Number of slices about the main axis.</p> </dd></param>	
        /// <param name="stacks"><dd>  <p>Number of stacks along the main axis.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to the output shape, an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. <strong><c>null</c></strong> can be specified.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The created sphere is centered at the origin, and its axis is aligned with the z-axis.</p><p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flexible vertex format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateSphere']/*"/>	
        /// <msdn-id>bb172795</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateSphere([In] IDirect3DDevice9* pDevice,[In] float Radius,[In] unsigned int Slices,[In] unsigned int Stacks,[In] ID3DXMesh** ppMesh,[In] ID3DXBuffer** ppAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXCreateSphere</unmanaged-short>	
        public static void CreateSphere(SharpDX.Direct3D9.Device deviceRef, float radius, int slices, int stacks, out SharpDX.Direct3D9.Mesh meshOut, out SharpDX.Direct3D.Blob adjacencyOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                IntPtr adjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateSphere_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), radius, slices, stacks, &meshOut_, &adjacencyOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateSphere", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateSphere_(void* arg0,float arg1,int arg2,int arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Uses a left-handed coordinate system to create a mesh containing a teapot.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the created teapot mesh.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to the output shape, an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. <strong><c>null</c></strong> can be specified.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flexible vertex format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTeapot']/*"/>	
        /// <msdn-id>bb172798</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTeapot([In] IDirect3DDevice9* pDevice,[In] ID3DXMesh** ppMesh,[In] ID3DXBuffer** ppAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTeapot</unmanaged-short>	
        public static void CreateTeapot(SharpDX.Direct3D9.Device deviceRef, out SharpDX.Direct3D9.Mesh meshOut, out SharpDX.Direct3D.Blob adjacencyOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                IntPtr adjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTeapot_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), &meshOut_, &adjacencyOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTeapot", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTeapot_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Uses a left-handed coordinate system to create a mesh containing an axis-aligned box.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the created box mesh.</p> </dd></param>	
        /// <param name="width"><dd>  <p>Width of the box, along the x-axis.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height of the box, along the y-axis.</p> </dd></param>	
        /// <param name="depth"><dd>  <p>Depth of the box, along the z-axis.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to the output shape, an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three DWORDs per face that specify the three neighbors for each face in the mesh. <strong><c>null</c></strong> can be specified.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The created box is centered at the origin.</p><p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flexible vertex format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateBox']/*"/>	
        /// <msdn-id>bb172752</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateBox([In] IDirect3DDevice9* pDevice,[In] float Width,[In] float Height,[In] float Depth,[In] ID3DXMesh** ppMesh,[In] ID3DXBuffer** ppAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXCreateBox</unmanaged-short>	
        public static void CreateBox(SharpDX.Direct3D9.Device deviceRef, float width, float height, float depth, out SharpDX.Direct3D9.Mesh meshOut, out SharpDX.Direct3D.Blob adjacencyOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                IntPtr adjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateBox_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), width, height, depth, &meshOut_, &adjacencyOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateBox", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateBox_(void* arg0,float arg1,float arg2,float arg3,void* arg4,void* arg5);

        
        /// <summary>	
        /// <p>Uses a left-handed coordinate system to create a mesh containing an 	
        /// n-sided polygon.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device associated with the created polygon mesh.</p> </dd></param>	
        /// <param name="length"><dd>  <p>Length of each side.</p> </dd></param>	
        /// <param name="sides"><dd>  <p>Number of sides for the polygon. Value must be greater than or equal to 3.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Address of a reference to the output shape, an <strong><see cref="SharpDX.Direct3D9.Mesh"/></strong> interface.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> interface. When the method returns, this parameter is filled with an array of three  DWORDs per face that specify the three neighbors for each face in the mesh. <strong><c>null</c></strong> can be specified.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The created polygon is centered at the origin.</p><p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flexible vertex format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreatePolygon']/*"/>	
        /// <msdn-id>bb172785</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreatePolygon([In] IDirect3DDevice9* pDevice,[In] float Length,[In] unsigned int Sides,[In] ID3DXMesh** ppMesh,[In] ID3DXBuffer** ppAdjacency)</unmanaged>	
        /// <unmanaged-short>D3DXCreatePolygon</unmanaged-short>	
        public static void CreatePolygon(SharpDX.Direct3D9.Device deviceRef, float length, int sides, out SharpDX.Direct3D9.Mesh meshOut, out SharpDX.Direct3D.Blob adjacencyOut) {
            unsafe {
                IntPtr meshOut_ = IntPtr.Zero;
                IntPtr adjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreatePolygon_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), length, sides, &meshOut_, &adjacencyOut_);		
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreatePolygon", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreatePolygon_(void* arg0,float arg1,int arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Creates a mesh containing the specified text, using the font associated with the device context.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to the device that created the mesh.</p> </dd></param>	
        /// <param name="hDC"><dd>  <p>Device context, containing the font for output. The font selected by the device context must be a TrueType font.</p> </dd></param>	
        /// <param name="textRef"><dd>  <p>Pointer to a string that specifies the text to generate. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="deviation"><dd>  <p>Maximum chordal deviation from TrueType font outlines.</p> </dd></param>	
        /// <param name="extrusion"><dd>  <p>Amount to extrude text in the negative z-direction.</p> </dd></param>	
        /// <param name="meshOut"><dd>  <p>Pointer to the returned mesh.</p> </dd></param>	
        /// <param name="adjacencyOut"><dd>  <p>Pointer to a buffer containing adjacency information. May be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="pGlyphMetrics"><dd>  <p>Pointer to an array of <strong>GLYPHMETRICSFLOAT</strong> structures that contain the glyph metric data. Each element contains information about the position and orientation of the corresponding glyph in the string. The number of elements in the array should be equal to the number of characters in the string. Note that the origin in each structure is not relative to the entire string, but rather is relative to that character cell. To compute the entire bounding box, add the increment for each glyph while traversing the string. If you are not concerned with the glyph sizes, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextW"/>. Otherwise, the function call resolves to D3DXCreateTextA because ANSI strings are being used.</p><p>This function creates a mesh with the <see cref="SharpDX.Direct3D9.MeshFlags.Managed"/> creation option and <see cref="SharpDX.Direct3D9.VertexFormat.Position"/> | <see cref="SharpDX.Direct3D9.VertexFormat.Normal"/> flexible vertex format (FVF).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextW']/*"/>	
        /// <msdn-id>bb172799</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextW([In] IDirect3DDevice9* pDevice,[In] HDC hDC,[In] const wchar_t* pText,[In] float Deviation,[In] float Extrusion,[In] ID3DXMesh** ppMesh,[In] ID3DXBuffer** ppAdjacency,[In] LPGLYPHMETRICSFLOAT pGlyphMetrics)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextW</unmanaged-short>	
        public static void CreateTextW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hDC, string textRef, float deviation, float extrusion, out SharpDX.Direct3D9.Mesh meshOut, out SharpDX.Direct3D.Blob adjacencyOut, System.IntPtr pGlyphMetrics) {
            unsafe {
                IntPtr textRef_ = Utilities.StringToHGlobalUni(textRef);
                IntPtr meshOut_ = IntPtr.Zero;
                IntPtr adjacencyOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTextW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hDC, (void*)textRef_, deviation, extrusion, &meshOut_, &adjacencyOut_, (void*)pGlyphMetrics);		
                Marshal.FreeHGlobal(textRef_ );
                meshOut= (meshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Mesh(meshOut_);	
                adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(adjacencyOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextW_(void* arg0,void* arg1,void* arg2,float arg3,float arg4,void* arg5,void* arg6,void* arg7);

        
        /// <summary>	
        /// <p>Retrieves information about a given image file in memory.</p>	
        /// </summary>	
        /// <param name="srcDataRef"><dd>  <p>VOID reference to the source file in memory.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Size of file in memory, in bytes. .</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled with the description of the data in the source file.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetImageInfoFromFileInMemory']/*"/>	
        /// <msdn-id>bb172868</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileInMemory([In] const void* pSrcData,[In] unsigned int SrcDataSize,[Out] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXGetImageInfoFromFileInMemory</unmanaged-short>	
        public static SharpDX.Direct3D9.ImageInformation GetImageInfoFromFileInMemory(System.IntPtr srcDataRef, int srcDataSize) {
            unsafe {
                SharpDX.Direct3D9.ImageInformation srcInfoRef;
                srcInfoRef = new SharpDX.Direct3D9.ImageInformation();
                SharpDX.Result __result__;
                __result__= 
				D3DXGetImageInfoFromFileInMemory_((void*)srcDataRef, srcDataSize, &srcInfoRef);		
                __result__.CheckError();
                return srcInfoRef;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetImageInfoFromFileInMemory_(void* arg0,int arg1,void* arg2);

        
        /// <summary>	
        /// <p>Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.</p>	
        /// </summary>	
        /// <param name="volumeTextureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> object, representing the texture to be filled.</p> </dd></param>	
        /// <param name="textureShaderRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.TextureShader"/></strong> texture shader object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following:D3DERR_NOTAVAILABLE, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The texture target must be an HLSL function that takes contains the following semantics:</p><ul> <li>One input parameter must use a POSITION semantic.</li> <li>One input parameter must use a PSIZE semantic.</li> <li>The function must return a parameter that uses the COLOR semantic.</li> </ul><p>The input parameters can be in any order. For an example, see <strong><see cref="SharpDX.Direct3D9.D3DX9.FillTextureTX"/></strong> </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFillVolumeTextureTX']/*"/>	
        /// <msdn-id>bb172836</msdn-id>	
        /// <unmanaged>HRESULT D3DXFillVolumeTextureTX([In] IDirect3DVolumeTexture9* pVolumeTexture,[In] ID3DXTextureShader* pTextureShader)</unmanaged>	
        /// <unmanaged-short>D3DXFillVolumeTextureTX</unmanaged-short>	
        public static void FillVolumeTextureTX(SharpDX.Direct3D9.VolumeTexture volumeTextureRef, SharpDX.Direct3D9.TextureShader textureShaderRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXFillVolumeTextureTX_((void*)((volumeTextureRef == null)?IntPtr.Zero:volumeTextureRef.NativePointer), (void*)((textureShaderRef == null)?IntPtr.Zero:textureShaderRef.NativePointer));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillVolumeTextureTX", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFillVolumeTextureTX_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Creates an empty cube texture, adjusting the calling parameters as needed.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="size"><dd>  <p>Width and height of the cube texture, in pixels. For example, if the cube texture is an 8-pixel by 8-pixel cube, the value for this parameter should be 8.</p> </dd></param>	
        /// <param name="mipLevels"><dd>  <p>Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>0, <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/>, or <see cref="SharpDX.Direct3D9.Usage.Dynamic"/>. Setting this flag to <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> indicates that the surface is to be used as a render target. The resource can then be passed to the <em>pNewRenderTarget</em> parameter of the <strong>SetRenderTarget</strong> method. If <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> is specified, the application should check that the device supports this operation by calling <strong>CheckDeviceFormat</strong>. For more information about using dynamic textures, see Using Dynamic Textures.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the cube texture. The returned cube texture might have a different format from that specified by  <em>Format</em>. Applications should check the format of the returned cube texture.</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the cube texture should be placed.</p> </dd></param>	
        /// <param name="cubeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface, representing the created cube texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Cube textures differ from other surfaces in that they are collections of surfaces. </p><p>Internally, <see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTexture"/> uses <strong><see cref="SharpDX.Direct3D9.D3DX9.CheckCubeTextureRequirements"/></strong> to adjust the calling parameters. Therefore, calls to <see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTexture"/> will often succeed where calls to <strong>CreateCubeTexture</strong> would fail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCubeTexture']/*"/>	
        /// <msdn-id>bb172755</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCubeTexture([In] IDirect3DDevice9* pDevice,[In] unsigned int Size,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] IDirect3DCubeTexture9** ppCubeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCubeTexture</unmanaged-short>	
        public static void CreateCubeTexture(SharpDX.Direct3D9.Device deviceRef, int size, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, out SharpDX.Direct3D9.CubeTexture cubeTextureOut) {
            unsafe {
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateCubeTexture_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), size, mipLevels, usage, unchecked((int)format), unchecked((int)pool), &cubeTextureOut_);		
                cubeTextureOut= (cubeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CubeTexture(cubeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCubeTexture_(void* arg0,int arg1,int arg2,int arg3,int arg4,int arg5,void* arg6);

        
        /// <summary>	
        /// <p>Creates a volume texture from a file. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromFileInMemory"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="depth">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="volumeTextureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the <em>MipFilter</em> value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the <em>MipFilter</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateVolumeTextureFromFileInMemoryEx']/*"/>	
        /// <msdn-id>bb172814</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemoryEx([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int Depth,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] void* pSrcInfo,[Out, Buffer] PALETTEENTRY* pPalette,[In] IDirect3DVolumeTexture9** ppVolumeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateVolumeTextureFromFileInMemoryEx</unmanaged-short>	
        public static void CreateVolumeTextureFromFileInMemoryEx(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataSize, int width, int height, int depth, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, System.IntPtr srcInfoRef, SharpDX.Direct3D9.PaletteEntry[] paletteRef, out SharpDX.Direct3D9.VolumeTexture volumeTextureOut) {
            unsafe {
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* paletteRef_ = paletteRef)
                    __result__= 
    				D3DXCreateVolumeTextureFromFileInMemoryEx_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataSize, width, height, depth, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, (void*)srcInfoRef, paletteRef_, &volumeTextureOut_);		
                volumeTextureOut= (volumeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VolumeTexture(volumeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateVolumeTextureFromFileInMemoryEx_(void* arg0,void* arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,int arg10,int arg11,SharpDX.Mathematics.Interop.RawColorBGRA arg12,void* arg13,void* arg14,void* arg15);

        
        /// <summary>	
        /// <p>Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.</p>	
        /// </summary>	
        /// <param name="textureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> object, representing the texture to be filled.</p> </dd></param>	
        /// <param name="textureShaderRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.TextureShader"/></strong> texture shader object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The texture target must be an HLSL function that takes contains the following semantics:</p><ul> <li>One input parameter must use a POSITION semantic.</li> <li>One input parameter must use a PSIZE semantic.</li> <li>The function must return a parameter that uses the COLOR semantic.</li> </ul><p>The following is an example of such an HLSL function:</p><pre> float4 TextureGradientFill( float2 vTexCoord : POSITION,  float2 vTexelSize : PSIZE) : COLOR  { float r,g, b, xSq,ySq, a; xSq = 2.f*vTexCoord.x-1.f; xSq *= xSq; ySq = 2.f*vTexCoord.y-1.f; ySq *= ySq; a = sqrt(xSq+ySq); if (a &gt; 1.0f) { a = 1.0f-(a-1.0f); } else if (a &lt; 0.2f) { a = 0.2f; } r = 1-vTexCoord.x; g = 1-vTexCoord.y; b = vTexCoord.x; return float4(r, g, b, a); };	
        /// </pre><p>Note that the input parameters can be in any order, but both input semantics must be represented.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFillTextureTX']/*"/>	
        /// <msdn-id>bb172834</msdn-id>	
        /// <unmanaged>HRESULT D3DXFillTextureTX([In] IDirect3DTexture9* pTexture,[In] ID3DXTextureShader* pTextureShader)</unmanaged>	
        /// <unmanaged-short>D3DXFillTextureTX</unmanaged-short>	
        public static void FillTextureTX(SharpDX.Direct3D9.Texture textureRef, SharpDX.Direct3D9.TextureShader textureShaderRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXFillTextureTX_((void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer), (void*)((textureShaderRef == null)?IntPtr.Zero:textureShaderRef.NativePointer));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillTextureTX", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFillTextureTX_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Checks cube-texture-creation parameters.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the cube texture.</p> </dd></param>	
        /// <param name="sizeRef"><dd>  <p>Pointer to the requested width and height in pixels, or <strong><c>null</c></strong>. Returns the corrected size.</p> </dd></param>	
        /// <param name="numMipLevelsRef"><dd>  <p>Pointer to the number of requested mipmap levels, or <strong><c>null</c></strong>. Returns the corrected number of mipmap levels.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>0 or <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/>. Setting this flag to <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the <strong>SetRenderTarget</strong> method. If <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> is specified, the application should check that the device supports this operation by calling <strong>CheckDeviceFormat</strong>.</p> </dd></param>	
        /// <param name="formatRef"><dd>  <p>Pointer to a member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or <strong><c>null</c></strong>. Returns the corrected format.</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the texture should be placed.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If parameters to this function are invalid, this function returns corrected parameters.</p><p>Cube textures differ from other surfaces in that they are collections of surfaces. To call <strong>SetRenderTarget</strong> with a cube texture, you must select an individual face using <strong>GetCubeMapSurface</strong> and pass the resulting surface to <strong>SetRenderTarget</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCheckCubeTextureRequirements']/*"/>	
        /// <msdn-id>bb172715</msdn-id>	
        /// <unmanaged>HRESULT D3DXCheckCubeTextureRequirements([In] IDirect3DDevice9* pDevice,[InOut] unsigned int* pSize,[InOut] unsigned int* pNumMipLevels,[In] unsigned int Usage,[InOut] D3DFORMAT* pFormat,[In] D3DPOOL Pool)</unmanaged>	
        /// <unmanaged-short>D3DXCheckCubeTextureRequirements</unmanaged-short>	
        public static void CheckCubeTextureRequirements(SharpDX.Direct3D9.Device deviceRef, ref int sizeRef, ref int numMipLevelsRef, int usage, ref SharpDX.Direct3D9.Format formatRef, SharpDX.Direct3D9.Pool pool) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* sizeRef_ = &sizeRef)
                    fixed (void* numMipLevelsRef_ = &numMipLevelsRef)
                        fixed (void* formatRef_ = &formatRef)
                            __result__= 
            				D3DXCheckCubeTextureRequirements_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), sizeRef_, numMipLevelsRef_, usage, formatRef_, unchecked((int)pool));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckCubeTextureRequirements", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCheckCubeTextureRequirements_(void* arg0,void* arg1,void* arg2,int arg3,void* arg4,int arg5);

        
        /// <summary>	
        /// <p>Creates a texture from a file.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="textureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileW"/>. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used.</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileExW"/>(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppTexture).</p><p>Mipmapped textures automatically have each level filled with the loaded texture.</p><p>When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually.</p><p>Note that a resource created with this function will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p><p>For the best performance when using <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileW"/></strong>:</p><ol> <li>Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions.</li> <li>Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.</li> </ol>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextureFromFileW']/*"/>	
        /// <msdn-id>bb172801</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In] IDirect3DTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextureFromFileW</unmanaged-short>	
        public static void CreateTextureFromFileW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, out SharpDX.Direct3D9.Texture textureOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTextureFromFileW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, &textureOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextureFromFileW_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Loads a surface from a file.</p>	
        /// </summary>	
        /// <param name="destSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Specifies the destination surface, which receives the image.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a  <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the destination rectangle. Set this parameter to <strong><c>null</c></strong> to specify the entire surface.</p> </dd></param>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="srcRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the source rectangle. Set this parameter to <strong><c>null</c></strong> to specify the entire image.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>Combination of one or more <see cref="SharpDX.Direct3D9.Filter"/> controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <param name="srcInfoRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled with a description of the data in the source image file, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.LoadSurfaceFromFileW"/>. Otherwise, the function call resolves to D3DXLoadSurfaceFromFileA because ANSI strings are being used.</p><p>This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadSurfaceFromFileW"/></strong> is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong>AddDirtyRect</strong> on the surface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadSurfaceFromFileW']/*"/>	
        /// <msdn-id>bb172900</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileW([In] IDirect3DSurface9* pDestSurface,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestRect,[In] const wchar_t* pSrcFile,[In] const void* pSrcRect,[In] D3DX_FILTER Filter,[In] int ColorKey,[In] void* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXLoadSurfaceFromFileW</unmanaged-short>	
        public static void LoadSurfaceFromFileW(SharpDX.Direct3D9.Surface destSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destRectRef, string srcFileRef, System.IntPtr srcRectRef, SharpDX.Direct3D9.Filter filter, int colorKey, System.IntPtr srcInfoRef) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    __result__= 
    				D3DXLoadSurfaceFromFileW_((void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer), destPaletteRef_, (void*)destRectRef, (void*)srcFileRef_, (void*)srcRectRef, unchecked((int)filter), colorKey, (void*)srcInfoRef);		
                Marshal.FreeHGlobal(srcFileRef_ );
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadSurfaceFromFileW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,int arg6,void* arg7);

        
        /// <summary>	
        /// <p>Uses a user-provided function to fill each texel of each mip level of a given cube texture.</p>	
        /// </summary>	
        /// <param name="cubeTextureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface, representing the filled texture.</p> </dd></param>	
        /// <param name="functionRef"><dd>  <p>Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of LPD3DXFILL3D.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to an arbitrary block of user-defined data. This reference will be passed to the function provided in <em>pFunction</em>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Here is an example that creates a function called ColorCubeFill, which relies on <see cref="SharpDX.Direct3D9.D3DX9.FillCubeTexture"/>.</p><pre> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorCubeFill (<see cref="SharpDX.Mathematics.Interop.RawVector4"/>* pOut, const <see cref="SharpDX.Mathematics.Interop.RawVector3"/>* pTexCoord, 	
        /// const <see cref="SharpDX.Mathematics.Interop.RawVector3"/>* pTexelSize, LPVOID pData)	
        /// { *pOut = <see cref="SharpDX.Mathematics.Interop.RawVector4"/>(pTexCoord-&gt;x, pTexCoord-&gt;y, pTexCoord-&gt;z, 0.0f);	
        /// } // Fill the texture using <see cref="SharpDX.Direct3D9.D3DX9.FillCubeTexture"/>	
        /// if (FAILED (hr = <see cref="SharpDX.Direct3D9.D3DX9.FillCubeTexture"/> (m_pTexture, ColorCubeFill, <c>null</c>)))	
        /// { return hr;	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFillCubeTexture']/*"/>	
        /// <msdn-id>bb172831</msdn-id>	
        /// <unmanaged>HRESULT D3DXFillCubeTexture([In] IDirect3DCubeTexture9* pCubeTexture,[In] __function__stdcall* pFunction,[In] void* pData)</unmanaged>	
        /// <unmanaged-short>D3DXFillCubeTexture</unmanaged-short>	
        public static void FillCubeTexture(SharpDX.Direct3D9.CubeTexture cubeTextureRef, SharpDX.FunctionCallback functionRef, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXFillCubeTexture_((void*)((cubeTextureRef == null)?IntPtr.Zero:cubeTextureRef.NativePointer), functionRef, (void*)dataRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillCubeTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFillCubeTexture_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Creates an empty volume texture, adjusting the calling parameters as needed.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the volume texture.</p> </dd></param>	
        /// <param name="width"><dd>  <p>Width in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="depth"><dd>  <p>Depth in pixels. This value must be nonzero. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="mipLevels"><dd>  <p>Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>0 or <see cref="SharpDX.Direct3D9.Usage.Dynamic"/>. For more information about using dynamic textures, see Using Dynamic Textures.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the volume texture. The returned volume texture might have a different format from that specified by Format. Applications should check the format of the returned volume texture.</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the volume texture should be placed.</p> </dd></param>	
        /// <param name="volumeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface, representing the created volume texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, E_OUTOFMEMORY .</p></returns>	
        /// <remarks>	
        /// <p>Internally, <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTexture"/> uses <strong><see cref="SharpDX.Direct3D9.D3DX9.CheckVolumeTextureRequirements"/></strong> to adjust the calling parameters. Therefore, calls to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTexture"/> will often succeed where calls to <strong>CreateVolumeTexture</strong> would fail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateVolumeTexture']/*"/>	
        /// <msdn-id>bb172810</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateVolumeTexture([In] IDirect3DDevice9* pDevice,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int Depth,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] IDirect3DVolumeTexture9** ppVolumeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateVolumeTexture</unmanaged-short>	
        public static void CreateVolumeTexture(SharpDX.Direct3D9.Device deviceRef, int width, int height, int depth, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, out SharpDX.Direct3D9.VolumeTexture volumeTextureOut) {
            unsafe {
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateVolumeTexture_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), width, height, depth, mipLevels, usage, unchecked((int)format), unchecked((int)pool), &volumeTextureOut_);		
                volumeTextureOut= (volumeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VolumeTexture(volumeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateVolumeTexture_(void* arg0,int arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,void* arg8);

        
        /// <summary>	
        /// <p>Loads a volume from a file.</p>	
        /// </summary>	
        /// <param name="destVolumeRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. Specifies the destination volume.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the destination box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the source box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>Combination of one or more <see cref="SharpDX.Direct3D9.Filter"/>, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <param name="srcInfoRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled with a description of the data in the source image file, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.LoadVolumeFromFileW"/>. Otherwise, the function call resolves to D3DXLoadVolumeFromFileA because ANSI strings are being used.</p><p>This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadVolumeFromFileW"/></strong> is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong><see cref="SharpDX.Direct3D9.VolumeTexture.AddDirtyBox"/></strong> on the volume texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadVolumeFromFileW']/*"/>	
        /// <msdn-id>bb172905</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileW([In] IDirect3DVolume9* pDestVolume,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestBox,[In] const wchar_t* pSrcFile,[In] const void* pSrcBox,[In] D3DX_FILTER Filter,[In] int ColorKey,[In] void* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXLoadVolumeFromFileW</unmanaged-short>	
        public static void LoadVolumeFromFileW(SharpDX.Direct3D9.Volume destVolumeRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destBoxRef, string srcFileRef, System.IntPtr srcBoxRef, SharpDX.Direct3D9.Filter filter, int colorKey, System.IntPtr srcInfoRef) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    __result__= 
    				D3DXLoadVolumeFromFileW_((void*)((destVolumeRef == null)?IntPtr.Zero:destVolumeRef.NativePointer), destPaletteRef_, (void*)destBoxRef, (void*)srcFileRef_, (void*)srcBoxRef, unchecked((int)filter), colorKey, (void*)srcInfoRef);		
                Marshal.FreeHGlobal(srcFileRef_ );
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadVolumeFromFileW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,int arg6,void* arg7);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="destSurfaceRef">No documentation.</param>	
        /// <param name="destPaletteRef">No documentation.</param>	
        /// <param name="destRectRef">No documentation.</param>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="srcRectRef">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadSurfaceFromResourceW']/*"/>	
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromResourceW([In] IDirect3DSurface9* pDestSurface,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestRect,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] const void* pSrcRect,[In] D3DX_FILTER Filter,[In] int ColorKey,[In] void* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXLoadSurfaceFromResourceW</unmanaged-short>	
        public static void LoadSurfaceFromResourceW(SharpDX.Direct3D9.Surface destSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destRectRef, System.IntPtr hSrcModule, string srcResourceRef, System.IntPtr srcRectRef, SharpDX.Direct3D9.Filter filter, int colorKey, System.IntPtr srcInfoRef) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    __result__= 
    				D3DXLoadSurfaceFromResourceW_((void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer), destPaletteRef_, (void*)destRectRef, (void*)hSrcModule, (void*)srcResourceRef_, (void*)srcRectRef, unchecked((int)filter), colorKey, (void*)srcInfoRef);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadSurfaceFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,int arg6,int arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates a texture from a file. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileW"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="srcFileRef">No documentation.</param>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="textureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileExW"/>. Otherwise, the function call resolves to D3DXCreateTextureFromFileExA because ANSI strings are being used.</p><p>Use <strong><see cref="SharpDX.Direct3D9.D3DX9.CheckTextureRequirements"/></strong> to determine if your device can support the texture given the current state.</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Mipmapped textures automatically have each level filled with the loaded texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually.</p><p>For the best performance when using <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileExW"/></strong>:</p><ol> <li>Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of 2 dimensions, then create and store images using power of 2 dimensions.</li> <li>For mipmap image creation at load time, filter using <see cref="SharpDX.Direct3D9.Filter.Box"/>. A box filter is much faster than other filter types such as <see cref="SharpDX.Direct3D9.Filter.Triangle"/>.</li> <li>Consider using DDS files. Since DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.</li> </ol><p>When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextureFromFileExW']/*"/>	
        /// <msdn-id>bb172802</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileExW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] void* pSrcInfo,[Out, Buffer] PALETTEENTRY* pPalette,[In] IDirect3DTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextureFromFileExW</unmanaged-short>	
        public static void CreateTextureFromFileExW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, int width, int height, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, System.IntPtr srcInfoRef, SharpDX.Direct3D9.PaletteEntry[] paletteRef, out SharpDX.Direct3D9.Texture textureOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* paletteRef_ = paletteRef)
                    __result__= 
    				D3DXCreateTextureFromFileExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, width, height, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, (void*)srcInfoRef, paletteRef_, &textureOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextureFromFileExW_(void* arg0,void* arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,SharpDX.Mathematics.Interop.RawColorBGRA arg10,void* arg11,void* arg12,void* arg13);

        
        /// <summary>	
        /// <p>Converts a height map into a normal map. The (x,y,z) components of each normal are mapped to the (r,g,b) channels of the output texture.</p>	
        /// </summary>	
        /// <param name="textureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the destination texture.</p> </dd></param>	
        /// <param name="srcTextureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the source height-map texture.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> type that contains the source palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="flags"><dd>  <p>One or more <see cref="SharpDX.Direct3D9.NormalMapFlags"/> flags that control generation of normal maps.</p> </dd></param>	
        /// <param name="channel"><dd>  <p>One <see cref="SharpDX.Direct3D9.Channel"/> flag specifying the source of height information.</p> </dd></param>	
        /// <param name="amplitude"><dd>  <p>Constant value multiplier that increases (or decreases) the values in the normal map. Higher values usually make bumps more visible, lower values usually make bumps less visible.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following value: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This method computes the normal by using the central difference with a kernel size of 3x3. The central differencing denominator used is 2.0. RGB channels in the destination contain biased (x,y,z) components of the normal.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXComputeNormalMap']/*"/>	
        /// <msdn-id>bb172741</msdn-id>	
        /// <unmanaged>HRESULT D3DXComputeNormalMap([In] IDirect3DTexture9* pTexture,[In] IDirect3DTexture9* pSrcTexture,[Out, Buffer] const PALETTEENTRY* pSrcPalette,[In] unsigned int Flags,[In] unsigned int Channel,[In] float Amplitude)</unmanaged>	
        /// <unmanaged-short>D3DXComputeNormalMap</unmanaged-short>	
        public static void ComputeNormalMap(SharpDX.Direct3D9.Texture textureRef, SharpDX.Direct3D9.Texture srcTextureRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, int flags, int channel, float amplitude) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* srcPaletteRef_ = srcPaletteRef)
                    __result__= 
    				D3DXComputeNormalMap_((void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer), (void*)((srcTextureRef == null)?IntPtr.Zero:srcTextureRef.NativePointer), srcPaletteRef_, flags, channel, amplitude);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXComputeNormalMap", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXComputeNormalMap_(void* arg0,void* arg1,void* arg2,int arg3,int arg4,float arg5);

        
        /// <summary>	
        /// <p>Checks volume-texture-creation parameters.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the volume texture.</p> </dd></param>	
        /// <param name="widthRef"><dd>  <p>Pointer to the requested width in pixels, or <strong><c>null</c></strong>. Returns the corrected size.</p> </dd></param>	
        /// <param name="heightRef"><dd>  <p>Pointer to the requested height in pixels, or <strong><c>null</c></strong>. Returns the corrected size.</p> </dd></param>	
        /// <param name="depthRef"><dd>  <p>Pointer to the requested depth in pixels, or <strong><c>null</c></strong>. Returns the corrected size.</p> </dd></param>	
        /// <param name="numMipLevelsRef"><dd>  <p>Pointer to the number of requested mipmap levels, or <strong><c>null</c></strong>. Returns the corrected number of mipmap levels.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>Currently not used, set to 0.</p> </dd></param>	
        /// <param name="formatRef"><dd>  <p>Pointer to a member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or <strong><c>null</c></strong>. Returns the corrected format.</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the volume texture should be placed.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If parameters to this function are invalid, this function returns corrected parameters.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCheckVolumeTextureRequirements']/*"/>	
        /// <msdn-id>bb172718</msdn-id>	
        /// <unmanaged>HRESULT D3DXCheckVolumeTextureRequirements([In] IDirect3DDevice9* pDevice,[InOut] unsigned int* pWidth,[InOut] unsigned int* pHeight,[InOut] unsigned int* pDepth,[InOut] unsigned int* pNumMipLevels,[In] unsigned int Usage,[InOut] D3DFORMAT* pFormat,[In] D3DPOOL Pool)</unmanaged>	
        /// <unmanaged-short>D3DXCheckVolumeTextureRequirements</unmanaged-short>	
        public static void CheckVolumeTextureRequirements(SharpDX.Direct3D9.Device deviceRef, ref int widthRef, ref int heightRef, ref int depthRef, ref int numMipLevelsRef, int usage, ref SharpDX.Direct3D9.Format formatRef, SharpDX.Direct3D9.Pool pool) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* widthRef_ = &widthRef)
                    fixed (void* heightRef_ = &heightRef)
                        fixed (void* depthRef_ = &depthRef)
                            fixed (void* numMipLevelsRef_ = &numMipLevelsRef)
                                fixed (void* formatRef_ = &formatRef)
                                    __result__= 
                    				D3DXCheckVolumeTextureRequirements_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), widthRef_, heightRef_, depthRef_, numMipLevelsRef_, usage, formatRef_, unchecked((int)pool));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckVolumeTextureRequirements", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCheckVolumeTextureRequirements_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,int arg5,void* arg6,int arg7);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="destSurfaceRef">No documentation.</param>	
        /// <param name="destPaletteRef">No documentation.</param>	
        /// <param name="destRectRef">No documentation.</param>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="srcRectRef">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadSurfaceFromFileInMemory']/*"/>	
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromFileInMemory([In] IDirect3DSurface9* pDestSurface,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestRect,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] const void* pSrcRect,[In] D3DX_FILTER Filter,[In] int ColorKey,[In] void* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXLoadSurfaceFromFileInMemory</unmanaged-short>	
        public static void LoadSurfaceFromFileInMemory(SharpDX.Direct3D9.Surface destSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destRectRef, System.IntPtr srcDataRef, int srcDataSize, System.IntPtr srcRectRef, SharpDX.Direct3D9.Filter filter, int colorKey, System.IntPtr srcInfoRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    __result__= 
    				D3DXLoadSurfaceFromFileInMemory_((void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer), destPaletteRef_, (void*)destRectRef, (void*)srcDataRef, srcDataSize, (void*)srcRectRef, unchecked((int)filter), colorKey, (void*)srcInfoRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadSurfaceFromFileInMemory_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,void* arg5,int arg6,int arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates a texture from a file in memory.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p>Pointer to the file in memory from which to create the texture.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Size in bytes of the file in memory.</p> </dd></param>	
        /// <param name="textureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileInMemoryEx"/>(pDevice, pSrcData, SrcDataSize, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppTexture).</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Note that a resource created with this function when called from a <see cref="SharpDX.Direct3D9.Device"/> object will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.  When this method is called from a <see cref="SharpDX.Direct3D9.DeviceEx"/> object the resource will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextureFromFileInMemory']/*"/>	
        /// <msdn-id>bb172803</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemory([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] IDirect3DTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextureFromFileInMemory</unmanaged-short>	
        public static void CreateTextureFromFileInMemory(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataSize, out SharpDX.Direct3D9.Texture textureOut) {
            unsafe {
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTextureFromFileInMemory_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataSize, &textureOut_);		
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextureFromFileInMemory_(void* arg0,void* arg1,int arg2,void* arg3);

        
        /// <summary>	
        /// <p>Creates a cube texture from a resource specified by a string. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromResourceW"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="size">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="cubeTextureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting determines the function version. If Unicode is defined, the function call resolves to <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromResourceExW"/></strong>. Otherwise, the function call resolves to <strong>D3DXCreateCubeTextureFromResourceExA</strong> because ANSI strings are being used.</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Cube textures differ from other surfaces in that they are collections of surfaces. To call <strong>SetRenderTarget</strong> with a cube texture, you must select an individual face using <strong>GetCubeMapSurface</strong> and pass the resulting surface to  <strong>SetRenderTarget</strong>.</p><p><strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromResourceExW"/></strong> uses the DirectDraw surface (DDS) file format. The DirectX Texture Editor (Dxtex.exe) enables you to generate a cube map from other file formats and save it in the DDS file format.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCubeTextureFromResourceExW']/*"/>	
        /// <msdn-id>bb172761</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceExW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] unsigned int Size,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] D3DXIMAGE_INFO* pSrcInfo,[In] PALETTEENTRY* pPalette,[In] IDirect3DCubeTexture9** ppCubeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCubeTextureFromResourceExW</unmanaged-short>	
        public static void CreateCubeTextureFromResourceExW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, int size, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, ref SharpDX.Direct3D9.ImageInformation srcInfoRef, SharpDX.Direct3D9.PaletteEntry paletteRef, out SharpDX.Direct3D9.CubeTexture cubeTextureOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* srcInfoRef_ = &srcInfoRef)
                    __result__= 
    				D3DXCreateCubeTextureFromResourceExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, size, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, srcInfoRef_, &paletteRef, &cubeTextureOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                cubeTextureOut= (cubeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CubeTexture(cubeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCubeTextureFromResourceExW_(void* arg0,void* arg1,void* arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,SharpDX.Mathematics.Interop.RawColorBGRA arg10,void* arg11,void* arg12,void* arg13);

        
        /// <summary>	
        /// <p>Creates a volume texture from a file in memory.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the volume texture.</p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p>Pointer to the file in memory from which to create the volume texture.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Size of the file in memory, in bytes.</p> </dd></param>	
        /// <param name="volumeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface, representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromFileInMemoryEx"/>(pDevice, pSrcFile, SrcData, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppVolumeTexture).</p><p>Note that a resource created with this function when called from a <see cref="SharpDX.Direct3D9.Device"/> object will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.  When this method is called from a <see cref="SharpDX.Direct3D9.DeviceEx"/> object the resource will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateVolumeTextureFromFileInMemory']/*"/>	
        /// <msdn-id>bb172813</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileInMemory([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] IDirect3DVolumeTexture9** ppVolumeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateVolumeTextureFromFileInMemory</unmanaged-short>	
        public static void CreateVolumeTextureFromFileInMemory(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataSize, out SharpDX.Direct3D9.VolumeTexture volumeTextureOut) {
            unsafe {
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateVolumeTextureFromFileInMemory_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataSize, &volumeTextureOut_);		
                volumeTextureOut= (volumeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VolumeTexture(volumeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateVolumeTextureFromFileInMemory_(void* arg0,void* arg1,int arg2,void* arg3);

        
        /// <summary>	
        /// <p>Loads a volume from another volume.</p>	
        /// </summary>	
        /// <param name="destVolumeRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. Specifies the destination volume, which receives the image.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the destination box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="srcVolumeRef"><dd>  <p>A Pointer to an <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. Specifies the source volume.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the source palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the source box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>A combination of one or more <see cref="SharpDX.Direct3D9.Filter"/>, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadVolumeFromVolume"/></strong> is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong><see cref="SharpDX.Direct3D9.VolumeTexture.AddDirtyBox"/></strong> on the surface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadVolumeFromVolume']/*"/>	
        /// <msdn-id>bb172909</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadVolumeFromVolume([In] IDirect3DVolume9* pDestVolume,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestBox,[In] IDirect3DVolume9* pSrcVolume,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcBox,[In] D3DX_FILTER Filter,[In] int ColorKey)</unmanaged>	
        /// <unmanaged-short>D3DXLoadVolumeFromVolume</unmanaged-short>	
        public static void LoadVolumeFromVolume(SharpDX.Direct3D9.Volume destVolumeRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destBoxRef, SharpDX.Direct3D9.Volume srcVolumeRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcBoxRef, SharpDX.Direct3D9.Filter filter, int colorKey) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    fixed (void* srcPaletteRef_ = srcPaletteRef)
                        __result__= 
        				D3DXLoadVolumeFromVolume_((void*)((destVolumeRef == null)?IntPtr.Zero:destVolumeRef.NativePointer), destPaletteRef_, (void*)destBoxRef, (void*)((srcVolumeRef == null)?IntPtr.Zero:srcVolumeRef.NativePointer), srcPaletteRef_, (void*)srcBoxRef, unchecked((int)filter), colorKey);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromVolume", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadVolumeFromVolume_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,int arg6,int arg7);

        
        /// <summary>	
        /// <p>Saves a texture to a file.</p>	
        /// </summary>	
        /// <param name="destFileRef"><dd>  <p>Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="destFormat"><dd>  <p> <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> specifying the file format to use when saving. This function supports saving to all <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga).</p> </dd></param>	
        /// <param name="srcTextureRef"><dd>  <p>Pointer to <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface, containing the texture to be saved.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure containing a palette of 256 colors. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.SaveTextureToFileW"/>. Otherwise, the function call resolves to D3DXSaveTextureToFileA because ANSI strings are being used.</p><p>This function handles conversion to and from compressed texture formats.</p><p>If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to <see cref="SharpDX.Direct3D9.Pool.Default"/>), <strong><see cref="SharpDX.Direct3D9.D3DX9.SaveTextureToFileW"/></strong> will fail because D3DX cannot lock nondynamic volumes located in video memory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveTextureToFileW']/*"/>	
        /// <msdn-id>bb205433</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveTextureToFileW([In] const wchar_t* pDestFile,[In] D3DXIMAGE_FILEFORMAT DestFormat,[In] IDirect3DBaseTexture9* pSrcTexture,[In, Buffer] const PALETTEENTRY* pSrcPalette)</unmanaged>	
        /// <unmanaged-short>D3DXSaveTextureToFileW</unmanaged-short>	
        public static void SaveTextureToFileW(string destFileRef, SharpDX.Direct3D9.ImageFileFormat destFormat, SharpDX.Direct3D9.BaseTexture srcTextureRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef) {
            unsafe {
                IntPtr destFileRef_ = Utilities.StringToHGlobalUni(destFileRef);
                SharpDX.Result __result__;
                fixed (void* srcPaletteRef_ = srcPaletteRef)
                    __result__= 
    				D3DXSaveTextureToFileW_((void*)destFileRef_, unchecked((int)destFormat), (void*)((srcTextureRef == null)?IntPtr.Zero:srcTextureRef.NativePointer), srcPaletteRef_);		
                Marshal.FreeHGlobal(destFileRef_ );
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveTextureToFileW_(void* arg0,int arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Creates a texture from a file.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="cubeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileW"/>. Otherwise, the function call resolves to D3DXCreateTextureFromFileA because ANSI strings are being used.</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileExW"/>(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppTexture).</p><p>Mipmapped textures automatically have each level filled with the loaded texture.</p><p>When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, the images need to be loaded manually.</p><p>Note that a resource created with this function will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p><p>For the best performance when using <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileW"/></strong>:</p><ol> <li>Doing image scaling and format conversion at load time can be slow. Store images in the format and resolution they will be used. If the target hardware requires power of two dimensions, create and store images using power of two dimensions.</li> <li>Consider using DirectDraw surface (DDS) files. Because DDS files can be used to represent any Direct3D 9 texture format, they are very easy for D3DX to read. Also, they can store mipmaps, so any mipmap-generation algorithms can be used to author the images.</li> </ol>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCubeTextureFromFileW']/*"/>	
        /// <msdn-id>bb172801</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In] IDirect3DCubeTexture9** ppCubeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCubeTextureFromFileW</unmanaged-short>	
        public static void CreateCubeTextureFromFileW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, out SharpDX.Direct3D9.CubeTexture cubeTextureOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateCubeTextureFromFileW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, &cubeTextureOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                cubeTextureOut= (cubeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CubeTexture(cubeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCubeTextureFromFileW_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Creates a cube texture from a file in memory. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromFileInMemory"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="size">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="cubeTextureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Cube textures differ from other surfaces in that they are collections of surfaces. To call <strong>SetRenderTarget</strong> with a cube texture, you must select an individual face using <strong>GetCubeMapSurface</strong> and pass the resulting surface to <strong>SetRenderTarget</strong> .</p><p>This method is designed to be used for loading image files stored as RT_RCDATA, which is an application-defined resource (raw data). Otherwise this method will fail.</p><p>For details on <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong>, see the Platform SDK.  Note that as of DirectX 8.0, the peFlags member of the <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure does not function as documented in the Platform SDK. The peFlags  member is now the alpha channel for 8-bit palettized formats.</p><p><strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromFileInMemoryEx"/></strong> uses the DirectDraw surface (DDS) file format. The DirectX Texture Editor (Dxtex.exe) enables you to generate a cube map from other file formats and save it in the DDS file format</p><p>When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCubeTextureFromFileInMemoryEx']/*"/>	
        /// <msdn-id>bb172759</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemoryEx([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] unsigned int Size,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] void* pSrcInfo,[Out, Buffer] PALETTEENTRY* pPalette,[In] IDirect3DCubeTexture9** ppCubeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCubeTextureFromFileInMemoryEx</unmanaged-short>	
        public static void CreateCubeTextureFromFileInMemoryEx(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataSize, int size, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, System.IntPtr srcInfoRef, SharpDX.Direct3D9.PaletteEntry[] paletteRef, out SharpDX.Direct3D9.CubeTexture cubeTextureOut) {
            unsafe {
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* paletteRef_ = paletteRef)
                    __result__= 
    				D3DXCreateCubeTextureFromFileInMemoryEx_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataSize, size, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, (void*)srcInfoRef, paletteRef_, &cubeTextureOut_);		
                cubeTextureOut= (cubeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CubeTexture(cubeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCubeTextureFromFileInMemoryEx_(void* arg0,void* arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,SharpDX.Mathematics.Interop.RawColorBGRA arg10,void* arg11,void* arg12,void* arg13);

        
        /// <summary>	
        /// <p>Creates a texture from a resource. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromResourceW"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="textureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromResourceExW"/>. Otherwise, the function call resolves to D3DXCreateTextureFromResourceExA because ANSI strings are being used.</p><p>The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds).</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextureFromResourceExW']/*"/>	
        /// <msdn-id>bb172806</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceExW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] D3DXIMAGE_INFO* pSrcInfo,[In] PALETTEENTRY* pPalette,[In] IDirect3DTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextureFromResourceExW</unmanaged-short>	
        public static void CreateTextureFromResourceExW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, int width, int height, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, ref SharpDX.Direct3D9.ImageInformation srcInfoRef, SharpDX.Direct3D9.PaletteEntry paletteRef, out SharpDX.Direct3D9.Texture textureOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* srcInfoRef_ = &srcInfoRef)
                    __result__= 
    				D3DXCreateTextureFromResourceExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, width, height, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, srcInfoRef_, &paletteRef, &textureOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextureFromResourceExW_(void* arg0,void* arg1,void* arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,int arg10,SharpDX.Mathematics.Interop.RawColorBGRA arg11,void* arg12,void* arg13,void* arg14);

        
        /// <summary>	
        /// <p>Retrieves information about a given image file.</p>	
        /// </summary>	
        /// <param name="srcFileRef"><dd>  <p>File name of image to retrieve information about. If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled with the description of the data in the source file.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This function supports both Unicode and ANSI strings.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetImageInfoFromFileW']/*"/>	
        /// <msdn-id>bb172867</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetImageInfoFromFileW([In] const wchar_t* pSrcFile,[Out] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXGetImageInfoFromFileW</unmanaged-short>	
        public static SharpDX.Direct3D9.ImageInformation GetImageInfoFromFileW(string srcFileRef) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                SharpDX.Direct3D9.ImageInformation srcInfoRef;
                srcInfoRef = new SharpDX.Direct3D9.ImageInformation();
                SharpDX.Result __result__;
                __result__= 
				D3DXGetImageInfoFromFileW_((void*)srcFileRef_, &srcInfoRef);		
                Marshal.FreeHGlobal(srcFileRef_ );
                __result__.CheckError();
                return srcInfoRef;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetImageInfoFromFileW_(void* arg0,void* arg1);

        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="baseTextureRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="srcLevel">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFilterTexture']/*"/>	
        /// <unmanaged>HRESULT D3DXFilterTexture([In] IDirect3DBaseTexture9* pBaseTexture,[In, Buffer] const PALETTEENTRY* pPalette,[In] unsigned int SrcLevel,[In] D3DX_FILTER Filter)</unmanaged>	
        /// <unmanaged-short>D3DXFilterTexture</unmanaged-short>	
        public static void FilterTexture(SharpDX.Direct3D9.BaseTexture baseTextureRef, SharpDX.Direct3D9.PaletteEntry[] paletteRef, int srcLevel, SharpDX.Direct3D9.Filter filter) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* paletteRef_ = paletteRef)
                    __result__= 
    				D3DXFilterTexture_((void*)((baseTextureRef == null)?IntPtr.Zero:baseTextureRef.NativePointer), paletteRef_, srcLevel, unchecked((int)filter));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFilterTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFilterTexture_(void* arg0,void* arg1,int arg2,int arg3);

        
        /// <summary>	
        /// <p>Loads a surface from memory.</p>	
        /// </summary>	
        /// <param name="destSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Specifies the destination surface, which receives the image.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the destination rectangle. Set this parameter to <strong><c>null</c></strong> to specify the entire surface.</p> </dd></param>	
        /// <param name="srcMemoryRef"><dd>  <p>Pointer to the upper left corner of the source image in memory.</p> </dd></param>	
        /// <param name="srcFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, the pixel format of the source image.</p> </dd></param>	
        /// <param name="srcPitch"><dd>  <p>Pitch of source image, in bytes. For DXT formats, this number should represent the width of one row of cells, in bytes.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the source palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="srcRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the dimensions of the source image in memory. This value cannot be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>Combination of one or more <see cref="SharpDX.Direct3D9.Filter"/> controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>This function handles conversion to and from compressed texture formats.</p><p>Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadSurfaceFromMemory"/></strong> is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong>AddDirtyRect</strong> on the surface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadSurfaceFromMemory']/*"/>	
        /// <msdn-id>bb172902</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromMemory([In] IDirect3DSurface9* pDestSurface,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestRect,[In] const void* pSrcMemory,[In] D3DFORMAT SrcFormat,[In] unsigned int SrcPitch,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcRect,[In] D3DX_FILTER Filter,[In] int ColorKey)</unmanaged>	
        /// <unmanaged-short>D3DXLoadSurfaceFromMemory</unmanaged-short>	
        public static void LoadSurfaceFromMemory(SharpDX.Direct3D9.Surface destSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destRectRef, System.IntPtr srcMemoryRef, SharpDX.Direct3D9.Format srcFormat, int srcPitch, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcRectRef, SharpDX.Direct3D9.Filter filter, int colorKey) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    fixed (void* srcPaletteRef_ = srcPaletteRef)
                        __result__= 
        				D3DXLoadSurfaceFromMemory_((void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer), destPaletteRef_, (void*)destRectRef, (void*)srcMemoryRef, unchecked((int)srcFormat), srcPitch, srcPaletteRef_, (void*)srcRectRef, unchecked((int)filter), colorKey);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadSurfaceFromMemory_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,int arg5,void* arg6,void* arg7,int arg8,int arg9);

        
        /// <summary>	
        /// <p>Saves a texture to an image file.</p>	
        /// </summary>	
        /// <param name="destFormat"><dd>  <p> <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> specifying the file format to use when saving. This function supports saving to all <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga).</p> </dd></param>	
        /// <param name="srcTextureRef"><dd>  <p>Pointer to <strong><see cref="SharpDX.Direct3D9.BaseTexture"/></strong> interface containing the image to be saved.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure containing a palette of 256 colors. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> that will store the image.</p> </dd></returns>	
        /// <remarks>	
        /// <p>This function handles conversion to and from compressed texture formats.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveTextureToFileInMemory']/*"/>	
        /// <msdn-id>bb205434</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveTextureToFileInMemory([Out] ID3DXBuffer** ppDestBuf,[In] D3DXIMAGE_FILEFORMAT DestFormat,[In] IDirect3DBaseTexture9* pSrcTexture,[In, Buffer] const PALETTEENTRY* pSrcPalette)</unmanaged>	
        /// <unmanaged-short>D3DXSaveTextureToFileInMemory</unmanaged-short>	
        public static SharpDX.Direct3D.Blob SaveTextureToFileInMemory(SharpDX.Direct3D9.ImageFileFormat destFormat, SharpDX.Direct3D9.BaseTexture srcTextureRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef) {
            unsafe {
                SharpDX.Direct3D.Blob destBufOut;
                IntPtr destBufOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* srcPaletteRef_ = srcPaletteRef)
                    __result__= 
    				D3DXSaveTextureToFileInMemory_(&destBufOut_, unchecked((int)destFormat), (void*)((srcTextureRef == null)?IntPtr.Zero:srcTextureRef.NativePointer), srcPaletteRef_);		
                destBufOut= (destBufOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(destBufOut_);	
                __result__.CheckError();
                return destBufOut;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveTextureToFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveTextureToFileInMemory_(void* arg0,int arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Checks texture-creation parameters.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="widthRef"><dd>  <p>Pointer to the requested width in pixels, or <strong><c>null</c></strong>. Returns the corrected size.</p> </dd></param>	
        /// <param name="heightRef"><dd>  <p>Pointer to the requested height in pixels, or <strong><c>null</c></strong>. Returns the corrected size.</p> </dd></param>	
        /// <param name="numMipLevelsRef"><dd>  <p>Pointer to number of requested mipmap levels, or <strong><c>null</c></strong>. Returns the corrected number of mipmap levels.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>0 or <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong>. Setting this flag to <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> indicates that the surface is to be used as a render target. The resource can then be passed to the pNewRenderTarget parameter of the <strong>SetRenderTarget</strong> method. If <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong> is specified, the application should check that the device supports this operation by calling <strong>CheckDeviceFormat</strong>.</p> </dd></param>	
        /// <param name="formatRef"><dd>  <p>Pointer to a member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type. Specifies the desired pixel format, or <strong><c>null</c></strong>. Returns the corrected format.</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the texture should be placed.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>.</p></returns>	
        /// <remarks>	
        /// <p>If parameters to this function are invalid, this function returns corrected parameters.</p><p>This function uses the following heuristics when comparing the requested requirements against available formats:</p><ul> <li>Do not choose a format that has fewer channels.</li> <li>Avoid FOURCC And 24-bit formats unless explicitly requested.</li> <li>Try not to add new channels.</li> <li>Try not to change the number of bits per channel.</li> <li>Try to avoid converting between types of formats. For instance, avoid converting an ARGB format to a depth format.</li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCheckTextureRequirements']/*"/>	
        /// <msdn-id>bb172716</msdn-id>	
        /// <unmanaged>HRESULT D3DXCheckTextureRequirements([In] IDirect3DDevice9* pDevice,[InOut] unsigned int* pWidth,[InOut] unsigned int* pHeight,[InOut] unsigned int* pNumMipLevels,[In] unsigned int Usage,[InOut] D3DFORMAT* pFormat,[In] D3DPOOL Pool)</unmanaged>	
        /// <unmanaged-short>D3DXCheckTextureRequirements</unmanaged-short>	
        public static void CheckTextureRequirements(SharpDX.Direct3D9.Device deviceRef, ref int widthRef, ref int heightRef, ref int numMipLevelsRef, int usage, ref SharpDX.Direct3D9.Format formatRef, SharpDX.Direct3D9.Pool pool) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* widthRef_ = &widthRef)
                    fixed (void* heightRef_ = &heightRef)
                        fixed (void* numMipLevelsRef_ = &numMipLevelsRef)
                            fixed (void* formatRef_ = &formatRef)
                                __result__= 
                				D3DXCheckTextureRequirements_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), widthRef_, heightRef_, numMipLevelsRef_, usage, formatRef_, unchecked((int)pool));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCheckTextureRequirements", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCheckTextureRequirements_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,void* arg5,int arg6);

        
        /// <summary>	
        /// <p>Saves a volume to a file on disk.</p>	
        /// </summary>	
        /// <param name="destFileRef"><dd>  <p>Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="destFormat"><dd>  <p> <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> specifying the file format to use when saving. This function supports saving to all <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga).</p> </dd></param>	
        /// <param name="srcVolumeRef"><dd>  <p>Pointer to <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface containing the image to be saved.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure containing a palette of 256 colors. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the source box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.SaveVolumeToFileW"/>. Otherwise, the function call resolves to &gt;D3DXSaveVolumeToFileA because ANSI strings are being used.</p><p>This function handles conversion to and from compressed texture formats.</p><p>If the volume is nondynamic (because of a usage parameter set to 0 at the creation) and located in video memory (the memory pool set to <see cref="SharpDX.Direct3D9.Pool.Default"/>), <strong><see cref="SharpDX.Direct3D9.D3DX9.SaveTextureToFileW"/></strong> will fail because D3DX cannot lock nondynamic volumes located in video memory.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveVolumeToFileW']/*"/>	
        /// <msdn-id>bb205435</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileW([In] const wchar_t* pDestFile,[In] D3DXIMAGE_FILEFORMAT DestFormat,[In] IDirect3DVolume9* pSrcVolume,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcBox)</unmanaged>	
        /// <unmanaged-short>D3DXSaveVolumeToFileW</unmanaged-short>	
        public static void SaveVolumeToFileW(string destFileRef, SharpDX.Direct3D9.ImageFileFormat destFormat, SharpDX.Direct3D9.Volume srcVolumeRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcBoxRef) {
            unsafe {
                IntPtr destFileRef_ = Utilities.StringToHGlobalUni(destFileRef);
                SharpDX.Result __result__;
                fixed (void* srcPaletteRef_ = srcPaletteRef)
                    __result__= 
    				D3DXSaveVolumeToFileW_((void*)destFileRef_, unchecked((int)destFormat), (void*)((srcVolumeRef == null)?IntPtr.Zero:srcVolumeRef.NativePointer), srcPaletteRef_, (void*)srcBoxRef);		
                Marshal.FreeHGlobal(destFileRef_ );
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveVolumeToFileW_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Loads a volume from a resource.</p>	
        /// </summary>	
        /// <param name="destVolumeRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. Specifies the destination volume.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the destination box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="hSrcModule"><dd>  <p>Handle to the module where the resource is located, or <strong><c>null</c></strong> for module associated with the image the operating system used to create the current process.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Pointer to a string that specifies the file name of the source image.  If UNICODE or _UNICODE are defined, this parameter type is LPCWSTR, otherwise, the type is LPCSTR.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the source box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>Combination of one or more <see cref="SharpDX.Direct3D9.Filter"/>, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <param name="srcInfoRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled with a description of the data in the source image file, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>The resource being loaded must be a bitmap resource(RT_BITMAP).</p><p>This function handles conversion to and from compressed texture formats.</p><p>Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadVolumeFromFileW"/></strong> is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong><see cref="SharpDX.Direct3D9.VolumeTexture.AddDirtyBox"/></strong> on the volume texture.</p><p>This function supports both Unicode and ANSI strings.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadVolumeFromResourceW']/*"/>	
        /// <msdn-id>bb172908</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadVolumeFromResourceW([In] IDirect3DVolume9* pDestVolume,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestBox,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] const void* pSrcBox,[In] D3DX_FILTER Filter,[In] int ColorKey,[In] void* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXLoadVolumeFromResourceW</unmanaged-short>	
        public static void LoadVolumeFromResourceW(SharpDX.Direct3D9.Volume destVolumeRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destBoxRef, System.IntPtr hSrcModule, string srcResourceRef, System.IntPtr srcBoxRef, SharpDX.Direct3D9.Filter filter, int colorKey, System.IntPtr srcInfoRef) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    __result__= 
    				D3DXLoadVolumeFromResourceW_((void*)((destVolumeRef == null)?IntPtr.Zero:destVolumeRef.NativePointer), destPaletteRef_, (void*)destBoxRef, (void*)hSrcModule, (void*)srcResourceRef_, (void*)srcBoxRef, unchecked((int)filter), colorKey, (void*)srcInfoRef);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadVolumeFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,int arg6,int arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates a volume texture from a resource specified by a string. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromResourceW"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="hSrcModule">No documentation.</param>	
        /// <param name="srcResourceRef">No documentation.</param>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="depth">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="volumeTextureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromResourceExW"/>. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceExA because ANSI strings are being used.</p><p>The resource being loaded must be an application-defined resource (RT_RCDATA).</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateVolumeTextureFromResourceExW']/*"/>	
        /// <msdn-id>bb172816</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceExW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int Depth,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] D3DXIMAGE_INFO* pSrcInfo,[In] PALETTEENTRY* pPalette,[In] IDirect3DVolumeTexture9** ppVolumeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateVolumeTextureFromResourceExW</unmanaged-short>	
        public static void CreateVolumeTextureFromResourceExW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, int width, int height, int depth, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, ref SharpDX.Direct3D9.ImageInformation srcInfoRef, SharpDX.Direct3D9.PaletteEntry paletteRef, out SharpDX.Direct3D9.VolumeTexture volumeTextureOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* srcInfoRef_ = &srcInfoRef)
                    __result__= 
    				D3DXCreateVolumeTextureFromResourceExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, width, height, depth, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, srcInfoRef_, &paletteRef, &volumeTextureOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                volumeTextureOut= (volumeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VolumeTexture(volumeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateVolumeTextureFromResourceExW_(void* arg0,void* arg1,void* arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,int arg10,int arg11,SharpDX.Mathematics.Interop.RawColorBGRA arg12,void* arg13,void* arg14,void* arg15);

        
        /// <summary>	
        /// <p>Creates a cube texture from a resource.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the cube texture.</p> </dd></param>	
        /// <param name="hSrcModule"><dd>  <p>Handle to the module where the resource is located, or <strong><c>null</c></strong> for the module associated with the image the operating system used to create the current process.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="cubeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface, representing the created cube texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting determines the function version. If Unicode is defined, the function call resolves to <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromResourceW"/></strong>. Otherwise, the function call resolves to <strong>D3DXCreateCubeTextureFromResourceA</strong> because ANSI strings are being used.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromResourceExW"/>(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppCubeTexture).</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Note that a resource created with this function when called from a <see cref="SharpDX.Direct3D9.Device"/> object will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.  When this method is called from a <see cref="SharpDX.Direct3D9.DeviceEx"/> object the resource will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p><p><strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromResourceW"/></strong> uses the DirectDraw surface (DDS) file format. The DirectX Texture Editor (Dxtex.exe) enables you to generate a cube map from other file formats and save it in the DDS file format.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCubeTextureFromResourceW']/*"/>	
        /// <msdn-id>bb172760</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromResourceW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] IDirect3DCubeTexture9** ppCubeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCubeTextureFromResourceW</unmanaged-short>	
        public static void CreateCubeTextureFromResourceW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, out SharpDX.Direct3D9.CubeTexture cubeTextureOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateCubeTextureFromResourceW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, &cubeTextureOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                cubeTextureOut= (cubeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CubeTexture(cubeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCubeTextureFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Saves a surface to a file.</p>	
        /// </summary>	
        /// <param name="destFileRef"><dd>  <p>Pointer to a string that specifies the file name of the destination image. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="destFormat"><dd>  <p> <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> specifying the file format to use when saving. This function supports saving to all <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga).</p> </dd></param>	
        /// <param name="srcSurfaceRef"><dd>  <p>Pointer to <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, containing the image to be saved.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure containing a palette of 256 colors. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="srcRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the source rectangle. Set this parameter to <strong><c>null</c></strong> to specify the entire image.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.SaveSurfaceToFileW"/>. Otherwise, the function call resolves to D3DXSaveSurfaceToFileA because ANSI strings are being used.</p><p>This function handles conversion to and from compressed texture formats.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveSurfaceToFileW']/*"/>	
        /// <msdn-id>bb205431</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileW([In] const wchar_t* pDestFile,[In] D3DXIMAGE_FILEFORMAT DestFormat,[In] IDirect3DSurface9* pSrcSurface,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcRect)</unmanaged>	
        /// <unmanaged-short>D3DXSaveSurfaceToFileW</unmanaged-short>	
        public static void SaveSurfaceToFileW(string destFileRef, SharpDX.Direct3D9.ImageFileFormat destFormat, SharpDX.Direct3D9.Surface srcSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcRectRef) {
            unsafe {
                IntPtr destFileRef_ = Utilities.StringToHGlobalUni(destFileRef);
                SharpDX.Result __result__;
                fixed (void* srcPaletteRef_ = srcPaletteRef)
                    __result__= 
    				D3DXSaveSurfaceToFileW_((void*)destFileRef_, unchecked((int)destFormat), (void*)((srcSurfaceRef == null)?IntPtr.Zero:srcSurfaceRef.NativePointer), srcPaletteRef_, (void*)srcRectRef);		
                Marshal.FreeHGlobal(destFileRef_ );
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveSurfaceToFileW_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Creates a cube texture from a file in memory.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the cube texture.</p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p>Pointer to the file in memory from which to create the cubemap. See Remarks.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Size of the file in memory, in bytes.</p> </dd></param>	
        /// <param name="cubeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> interface, representing the created cube texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromFileInMemoryEx"/>(pDevice, pSrcData, SrcDataSize, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppCubeTexture).</p><p>Note that a resource created with this function when called from a <see cref="SharpDX.Direct3D9.Device"/> object will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.  When this method is called from a <see cref="SharpDX.Direct3D9.DeviceEx"/> object the resource will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p>This method is designed to be used for loading image files stored as RT_RCDATA, which is an application-defined resource (raw data). Otherwise this method will fail.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p><p><strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromFileInMemory"/></strong> uses the DirectDraw surface (DDS) file format. The DirectX Texture Editor (Dxtex.exe) enables you to generate a cube map from other file formats and save it in the DDS file format.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCubeTextureFromFileInMemory']/*"/>	
        /// <msdn-id>bb172758</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileInMemory([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] IDirect3DCubeTexture9** ppCubeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCubeTextureFromFileInMemory</unmanaged-short>	
        public static void CreateCubeTextureFromFileInMemory(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataSize, out SharpDX.Direct3D9.CubeTexture cubeTextureOut) {
            unsafe {
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateCubeTextureFromFileInMemory_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataSize, &cubeTextureOut_);		
                cubeTextureOut= (cubeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CubeTexture(cubeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCubeTextureFromFileInMemory_(void* arg0,void* arg1,int arg2,void* arg3);

        
        /// <summary>	
        /// <p>Creates a cube texture from a file. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromFileW"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="srcFileRef">No documentation.</param>	
        /// <param name="size">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="cubeTextureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromFileExW"/></strong>. Otherwise, the function call resolves to <strong>D3DXCreateCubeTextureFromFileExA</strong> because ANSI strings are being used.</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Cube textures differ from other surfaces in that they are collections of surfaces. To call <strong>SetRenderTarget</strong> with a cube texture, you must select an individual face using <strong>GetCubeMapSurface</strong> and pass the resulting surface to <strong>SetRenderTarget</strong>.</p><p><strong><see cref="SharpDX.Direct3D9.D3DX9.CreateCubeTextureFromFileExW"/></strong> uses the DirectDraw surface (DDS) file format. The DirectX Texture Editor (Dxtex.exe) enables you to generate a cube map from other file formats and save it in the DDS file format.</p><p>When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateCubeTextureFromFileExW']/*"/>	
        /// <msdn-id>bb172757</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateCubeTextureFromFileExW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In] unsigned int Size,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] void* pSrcInfo,[Out, Buffer] PALETTEENTRY* pPalette,[In] IDirect3DCubeTexture9** ppCubeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateCubeTextureFromFileExW</unmanaged-short>	
        public static void CreateCubeTextureFromFileExW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, int size, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, System.IntPtr srcInfoRef, SharpDX.Direct3D9.PaletteEntry[] paletteRef, out SharpDX.Direct3D9.CubeTexture cubeTextureOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                IntPtr cubeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* paletteRef_ = paletteRef)
                    __result__= 
    				D3DXCreateCubeTextureFromFileExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, size, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, (void*)srcInfoRef, paletteRef_, &cubeTextureOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                cubeTextureOut= (cubeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.CubeTexture(cubeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateCubeTextureFromFileExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateCubeTextureFromFileExW_(void* arg0,void* arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,SharpDX.Mathematics.Interop.RawColorBGRA arg9,void* arg10,void* arg11,void* arg12);

        
        /// <summary>	
        /// <p>Retrieves information about a given image in a resource.</p>	
        /// </summary>	
        /// <param name="hSrcModule"><dd>  <p>Module where the resource is loaded. Set this parameter to <strong><c>null</c></strong> to specify the module associated with the image that the operating system used to create the current process.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <returns><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled with the description of the data in the source file.</p> </dd></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines  the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.GetImageInfoFromResourceW"/>. Otherwise, the function call resolves to D3DXGetImageInfoFromResourceA because ANSI strings are being used.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXGetImageInfoFromResourceW']/*"/>	
        /// <msdn-id>bb172869</msdn-id>	
        /// <unmanaged>HRESULT D3DXGetImageInfoFromResourceW([In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[Out] D3DXIMAGE_INFO* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXGetImageInfoFromResourceW</unmanaged-short>	
        public static SharpDX.Direct3D9.ImageInformation GetImageInfoFromResourceW(System.IntPtr hSrcModule, string srcResourceRef) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                SharpDX.Direct3D9.ImageInformation srcInfoRef;
                srcInfoRef = new SharpDX.Direct3D9.ImageInformation();
                SharpDX.Result __result__;
                __result__= 
				D3DXGetImageInfoFromResourceW_((void*)hSrcModule, (void*)srcResourceRef_, &srcInfoRef);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                __result__.CheckError();
                return srcInfoRef;
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXGetImageInfoFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXGetImageInfoFromResourceW_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Uses a compiled high-level shader language (HLSL) function to fill each texel of each mipmap level of a texture.</p>	
        /// </summary>	
        /// <param name="cubeTextureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.CubeTexture"/></strong> object, representing the texture to be filled.</p> </dd></param>	
        /// <param name="textureShaderRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.TextureShader"/></strong> texture shader object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>The texture target must be an HLSL function that takes contains the following semantics:</p><ul> <li>One input parameter must use a POSITION semantic.</li> <li>One input parameter must use a PSIZE semantic.</li> <li>The function must return a parameter that uses the COLOR semantic.</li> </ul><p>The input parameters can be in any order. For an example, see <strong><see cref="SharpDX.Direct3D9.D3DX9.FillTextureTX"/></strong> </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFillCubeTextureTX']/*"/>	
        /// <msdn-id>bb172832</msdn-id>	
        /// <unmanaged>HRESULT D3DXFillCubeTextureTX([In] IDirect3DCubeTexture9* pCubeTexture,[In] ID3DXTextureShader* pTextureShader)</unmanaged>	
        /// <unmanaged-short>D3DXFillCubeTextureTX</unmanaged-short>	
        public static void FillCubeTextureTX(SharpDX.Direct3D9.CubeTexture cubeTextureRef, SharpDX.Direct3D9.TextureShader textureShaderRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXFillCubeTextureTX_((void*)((cubeTextureRef == null)?IntPtr.Zero:cubeTextureRef.NativePointer), (void*)((textureShaderRef == null)?IntPtr.Zero:textureShaderRef.NativePointer));		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillCubeTextureTX", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFillCubeTextureTX_(void* arg0,void* arg1);

        
        /// <summary>	
        /// <p>Uses a user-provided function to fill each texel of each mip level of a given texture.</p>	
        /// </summary>	
        /// <param name="textureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the filled texture.</p> </dd></param>	
        /// <param name="functionRef"><dd>  <p>Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of LPD3DXFILL2D.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to an arbitrary block of user-defined data. This reference will be passed to the function provided in <em>pFunction</em>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>Here is an example that creates a function called ColorFill, which relies on <see cref="SharpDX.Direct3D9.D3DX9.FillTexture"/>.</p><pre> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorFill (<see cref="SharpDX.Mathematics.Interop.RawVector4"/>* pOut, const <see cref="SharpDX.Mathematics.Interop.RawVector2"/>* pTexCoord, 	
        /// const <see cref="SharpDX.Mathematics.Interop.RawVector2"/>* pTexelSize, LPVOID pData)	
        /// { *pOut = <see cref="SharpDX.Mathematics.Interop.RawVector4"/>(pTexCoord-&gt;x, pTexCoord-&gt;y, 0.0f, 0.0f);	
        /// } // Fill the texture using <see cref="SharpDX.Direct3D9.D3DX9.FillTexture"/>	
        /// if (FAILED (hr = <see cref="SharpDX.Direct3D9.D3DX9.FillTexture"/> (m_pTexture, ColorFill, <c>null</c>)))	
        /// { return hr;	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFillTexture']/*"/>	
        /// <msdn-id>bb172833</msdn-id>	
        /// <unmanaged>HRESULT D3DXFillTexture([In] IDirect3DTexture9* pTexture,[In] __function__stdcall* pFunction,[In] void* pData)</unmanaged>	
        /// <unmanaged-short>D3DXFillTexture</unmanaged-short>	
        public static void FillTexture(SharpDX.Direct3D9.Texture textureRef, SharpDX.FunctionCallback functionRef, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXFillTexture_((void*)((textureRef == null)?IntPtr.Zero:textureRef.NativePointer), functionRef, (void*)dataRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFillTexture_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Saves a surface to an image file.</p>	
        /// </summary>	
        /// <param name="destBufOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> that will store the image.</p> </dd></param>	
        /// <param name="destFormat"><dd>  <p> <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> specifying the file format to use when saving. This function supports saving to all <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong> formats except Portable Pixmap (.ppm) and Targa/Truevision Graphics Adapter (.tga).</p> </dd></param>	
        /// <param name="srcSurfaceRef"><dd>  <p>Pointer to <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface containing the image to be saved.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure containing a palette of 256 colors. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="srcRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the source rectangle. Set this parameter to <strong><c>null</c></strong> to specify the entire image.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>This function handles conversion to and from compressed texture formats.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveSurfaceToFileInMemory']/*"/>	
        /// <msdn-id>bb205432</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveSurfaceToFileInMemory([In] ID3DXBuffer** ppDestBuf,[In] D3DXIMAGE_FILEFORMAT DestFormat,[In] IDirect3DSurface9* pSrcSurface,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcRect)</unmanaged>	
        /// <unmanaged-short>D3DXSaveSurfaceToFileInMemory</unmanaged-short>	
        public static void SaveSurfaceToFileInMemory(out SharpDX.Direct3D.Blob destBufOut, SharpDX.Direct3D9.ImageFileFormat destFormat, SharpDX.Direct3D9.Surface srcSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcRectRef) {
            unsafe {
                IntPtr destBufOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* srcPaletteRef_ = srcPaletteRef)
                    __result__= 
    				D3DXSaveSurfaceToFileInMemory_(&destBufOut_, unchecked((int)destFormat), (void*)((srcSurfaceRef == null)?IntPtr.Zero:srcSurfaceRef.NativePointer), srcPaletteRef_, (void*)srcRectRef);		
                destBufOut= (destBufOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(destBufOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveSurfaceToFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveSurfaceToFileInMemory_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Creates a volume texture from a file.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the volume texture.</p> </dd></param>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to a string that specifies the file name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="volumeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromFileW"/>. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileA because ANSI strings are being used.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromFileExW"/>(pDevice, pSrcFile, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppVolumeTexture).</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Mipmapped textures automatically have each level filled with the loaded texture.</p><p>When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually.</p><p>Note that a resource created with this function when called from a <see cref="SharpDX.Direct3D9.Device"/> object will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.  When this method is called from a <see cref="SharpDX.Direct3D9.DeviceEx"/> object the resource will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateVolumeTextureFromFileW']/*"/>	
        /// <msdn-id>bb172811</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In] IDirect3DVolumeTexture9** ppVolumeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateVolumeTextureFromFileW</unmanaged-short>	
        public static void CreateVolumeTextureFromFileW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, out SharpDX.Direct3D9.VolumeTexture volumeTextureOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateVolumeTextureFromFileW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, &volumeTextureOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                volumeTextureOut= (volumeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VolumeTexture(volumeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateVolumeTextureFromFileW_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Creates a texture from a resource.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="hSrcModule"><dd>  <p>Handle to the module where the resource is located, or <strong><c>null</c></strong> for module associated with the image the operating system used to create the current process.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="textureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromResourceW"/>. Otherwise, the function call resolves to D3DXCreateTextureFromResourceA because ANSI strings are being used.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromResourceExW"/>(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppTexture).</p><p>The resource being loaded must be of type RT_BITMAP or RT_RCDATA. Resource type RT_RCDATA is used to load formats other than bitmaps (such as .tga, .jpg, and .dds).</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Note that a resource created with this function when called from a <see cref="SharpDX.Direct3D9.Device"/> object will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.  When this method is called from a <see cref="SharpDX.Direct3D9.DeviceEx"/> object the resource will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextureFromResourceW']/*"/>	
        /// <msdn-id>bb172805</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextureFromResourceW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] IDirect3DTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextureFromResourceW</unmanaged-short>	
        public static void CreateTextureFromResourceW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, out SharpDX.Direct3D9.Texture textureOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTextureFromResourceW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, &textureOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextureFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Loads a volume from memory.</p>	
        /// </summary>	
        /// <param name="destVolumeRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. Specifies the destination volume, which receives the image.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a  <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the destination box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="srcMemoryRef"><dd>  <p>Pointer to the top-left corner of the source volume in memory.</p> </dd></param>	
        /// <param name="srcFormat"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, the pixel format of the source volume.</p> </dd></param>	
        /// <param name="srcRowPitch"><dd>  <p>Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one row of cells, in bytes.</p> </dd></param>	
        /// <param name="srcSlicePitch"><dd>  <p>Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one slice of cells, in bytes.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the source palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the source box. <strong><c>null</c></strong> is not a valid value for this parameter.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>A combination of one or more <see cref="SharpDX.Direct3D9.Filter"/> controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadVolumeFromMemory"/></strong> is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong><see cref="SharpDX.Direct3D9.VolumeTexture.AddDirtyBox"/></strong> on the volume texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadVolumeFromMemory']/*"/>	
        /// <msdn-id>bb172907</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadVolumeFromMemory([In] IDirect3DVolume9* pDestVolume,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestBox,[In] const void* pSrcMemory,[In] D3DFORMAT SrcFormat,[In] unsigned int SrcRowPitch,[In] unsigned int SrcSlicePitch,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcBox,[In] D3DX_FILTER Filter,[In] int ColorKey)</unmanaged>	
        /// <unmanaged-short>D3DXLoadVolumeFromMemory</unmanaged-short>	
        public static void LoadVolumeFromMemory(SharpDX.Direct3D9.Volume destVolumeRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destBoxRef, System.IntPtr srcMemoryRef, SharpDX.Direct3D9.Format srcFormat, int srcRowPitch, int srcSlicePitch, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcBoxRef, SharpDX.Direct3D9.Filter filter, int colorKey) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    fixed (void* srcPaletteRef_ = srcPaletteRef)
                        __result__= 
        				D3DXLoadVolumeFromMemory_((void*)((destVolumeRef == null)?IntPtr.Zero:destVolumeRef.NativePointer), destPaletteRef_, (void*)destBoxRef, (void*)srcMemoryRef, unchecked((int)srcFormat), srcRowPitch, srcSlicePitch, srcPaletteRef_, (void*)srcBoxRef, unchecked((int)filter), colorKey);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadVolumeFromMemory_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,int arg5,int arg6,void* arg7,void* arg8,int arg9,int arg10);

        
        /// <summary>	
        /// <p>Creates a volume texture from a file.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="srcFileRef"><dd>  <p>Pointer to a string that specifies the filename. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="width"><dd>  <p>Width in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="depth"><dd>  <p>Depth, in pixels. If this value is zero or D3DX_DEFAULT, the dimensions are taken from the file. The maximum dimension that a driver supports (for width, height, and depth) can be found in MaxVolumeExtent in <strong><see cref="SharpDX.Direct3D9.Capabilities"/></strong>.</p> </dd></param>	
        /// <param name="mipLevels"><dd>  <p>Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>0, <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/>, or <see cref="SharpDX.Direct3D9.Usage.Dynamic"/>. Setting this flag to <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> indicates that the surface is to be used as a render target. The resource can then be passed to the  <em>pNewRenderTarget</em> parameter of the <strong>SetRenderTarget</strong> method. If either <see cref="SharpDX.Direct3D9.Usage.RenderTarget"/> or <see cref="SharpDX.Direct3D9.Usage.Dynamic"/> is specified,  <em>Pool</em> must be set to <see cref="SharpDX.Direct3D9.Pool.Default"/>, and the application should check that the device supports this operation by calling <strong>CheckDeviceFormat</strong>. <see cref="SharpDX.Direct3D9.Usage.Dynamic"/> indicates that the surface should be handled dynamically. For more information about using dynamic textures, see Using Dynamic Textures.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture might have a different format from that specified by <em>Format</em>. Applications should check the format of the returned texture. If <see cref="SharpDX.Direct3D9.Format.Unknown"/>, the format is taken from the file. If D3DFMT_FROM_FILE, the format is taken exactly as it is in the file, and the call will fail if this violates device capabilities.</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the texture should be placed.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>A combination of one or more <see cref="SharpDX.Direct3D9.Filter"/> controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="mipFilter"><dd>  <p>A combination of one or more <see cref="SharpDX.Direct3D9.Filter"/> controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Box"/>. In addition, use bits 27-31 to specify the number of mip levels to be skipped (from the top of the mipmap chain) when a .dds texture is loaded into memory; this allows you to skip up to 32 levels.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <param name="srcInfoRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled in with a description of the data in the source image file, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="paletteRef"><dd>  <p>Pointer to a  <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, representing a 256-color palette to fill in, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="volumeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface, representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromFileExW"/>. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromFileExA because ANSI strings are being used.</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Mipmapped textures automatically have each level filled with the loaded volume texture. When loading images into mipmapped textures, some devices are unable to go to a 1x1 image and this function will fail. If this happens, then the images need to be loaded manually.</p><p>When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the <em>MipFilter</em> value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the <em>MipFilter</em> parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateVolumeTextureFromFileExW']/*"/>	
        /// <msdn-id>bb172812</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromFileExW([In] IDirect3DDevice9* pDevice,[In] const wchar_t* pSrcFile,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int Depth,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] void* pSrcInfo,[Out, Buffer] PALETTEENTRY* pPalette,[In] IDirect3DVolumeTexture9** ppVolumeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateVolumeTextureFromFileExW</unmanaged-short>	
        public static void CreateVolumeTextureFromFileExW(SharpDX.Direct3D9.Device deviceRef, string srcFileRef, int width, int height, int depth, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, System.IntPtr srcInfoRef, SharpDX.Direct3D9.PaletteEntry[] paletteRef, out SharpDX.Direct3D9.VolumeTexture volumeTextureOut) {
            unsafe {
                IntPtr srcFileRef_ = Utilities.StringToHGlobalUni(srcFileRef);
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* paletteRef_ = paletteRef)
                    __result__= 
    				D3DXCreateVolumeTextureFromFileExW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcFileRef_, width, height, depth, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, (void*)srcInfoRef, paletteRef_, &volumeTextureOut_);		
                Marshal.FreeHGlobal(srcFileRef_ );
                volumeTextureOut= (volumeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VolumeTexture(volumeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromFileExW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateVolumeTextureFromFileExW_(void* arg0,void* arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,int arg10,SharpDX.Mathematics.Interop.RawColorBGRA arg11,void* arg12,void* arg13,void* arg14);

        
        /// <summary>	
        /// <p>Creates a texture from a file in memory. This is a more advanced function than <strong><see cref="SharpDX.Direct3D9.D3DX9.CreateTextureFromFileInMemory"/></strong>.</p>	
        /// </summary>	
        /// <param name="deviceRef">No documentation.</param>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcDataSize">No documentation.</param>	
        /// <param name="width">No documentation.</param>	
        /// <param name="height">No documentation.</param>	
        /// <param name="mipLevels">No documentation.</param>	
        /// <param name="usage">No documentation.</param>	
        /// <param name="format">No documentation.</param>	
        /// <param name="pool">No documentation.</param>	
        /// <param name="filter">No documentation.</param>	
        /// <param name="mipFilter">No documentation.</param>	
        /// <param name="colorKey">No documentation.</param>	
        /// <param name="srcInfoRef">No documentation.</param>	
        /// <param name="paletteRef">No documentation.</param>	
        /// <param name="textureOut">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>For details about  <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong>, see the Platform SDK. Note that as of DirectX 8.0, the peFlags member of the <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure does not function as documented in the Platform SDK. The peFlags member is now the alpha channel for 8-bit palettized formats.</p><p>When skipping mipmap levels while loading a .dds file, use the D3DX_SKIP_DDS_MIP_LEVELS macro to generate the MipFilter value. This macro takes the number of levels to skip and the filter type and returns the filter value, which would then be passed into the MipFilter parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTextureFromFileInMemoryEx']/*"/>	
        /// <msdn-id>bb172804</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTextureFromFileInMemoryEx([In] IDirect3DDevice9* pDevice,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] unsigned int Filter,[In] unsigned int MipFilter,[In] D3DCOLOR ColorKey,[In] void* pSrcInfo,[Out, Buffer] PALETTEENTRY* pPalette,[In] IDirect3DTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTextureFromFileInMemoryEx</unmanaged-short>	
        public static void CreateTextureFromFileInMemoryEx(SharpDX.Direct3D9.Device deviceRef, System.IntPtr srcDataRef, int srcDataSize, int width, int height, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, int filter, int mipFilter, SharpDX.Mathematics.Interop.RawColorBGRA colorKey, System.IntPtr srcInfoRef, SharpDX.Direct3D9.PaletteEntry[] paletteRef, out SharpDX.Direct3D9.Texture textureOut) {
            unsafe {
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* paletteRef_ = paletteRef)
                    __result__= 
    				D3DXCreateTextureFromFileInMemoryEx_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)srcDataRef, srcDataSize, width, height, mipLevels, usage, unchecked((int)format), unchecked((int)pool), filter, mipFilter, colorKey, (void*)srcInfoRef, paletteRef_, &textureOut_);		
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTextureFromFileInMemoryEx", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTextureFromFileInMemoryEx_(void* arg0,void* arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,int arg10,SharpDX.Mathematics.Interop.RawColorBGRA arg11,void* arg12,void* arg13,void* arg14);

        
        /// <summary>	
        /// <p>Saves a volume to a buffer. The method creates an <strong><see cref="SharpDX.Direct3D.Blob"/></strong> buffer to store the data, and returns that object.</p>	
        /// </summary>	
        /// <param name="destBufOut">No documentation.</param>	
        /// <param name="destFormat">No documentation.</param>	
        /// <param name="srcVolumeRef">No documentation.</param>	
        /// <param name="srcPaletteRef">No documentation.</param>	
        /// <param name="srcBoxRef">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/></p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXSaveVolumeToFileInMemory']/*"/>	
        /// <msdn-id>bb205436</msdn-id>	
        /// <unmanaged>HRESULT D3DXSaveVolumeToFileInMemory([In] ID3DXBuffer** ppDestBuf,[In] D3DXIMAGE_FILEFORMAT DestFormat,[In] IDirect3DVolume9* pSrcVolume,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcBox)</unmanaged>	
        /// <unmanaged-short>D3DXSaveVolumeToFileInMemory</unmanaged-short>	
        public static void SaveVolumeToFileInMemory(out SharpDX.Direct3D.Blob destBufOut, SharpDX.Direct3D9.ImageFileFormat destFormat, SharpDX.Direct3D9.Volume srcVolumeRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcBoxRef) {
            unsafe {
                IntPtr destBufOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* srcPaletteRef_ = srcPaletteRef)
                    __result__= 
    				D3DXSaveVolumeToFileInMemory_(&destBufOut_, unchecked((int)destFormat), (void*)((srcVolumeRef == null)?IntPtr.Zero:srcVolumeRef.NativePointer), srcPaletteRef_, (void*)srcBoxRef);		
                destBufOut= (destBufOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D.Blob(destBufOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXSaveVolumeToFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXSaveVolumeToFileInMemory_(void* arg0,int arg1,void* arg2,void* arg3,void* arg4);

        
        /// <summary>	
        /// <p>Creates a volume texture from a resource.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the volume texture.</p> </dd></param>	
        /// <param name="hSrcModule"><dd>  <p>Handle to the module where the resource is located, or <strong><c>null</c></strong> for the module associated with the image the operating system used to create the current process.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Pointer to a string that specifies the resource name. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR. Otherwise, the string data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="volumeTextureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromResourceW"/>. Otherwise, the function call resolves to D3DXCreateVolumeTextureFromResourceA because ANSI strings are being used.</p><p>The function is equivalent to <see cref="SharpDX.Direct3D9.D3DX9.CreateVolumeTextureFromResourceExW"/>(pDevice, hSrcModule, pSrcResource, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, <see cref="SharpDX.Direct3D9.Format.Unknown"/>, <see cref="SharpDX.Direct3D9.Pool.Managed"/>, D3DX_DEFAULT, D3DX_DEFAULT, 0, <strong><c>null</c></strong>, <strong><c>null</c></strong>, ppVolumeTexture).</p><p>The resource being loaded must be an application-defined resource (RT_RCDATA).</p><p>This function supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Note that a resource created with this function when called from a <see cref="SharpDX.Direct3D9.Device"/> object will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Managed"/>.  When this method is called from a <see cref="SharpDX.Direct3D9.DeviceEx"/> object the resource will be placed in the memory class denoted by <see cref="SharpDX.Direct3D9.Pool.Default"/>.</p><p>Filtering is automatically applied to a texture created using this method. The filtering is equivalent to <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/> in <see cref="SharpDX.Direct3D9.Filter"/>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateVolumeTextureFromResourceW']/*"/>	
        /// <msdn-id>bb172815</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateVolumeTextureFromResourceW([In] IDirect3DDevice9* pDevice,[In] HINSTANCE hSrcModule,[In] const wchar_t* pSrcResource,[In] IDirect3DVolumeTexture9** ppVolumeTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateVolumeTextureFromResourceW</unmanaged-short>	
        public static void CreateVolumeTextureFromResourceW(SharpDX.Direct3D9.Device deviceRef, System.IntPtr hSrcModule, string srcResourceRef, out SharpDX.Direct3D9.VolumeTexture volumeTextureOut) {
            unsafe {
                IntPtr srcResourceRef_ = Utilities.StringToHGlobalUni(srcResourceRef);
                IntPtr volumeTextureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateVolumeTextureFromResourceW_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), (void*)hSrcModule, (void*)srcResourceRef_, &volumeTextureOut_);		
                Marshal.FreeHGlobal(srcResourceRef_ );
                volumeTextureOut= (volumeTextureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.VolumeTexture(volumeTextureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateVolumeTextureFromResourceW", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateVolumeTextureFromResourceW_(void* arg0,void* arg1,void* arg2,void* arg3);

        
        /// <summary>	
        /// <p>Creates an empty texture, adjusting the calling parameters as needed.</p>	
        /// </summary>	
        /// <param name="deviceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Device"/></strong> interface, representing the device to be associated with the texture.</p> </dd></param>	
        /// <param name="width"><dd>  <p>Width in pixels. If this value is 0, a value of 1 is used. See Remarks.</p> </dd></param>	
        /// <param name="height"><dd>  <p>Height in pixels. If this value is 0, a value of 1 is used. See Remarks.</p> </dd></param>	
        /// <param name="mipLevels"><dd>  <p>Number of mip levels requested. If this value is zero or D3DX_DEFAULT, a complete mipmap chain is created.</p> </dd></param>	
        /// <param name="usage"><dd>  <p>0, <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong>, or <strong><see cref="SharpDX.Direct3D9.Usage.Dynamic"/></strong>. Setting this flag to <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong> indicates that the surface is to be used as a render target by calling the <strong>SetRenderTarget</strong> method. If either <strong><see cref="SharpDX.Direct3D9.Usage.RenderTarget"/></strong> or <strong><see cref="SharpDX.Direct3D9.Usage.Dynamic"/></strong> is specified, the application should check that the device supports this operation by calling <strong>CheckDeviceFormat</strong>. For more information about using dynamic textures, see Using Dynamic Textures.</p> </dd></param>	
        /// <param name="format"><dd>  <p>Member of the <see cref="SharpDX.Direct3D9.Format"/> enumerated type, describing the requested pixel format for the texture. The returned texture may be of a different format from that specified, if the device does not support the requested format. Applications should check the format of the returned texture to see if it matches the format requested.</p> </dd></param>	
        /// <param name="pool"><dd>  <p>Member of the <strong><see cref="SharpDX.Direct3D9.Pool"/></strong> enumerated type, describing the memory class into which the texture should be placed.</p> </dd></param>	
        /// <param name="textureOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D9.Texture"/></strong> interface, representing the created texture object.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, <see cref="SharpDX.Direct3D9.ResultCode.NotAvailable"/>, <see cref="SharpDX.Direct3D9.ResultCode.OutOfVideoMemory"/>, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>Internally, <see cref="SharpDX.Direct3D9.D3DX9.CreateTexture"/> uses <strong><see cref="SharpDX.Direct3D9.D3DX9.CheckTextureRequirements"/></strong> to adjust the calling parameters. Therefore, calls to <see cref="SharpDX.Direct3D9.D3DX9.CreateTexture"/> will often succeed where calls to <strong>CreateTexture</strong> would fail.</p><p>If both Height and Width are set to D3DX_DEFAULT, a value of 256 is used for both parameters. If either Height or Width is set to D3DX_DEFAULT And the other parameter is set to a numeric value, the texture will be square with both the height and width equal to the numeric value.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXCreateTexture']/*"/>	
        /// <msdn-id>bb172800</msdn-id>	
        /// <unmanaged>HRESULT D3DXCreateTexture([In] IDirect3DDevice9* pDevice,[In] unsigned int Width,[In] unsigned int Height,[In] unsigned int MipLevels,[In] unsigned int Usage,[In] D3DFORMAT Format,[In] D3DPOOL Pool,[In] IDirect3DTexture9** ppTexture)</unmanaged>	
        /// <unmanaged-short>D3DXCreateTexture</unmanaged-short>	
        public static void CreateTexture(SharpDX.Direct3D9.Device deviceRef, int width, int height, int mipLevels, int usage, SharpDX.Direct3D9.Format format, SharpDX.Direct3D9.Pool pool, out SharpDX.Direct3D9.Texture textureOut) {
            unsafe {
                IntPtr textureOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXCreateTexture_((void*)((deviceRef == null)?IntPtr.Zero:deviceRef.NativePointer), width, height, mipLevels, usage, unchecked((int)format), unchecked((int)pool), &textureOut_);		
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.Texture(textureOut_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXCreateTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXCreateTexture_(void* arg0,int arg1,int arg2,int arg3,int arg4,int arg5,int arg6,void* arg7);

        
        /// <summary>	
        /// <p>Uses a user-provided function to fill each texel of each mip level of a given volume texture.</p>	
        /// </summary>	
        /// <param name="volumeTextureRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.VolumeTexture"/></strong> interface, representing the filled texture.</p> </dd></param>	
        /// <param name="functionRef"><dd>  <p>Pointer to a user-provided evaluator function, which will be used to compute the value of each texel. The function follows the prototype of LPD3DXFILL3D.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to an arbitrary block of user-defined data. This reference will be passed to the function provided in <em>pFunction</em>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following values: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>.</p></returns>	
        /// <remarks>	
        /// <p>If the volume is non-dynamic (because usage is set to 0 when it is  created), and located in video memory (the memory pool set to <see cref="SharpDX.Direct3D9.Pool.Default"/>), <strong><see cref="SharpDX.Direct3D9.D3DX9.FillVolumeTexture"/></strong> will fail because the volume cannot be locked.</p><p>This example creates a function called ColorVolumeFill, which relies on <see cref="SharpDX.Direct3D9.D3DX9.FillVolumeTexture"/>.</p><pre> // Define a function that matches the prototype of LPD3DXFILL3D	
        /// VOID WINAPI ColorVolumeFill (<see cref="SharpDX.Mathematics.Interop.RawVector4"/>* pOut, const <see cref="SharpDX.Mathematics.Interop.RawVector3"/>* pTexCoord, 	
        /// const <see cref="SharpDX.Mathematics.Interop.RawVector3"/>* pTexelSize, LPVOID pData)	
        /// { *pOut = <see cref="SharpDX.Mathematics.Interop.RawVector4"/>(pTexCoord-&gt;x, pTexCoord-&gt;y, pTexCoord-&gt;z, 0.0f);	
        /// } // Fill volume texture	
        /// if (FAILED (hr = <see cref="SharpDX.Direct3D9.D3DX9.FillVolumeTexture"/> (m_pTexture, ColorVolumeFill, <c>null</c>)))	
        /// { return hr;	
        /// }	
        /// </pre>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFillVolumeTexture']/*"/>	
        /// <msdn-id>bb172835</msdn-id>	
        /// <unmanaged>HRESULT D3DXFillVolumeTexture([In] IDirect3DVolumeTexture9* pVolumeTexture,[In] __function__stdcall* pFunction,[In] void* pData)</unmanaged>	
        /// <unmanaged-short>D3DXFillVolumeTexture</unmanaged-short>	
        public static void FillVolumeTexture(SharpDX.Direct3D9.VolumeTexture volumeTextureRef, SharpDX.FunctionCallback functionRef, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				D3DXFillVolumeTexture_((void*)((volumeTextureRef == null)?IntPtr.Zero:volumeTextureRef.NativePointer), functionRef, (void*)dataRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFillVolumeTexture", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFillVolumeTexture_(void* arg0,void* arg1,void* arg2);

        
        /// <summary>	
        /// <p>Loads a surface from another surface with color conversion.</p>	
        /// </summary>	
        /// <param name="destSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface. Specifies the destination surface, which receives the image.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the destination rectangle. Set this parameter to <strong><c>null</c></strong> to specify the entire surface.</p> </dd></param>	
        /// <param name="srcSurfaceRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Surface"/></strong> interface, representing the source surface.</p> </dd></param>	
        /// <param name="srcPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the source palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="srcRectRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure. Specifies the source rectangle. Set this parameter to <strong><c>null</c></strong> to specify the entire surface.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>A combination of one or more <see cref="SharpDX.Direct3D9.Filter"/>, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>This function handles conversion to and from compressed texture formats.</p><p>Writing to a non-level-zero surface will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadSurfaceFromSurface"/></strong> is called and the surface was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong>AddDirtyRect</strong> on the surface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadSurfaceFromSurface']/*"/>	
        /// <msdn-id>bb172904</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadSurfaceFromSurface([In] IDirect3DSurface9* pDestSurface,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestRect,[In] IDirect3DSurface9* pSrcSurface,[In, Buffer] const PALETTEENTRY* pSrcPalette,[In] const void* pSrcRect,[In] D3DX_FILTER Filter,[In] int ColorKey)</unmanaged>	
        /// <unmanaged-short>D3DXLoadSurfaceFromSurface</unmanaged-short>	
        public static void LoadSurfaceFromSurface(SharpDX.Direct3D9.Surface destSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destRectRef, SharpDX.Direct3D9.Surface srcSurfaceRef, SharpDX.Direct3D9.PaletteEntry[] srcPaletteRef, System.IntPtr srcRectRef, SharpDX.Direct3D9.Filter filter, int colorKey) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    fixed (void* srcPaletteRef_ = srcPaletteRef)
                        __result__= 
        				D3DXLoadSurfaceFromSurface_((void*)((destSurfaceRef == null)?IntPtr.Zero:destSurfaceRef.NativePointer), destPaletteRef_, (void*)destRectRef, (void*)((srcSurfaceRef == null)?IntPtr.Zero:srcSurfaceRef.NativePointer), srcPaletteRef_, (void*)srcRectRef, unchecked((int)filter), colorKey);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadSurfaceFromSurface", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadSurfaceFromSurface_(void* arg0,void* arg1,void* arg2,void* arg3,void* arg4,void* arg5,int arg6,int arg7);

        
        /// <summary>	
        /// <p>Loads a volume from a file in memory.</p>	
        /// </summary>	
        /// <param name="destVolumeRef"><dd>  <p>Pointer to an <strong><see cref="SharpDX.Direct3D9.Volume"/></strong> interface. Specifies the destination volume.</p> </dd></param>	
        /// <param name="destPaletteRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.PaletteEntry"/></strong> structure, the destination palette of 256 colors or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="destBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the destination box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="srcDataRef"><dd>  <p>Pointer to the file in memory from which to load the volume.</p> </dd></param>	
        /// <param name="srcDataSize"><dd>  <p>Size in bytes of the file in memory.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.Box"/></strong> structure. Specifies the source box. Set this parameter to <strong><c>null</c></strong> to specify the entire volume.</p> </dd></param>	
        /// <param name="filter"><dd>  <p>Combination of one or more <see cref="SharpDX.Direct3D9.Filter"/>, controlling how the image is filtered. Specifying D3DX_DEFAULT for this parameter is the equivalent of specifying <see cref="SharpDX.Direct3D9.Filter.Triangle"/> | <see cref="SharpDX.Direct3D9.Filter.Dither"/>.</p> </dd></param>	
        /// <param name="colorKey"><dd>  <p> <strong><see cref="SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> value to replace with transparent black, or 0 to disable the colorkey. This is always a 32-bit ARGB color, independent of the source image format. Alpha is significant and should usually be set to FF for opaque color keys. Thus, for opaque black, the value would be equal to 0xFF000000.</p> </dd></param>	
        /// <param name="srcInfoRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D9.ImageInformation"/></strong> structure to be filled with a description of the data in the source image file, or <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Direct3D9.ResultCode.Success"/>. If the function fails, the return value can be one of the following: <see cref="SharpDX.Direct3D9.ResultCode.InvalidCall"/>, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>This function handles conversion to and from compressed texture formats and supports the following file formats: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. See <strong><see cref="SharpDX.Direct3D9.ImageFileFormat"/></strong>.</p><p>Writing to a non-level-zero surface of the volume texture will not cause the dirty rectangle to be updated. If <strong><see cref="SharpDX.Direct3D9.D3DX9.LoadVolumeFromFileInMemory"/></strong> is called and the texture was not already dirty (this is unlikely under normal usage scenarios), the application needs to explicitly call <strong><see cref="SharpDX.Direct3D9.VolumeTexture.AddDirtyBox"/></strong> on the volume texture.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXLoadVolumeFromFileInMemory']/*"/>	
        /// <msdn-id>bb172906</msdn-id>	
        /// <unmanaged>HRESULT D3DXLoadVolumeFromFileInMemory([In] IDirect3DVolume9* pDestVolume,[Out, Buffer] const PALETTEENTRY* pDestPalette,[In] const void* pDestBox,[In] const void* pSrcData,[In] unsigned int SrcDataSize,[In] const void* pSrcBox,[In] D3DX_FILTER Filter,[In] int ColorKey,[In] void* pSrcInfo)</unmanaged>	
        /// <unmanaged-short>D3DXLoadVolumeFromFileInMemory</unmanaged-short>	
        public static void LoadVolumeFromFileInMemory(SharpDX.Direct3D9.Volume destVolumeRef, SharpDX.Direct3D9.PaletteEntry[] destPaletteRef, System.IntPtr destBoxRef, System.IntPtr srcDataRef, int srcDataSize, System.IntPtr srcBoxRef, SharpDX.Direct3D9.Filter filter, int colorKey, System.IntPtr srcInfoRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* destPaletteRef_ = destPaletteRef)
                    __result__= 
    				D3DXLoadVolumeFromFileInMemory_((void*)((destVolumeRef == null)?IntPtr.Zero:destVolumeRef.NativePointer), destPaletteRef_, (void*)destBoxRef, (void*)srcDataRef, srcDataSize, (void*)srcBoxRef, unchecked((int)filter), colorKey, (void*)srcInfoRef);		
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXLoadVolumeFromFileInMemory", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXLoadVolumeFromFileInMemory_(void* arg0,void* arg1,void* arg2,void* arg3,int arg4,void* arg5,int arg6,int arg7,void* arg8);

        
        /// <summary>	
        /// <p>Creates an instance of an <strong><see cref="SharpDX.Direct3D9.XFile"/></strong> object.</p>	
        /// </summary>	
        /// <param name="lplpDirectXFile">No documentation.</param>	
        /// <returns><p>If the function succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the function fails, the return value can be one of the following: E_POINTER, E_OUTOFMEMORY.</p></returns>	
        /// <remarks>	
        /// <p>After using this function, use <strong>RegisterTemplates</strong> or <strong>RegisterEnumTemplates</strong> to register  templates, <strong>CreateEnumObject</strong> to create an enumerator object, or <strong>CreateSaveObject</strong> to create a save object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='D3DXFileCreate']/*"/>	
        /// <msdn-id>bb172830</msdn-id>	
        /// <unmanaged>HRESULT D3DXFileCreate([In] ID3DXFile** lplpDirectXFile)</unmanaged>	
        /// <unmanaged-short>D3DXFileCreate</unmanaged-short>	
        public static void FileCreate(out SharpDX.Direct3D9.XFile lplpDirectXFile) {
            unsafe {
                IntPtr lplpDirectXFile_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				D3DXFileCreate_(&lplpDirectXFile_);		
                lplpDirectXFile= (lplpDirectXFile_ == IntPtr.Zero)?null:new SharpDX.Direct3D9.XFile(lplpDirectXFile_);	
                __result__.CheckError();
            }
        }

        [DllImport("d3dx9_43.dll", EntryPoint = "D3DXFileCreate", CallingConvention = CallingConvention.StdCall)]
        private unsafe static extern int D3DXFileCreate_(void* arg0);

    }
        /// <summary>	
        /// Functions	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='SharpDX.Direct3D9.ResultCode']/*"/>	
    public  partial class ResultCode {   
        
        /// <summary>Constant ConflictingRenderState.</summary>
        /// <unmanaged>D3DERR_CONFLICTINGRENDERSTATE</unmanaged>
        public static readonly SharpDX.ResultDescriptor ConflictingRenderState = new SharpDX.ResultDescriptor(-0x07789f7df, "SharpDX.Direct3D9", "D3DERR_CONFLICTINGRENDERSTATE", "ConflictingRenderState");
        
        /// <summary>Constant ConflictingTextureFilter.</summary>
        /// <unmanaged>D3DERR_CONFLICTINGTEXTUREFILTER</unmanaged>
        public static readonly SharpDX.ResultDescriptor ConflictingTextureFilter = new SharpDX.ResultDescriptor(-0x07789f7e2, "SharpDX.Direct3D9", "D3DERR_CONFLICTINGTEXTUREFILTER", "ConflictingTextureFilter");
        
        /// <summary>Constant ConflictingTexturePalette.</summary>
        /// <unmanaged>D3DERR_CONFLICTINGTEXTUREPALETTE</unmanaged>
        public static readonly SharpDX.ResultDescriptor ConflictingTexturePalette = new SharpDX.ResultDescriptor(-0x07789f7da, "SharpDX.Direct3D9", "D3DERR_CONFLICTINGTEXTUREPALETTE", "ConflictingTexturePalette");
        
        /// <summary>Constant DeviceHung.</summary>
        /// <unmanaged>D3DERR_DEVICEHUNG</unmanaged>
        public static readonly SharpDX.ResultDescriptor DeviceHung = new SharpDX.ResultDescriptor(-0x07789f78c, "SharpDX.Direct3D9", "D3DERR_DEVICEHUNG", "DeviceHung");
        
        /// <summary>Constant DeviceLost.</summary>
        /// <unmanaged>D3DERR_DEVICELOST</unmanaged>
        public static readonly SharpDX.ResultDescriptor DeviceLost = new SharpDX.ResultDescriptor(-0x07789f798, "SharpDX.Direct3D9", "D3DERR_DEVICELOST", "DeviceLost");
        
        /// <summary>Constant DeviceNotReset.</summary>
        /// <unmanaged>D3DERR_DEVICENOTRESET</unmanaged>
        public static readonly SharpDX.ResultDescriptor DeviceNotReset = new SharpDX.ResultDescriptor(-0x07789f797, "SharpDX.Direct3D9", "D3DERR_DEVICENOTRESET", "DeviceNotReset");
        
        /// <summary>Constant DeviceRemoved.</summary>
        /// <unmanaged>D3DERR_DEVICEREMOVED</unmanaged>
        public static readonly SharpDX.ResultDescriptor DeviceRemoved = new SharpDX.ResultDescriptor(-0x07789f790, "SharpDX.Direct3D9", "D3DERR_DEVICEREMOVED", "DeviceRemoved");
        
        /// <summary>Constant DriverInternalError.</summary>
        /// <unmanaged>D3DERR_DRIVERINTERNALERROR</unmanaged>
        public static readonly SharpDX.ResultDescriptor DriverInternalError = new SharpDX.ResultDescriptor(-0x07789f7d9, "SharpDX.Direct3D9", "D3DERR_DRIVERINTERNALERROR", "DriverInternalError");
        
        /// <summary>Constant InvalidCall.</summary>
        /// <unmanaged>D3DERR_INVALIDCALL</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidCall = new SharpDX.ResultDescriptor(-0x07789f794, "SharpDX.Direct3D9", "D3DERR_INVALIDCALL", "InvalidCall");
        
        /// <summary>Constant InvalidDevice.</summary>
        /// <unmanaged>D3DERR_INVALIDDEVICE</unmanaged>
        public static readonly SharpDX.ResultDescriptor InvalidDevice = new SharpDX.ResultDescriptor(-0x07789f795, "SharpDX.Direct3D9", "D3DERR_INVALIDDEVICE", "InvalidDevice");
        
        /// <summary>Constant MoreData.</summary>
        /// <unmanaged>D3DERR_MOREDATA</unmanaged>
        public static readonly SharpDX.ResultDescriptor MoreData = new SharpDX.ResultDescriptor(-0x07789f799, "SharpDX.Direct3D9", "D3DERR_MOREDATA", "MoreData");
        
        /// <summary>Constant NoAutomaticGeneration.</summary>
        /// <unmanaged>D3DOK_NOAUTOGEN</unmanaged>
        public static readonly SharpDX.ResultDescriptor NoAutomaticGeneration = new SharpDX.ResultDescriptor(141953135, "SharpDX.Direct3D9", "D3DOK_NOAUTOGEN", "NoAutomaticGeneration");
        
        /// <summary>Constant NotAvailable.</summary>
        /// <unmanaged>D3DERR_NOTAVAILABLE</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotAvailable = new SharpDX.ResultDescriptor(-0x07789f796, "SharpDX.Direct3D9", "D3DERR_NOTAVAILABLE", "NotAvailable");
        
        /// <summary>Constant NotFound.</summary>
        /// <unmanaged>D3DERR_NOTFOUND</unmanaged>
        public static readonly SharpDX.ResultDescriptor NotFound = new SharpDX.ResultDescriptor(-0x07789f79a, "SharpDX.Direct3D9", "D3DERR_NOTFOUND", "NotFound");
        
        /// <summary>Constant OutOfVideoMemory.</summary>
        /// <unmanaged>D3DERR_OUTOFVIDEOMEMORY</unmanaged>
        public static readonly SharpDX.ResultDescriptor OutOfVideoMemory = new SharpDX.ResultDescriptor(-0x07789fe84, "SharpDX.Direct3D9", "D3DERR_OUTOFVIDEOMEMORY", "OutOfVideoMemory");
        
        /// <summary>Constant PresentModeChanged.</summary>
        /// <unmanaged>S_PRESENT_MODE_CHANGED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PresentModeChanged = new SharpDX.ResultDescriptor(141953143, "SharpDX.Direct3D9", "S_PRESENT_MODE_CHANGED", "PresentModeChanged");
        
        /// <summary>Constant PresentOccluded.</summary>
        /// <unmanaged>S_PRESENT_OCCLUDED</unmanaged>
        public static readonly SharpDX.ResultDescriptor PresentOccluded = new SharpDX.ResultDescriptor(141953144, "SharpDX.Direct3D9", "S_PRESENT_OCCLUDED", "PresentOccluded");
        
        /// <summary>Constant ResidentInSharedMemory.</summary>
        /// <unmanaged>S_RESIDENT_IN_SHARED_MEMORY</unmanaged>
        public static readonly SharpDX.ResultDescriptor ResidentInSharedMemory = new SharpDX.ResultDescriptor(141953142, "SharpDX.Direct3D9", "S_RESIDENT_IN_SHARED_MEMORY", "ResidentInSharedMemory");
        
        /// <summary>Constant Success.</summary>
        /// <unmanaged>D3D_OK</unmanaged>
        public static readonly SharpDX.ResultDescriptor Success = new SharpDX.ResultDescriptor(0, "SharpDX.Direct3D9", "D3D_OK", "Success");
        
        /// <summary>Constant TooManyOperations.</summary>
        /// <unmanaged>D3DERR_TOOMANYOPERATIONS</unmanaged>
        public static readonly SharpDX.ResultDescriptor TooManyOperations = new SharpDX.ResultDescriptor(-0x07789f7e3, "SharpDX.Direct3D9", "D3DERR_TOOMANYOPERATIONS", "TooManyOperations");
        
        /// <summary>Constant UnsupportedAlphaArgument.</summary>
        /// <unmanaged>D3DERR_UNSUPPORTEDALPHAARG</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedAlphaArgument = new SharpDX.ResultDescriptor(-0x07789f7e4, "SharpDX.Direct3D9", "D3DERR_UNSUPPORTEDALPHAARG", "UnsupportedAlphaArgument");
        
        /// <summary>Constant UnsupportedAlphaOperation.</summary>
        /// <unmanaged>D3DERR_UNSUPPORTEDALPHAOPERATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedAlphaOperation = new SharpDX.ResultDescriptor(-0x07789f7e5, "SharpDX.Direct3D9", "D3DERR_UNSUPPORTEDALPHAOPERATION", "UnsupportedAlphaOperation");
        
        /// <summary>Constant UnsupportedColorArgument.</summary>
        /// <unmanaged>D3DERR_UNSUPPORTEDCOLORARG</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedColorArgument = new SharpDX.ResultDescriptor(-0x07789f7e6, "SharpDX.Direct3D9", "D3DERR_UNSUPPORTEDCOLORARG", "UnsupportedColorArgument");
        
        /// <summary>Constant UnsupportedColorOperation.</summary>
        /// <unmanaged>D3DERR_UNSUPPORTEDCOLOROPERATION</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedColorOperation = new SharpDX.ResultDescriptor(-0x07789f7e7, "SharpDX.Direct3D9", "D3DERR_UNSUPPORTEDCOLOROPERATION", "UnsupportedColorOperation");
        
        /// <summary>Constant UnsupportedFactorValue.</summary>
        /// <unmanaged>D3DERR_UNSUPPORTEDFACTORVALUE</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedFactorValue = new SharpDX.ResultDescriptor(-0x07789f7e1, "SharpDX.Direct3D9", "D3DERR_UNSUPPORTEDFACTORVALUE", "UnsupportedFactorValue");
        
        /// <summary>Constant UnsupportedTextureFilter.</summary>
        /// <unmanaged>D3DERR_UNSUPPORTEDTEXTUREFILTER</unmanaged>
        public static readonly SharpDX.ResultDescriptor UnsupportedTextureFilter = new SharpDX.ResultDescriptor(-0x07789f7de, "SharpDX.Direct3D9", "D3DERR_UNSUPPORTEDTEXTUREFILTER", "UnsupportedTextureFilter");
        
        /// <summary>Constant WasStillDrawing.</summary>
        /// <unmanaged>D3DERR_WASSTILLDRAWING</unmanaged>
        public static readonly SharpDX.ResultDescriptor WasStillDrawing = new SharpDX.ResultDescriptor(-0x07789fde4, "SharpDX.Direct3D9", "D3DERR_WASSTILLDRAWING", "WasStillDrawing");
        
        /// <summary>Constant WrongTextureFormat.</summary>
        /// <unmanaged>D3DERR_WRONGTEXTUREFORMAT</unmanaged>
        public static readonly SharpDX.ResultDescriptor WrongTextureFormat = new SharpDX.ResultDescriptor(-0x07789f7e8, "SharpDX.Direct3D9", "D3DERR_WRONGTEXTUREFORMAT", "WrongTextureFormat");
    }
}
